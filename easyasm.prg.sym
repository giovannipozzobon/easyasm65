
; ******** Source: easyasm.asm
     1                          ; EasyAsm, an assembler for the MEGA65
     2                          ; Copyright Â© 2024  Dan Sanderson
     3                          ;
     4                          ; This program is free software: you can redistribute it and/or modify
     5                          ; it under the terms of the GNU General Public License as published by
     6                          ; the Free Software Foundation, either version 3 of the License, or
     7                          ; (at your option) any later version.
     8                          ;
     9                          ; This program is distributed in the hope that it will be useful,
    10                          ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    11                          ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    12                          ; GNU General Public License for more details.
    13                          ;
    14                          ; You should have received a copy of the GNU General Public License
    15                          ; along with this program.  If not, see <https://www.gnu.org/licenses/>.
    16                          ;
    17                          ; ---------------------------------------------------------
    18                          ; easyasm : The main program
    19                          ; ---------------------------------------------------------
    20                          
    21                          !cpu m65
    22                          
    23                          kernal_base_page = $00
    24                          easyasm_base_page = $1e
    25                          execute_user_program = $1e08
    26                          save_program = $1e1a
    27                          
    28                          ; BP map (B = $1E)
    29                          ; 00 - ?? : EasyAsm dispatch; see easyasm-e.prg
    30                          
    31                          * = $100 - 74
    32                          
    33                          pass            *=*+1  ; $FF=final pass
    34                          program_counter *=*+2
    35                          
    36                          asm_flags       *=*+1
    37                          ; - The PC is defined
    38                          F_ASM_PC_DEFINED = %00000001
    39                          ; - expect_addressing_expr is forcing 16-bit addressing
    40                          F_ASM_FORCE_MASK = %00000110
    41                          F_ASM_FORCE8     = %00000010
    42                          F_ASM_FORCE16    = %00000100
    43                          ; - expect_addressing_expr subtracts address arg from PC for branching
    44                          F_ASM_AREL_MASK  = %00011000
    45                          F_ASM_AREL8      = %00001000
    46                          F_ASM_AREL16     = %00010000
    47                          F_ASM_BITBRANCH  = %00100000
    48                          ; - assembly generated at least one warning
    49                          F_ASM_WARN       = %01000000
    50                          F_ASM_SRC_TO_BUF = %10000000
    51                          
    52                          current_segment *=*+4
    53                          next_segment_pc *=*+2
    54                          next_segment_byte_addr *=*+4
    55                          stmt_tokpos     *=*+1
    56                          label_pos       *=*+1
    57                          label_length    *=*+1
    58                          
    59                          instr_line_pos        *=*+1
    60                          instr_mnemonic_id     *=*+1
    61                          instr_buf_pos         *=*+1
    62                          instr_addr_mode       *=*+2
    63                          instr_mode_rec_addr   *=*+2
    64                          instr_supported_modes *=*+2
    65                          
    66                          symtbl_next_name *=*+3
    67                          last_pc_defined_global_label *=*+2
    68                          rellabels_next *=*+3
    69                          
    70                          viewer_line_next *=*+4
    71                          viewer_buffer_next *=*+4
    72                          
    73                          current_file    *=*+4
    74                          F_FILE_MASK     = %00000011
    75                          F_FILE_CBM      = %00000000
    76                          F_FILE_PLAIN    = %00000001
    77                          F_FILE_RUNNABLE = %00000010
    78                          
    79                          expr_a          *=*+4
    80                          expr_b          *=*+4
    81                          expr_result     *=*+4
    82                          expr_flags      *=*+1
    83                          F_EXPR_BRACKET_MASK   = %00000011
    84                          F_EXPR_BRACKET_NONE   = %00000000
    85                          ; - Entire expression surrounded by parentheses
    86                          F_EXPR_BRACKET_PAREN  = %00000001
    87                          ; - Entire expression surrounded by square brackets
    88                          F_EXPR_BRACKET_SQUARE = %00000010
    89                          ; - Entire expression is a char literal
    90                          F_EXPR_BRACKET_CHARLIT = %00000011
    91                          ; - Hex/dec number literal with leading zero, or symbol assigned such a literal with =
    92                          F_EXPR_FORCE16   = %00000100
    93                          ; - Expr contains undefined symbol
    94                          F_EXPR_UNDEFINED      = %00001000
    95                          
    96                          tok_pos         *=*+1   ; Offset of tokbuf
    97                          line_pos        *=*+1   ; Offset of line_addr
    98                          err_code        *=*+1   ; Error code; 0=no error
    99                          line_addr       *=*+2   ; Addr of current BASIC line
   100                          code_ptr        *=*+2   ; 16-bit pointer, CPU
   101                          attic_ptr       *=*+4   ; 32-bit pointer, Attic
   102                          bas_ptr         *=*+4   ; 32-bit pointer, bank 0
   103                          
   104                          !if * > $100 {
   105                              !error "Exceeded BP map; move start to earlier, if possible : ", *
   106                          }
   107                          
   108                          
   109                          ; Attic map
   110                          attic_easyasm_stash = $08700000                    ; 0.0000-0.5FFF
   111                          attic_source_stash  = attic_easyasm_stash + $6000  ; 0.6000-1.36FF
   112                          attic_symbol_table  = attic_source_stash + $d700   ; 1.3700-1.56FF (8 KB)
   113                             ; If symbol table has to cross a bank boundary, check code for 16-bit addresses. :|
   114                          attic_symbol_names  = attic_symbol_table + $2000   ; 1.5700-1.B6FF (24 KB)
   115                          attic_symbol_names_end = attic_symbol_names + $6000
   116                          attic_segments      = attic_symbol_names + $6000   ; 1.B700-2.6700 (44 KB)
   117                          attic_segments_end  = attic_segments + $b000
   118                          attic_forced16s     = attic_segments + $b000       ; 2.6700-2.7D00 (5.5 KB)
   119                          attic_forced16s_end = attic_forced16s + $1600
   120                          attic_rellabels     = attic_forced16s + $1600      ; 2.7D00-2.8D00 (4 KB)
   121                          attic_rellabels_end = attic_rellabels + $1000
   122                          ; (Gap: 2.8D00-3.0000 = $7300 = 28.75 KB)
   123                          ; Save file cannot cross a bank boundary, limit 64 KB
   124                          attic_savefile_start = attic_easyasm_stash + $30000 ; 3.0000-4.0000 (64 KB)
   125                          attic_savefile_max_end = attic_savefile_start + $10000
   126                          attic_viewer_lines = attic_savefile_max_end
   127                          attic_viewer_lines_end = attic_viewer_lines + $2000 ; 4.0000-4.2000 (8 KB)
   128                          attic_viewer_buffer = attic_viewer_lines_end        ; 4.2000-5.0000 (56 KB)
   129                          attic_viewer_buffer_end = attic_viewer_buffer + $E000
   130                          
   131                          ; - Symbol table entries are 8 bytes: (name_ptr_24, flags_8, value_32)
   132                          SYMTBL_ENTRY_SIZE = 8
   133                          SYMTBL_MAX_ENTRIES = (attic_symbol_names-attic_symbol_table) / SYMTBL_ENTRY_SIZE
   134                          ; - Symbol is defined in the current pass; value is valid
   135                          F_SYMTBL_DEFINED  = %00000001
   136                          ; - Symbol was assigned a number literal with leading zeroes
   137                          F_SYMTBL_LEADZERO = %00000010
   138                          
   139                          
   140                          ; Other memory
   141                          source_start = $2000  ; bank 0
   142                          tokbuf = $7e00        ; bank 5
   143                          strbuf = $7f00        ; bank 5
   144                          max_end_of_program = tokbuf
   145                          
   146                          ; KERNAL routines
   147                          basin = $ffcf
   148                          bsout = $ffd2
   149                          chkin = $ffc6
   150                          ckout = $ffc9
   151                          close = $ffc3
   152                          close_all = $ff50
   153                          clrch = $ffcc
   154                          open = $ffc0
   155                          primm = $ff7d
   156                          readss = $ffb7
   157                          setbnk = $ff6b
   158                          setlfs = $ffba
   159                          setnam = $ffbd
   160                          
   161                          ; MEGA65 registers
   162                          dmaimm   = $d707
   163                          dmamb    = $d704
   164                          dmaba    = $d702
   165                          dmahi    = $d701
   166                          dmalo_e  = $d705
   167                          mathbusy = $d70f
   168                          divrema  = $d768
   169                          divquot  = $d76c
   170                          multina  = $d770
   171                          multinb  = $d774
   172                          product  = $d778
   173                          asciikey = $d610
   174                          
   175                          ; Character constants
   176                          chr_cr = 13
   177                          chr_spc = 32
   178                          chr_shiftspc = 160
   179                          chr_tab = 9
   180                          chr_uparrow = 94
   181                          chr_backarrow = 95
   182                          chr_megaat = 164
   183                          chr_doublequote = 34
   184                          chr_singlequote = 39
   185                          
   186                          
   187                          ; Call a given KERNAL routine
   188                          !macro kcall .kaddr {
   189                              pha
   190                              lda #kernal_base_page
   191                              tab
   192                              pla
   193                              jsr .kaddr
   194                              pha
   195                              lda #easyasm_base_page
   196                              tab
   197                              pla
   198                          }
   199                          
   200                          ; Call KERNAL primm
   201                          ; Wrap string to print in +kprimm_start and +kprimm_end
   202                          !macro kprimm_start {
   203                              pha
   204                              lda #kernal_base_page
   205                              tab
   206                              pla
   207                              jsr primm
   208                          }
   209                          !macro kprimm_end {
   210                              pha
   211                              lda #easyasm_base_page
   212                              tab
   213                              pla
   214                          }
   215                          
   216                          !macro debug_print .msg {
   217                              +kprimm_start
   218                              !pet .msg
   219                              !byte 0
   220                              +kprimm_end
   221                          }
   222                          
   223                          !macro debug_print16 .msg, .addr {
   224                              lda #'['
   225                              +kcall bsout
   226                              +debug_print .msg
   227                              lda .addr+1
   228                              jsr print_hex8
   229                              lda .addr
   230                              jsr print_hex8
   231                              lda #']'
   232                              +kcall bsout
   233                          }
   234                          
   235                          !macro push32 .addr {
   236                              lda .addr
   237                              pha
   238                              lda .addr+1
   239                              pha
   240                              lda .addr+2
   241                              pha
   242                              lda .addr+3
   243                              pha
   244                          }
   245                          
   246                          !macro pull32 .addr {
   247                              pla
   248                              sta .addr+3
   249                              pla
   250                              sta .addr+2
   251                              pla
   252                              sta .addr+1
   253                              pla
   254                              sta .addr
   255                          }
   256                          
   257                          !macro cmp16 .a, .b {
   258                              lda .a+1
   259                              cmp .b+1
   260                              bne +
   261                              lda .a
   262                              cmp .b
   263                          +
   264                          }
   265                          
   266                          ; ------------------------------------------------------------
   267                          ; Dispatch
   268                          ; ------------------------------------------------------------
   269                          
   270                          * = $2000    ; Actually $52000
   271                          
   272  2000 4c3220                 jmp dispatch
   273                          id_string:
   274  2003 4541535941534d20...    !pet "easyasm v0.1",0
   275                          
   276                          ; Initialize
   277                          ; - Assume entry conditions (B, bank 5, MAP)
   278                          init:
   279                              ; Init pointer banks
   280  2010 a908                   lda #attic_easyasm_stash >> 24
   281  2012 85fb                   sta attic_ptr+3
   282  2014 a970                   lda #(attic_easyasm_stash >> 16) & $ff
   283  2016 85fa                   sta attic_ptr+2
   284  2018 a900                   lda #$00
   285  201a 85ff                   sta bas_ptr+3
   286  201c 85fe                   sta bas_ptr+2
   287                          
   288  201e a900                   lda #0
   289  2020 85b9                   sta asm_flags
   290                          
   291  2022 200334                 jsr init_symbol_table
   292  2025 206535                 jsr init_segment_table
   293  2028 20a038                 jsr init_forced16
   294  202b 205539                 jsr init_rellabel_table
   295  202e 20d32f                 jsr init_viewer
   296                          
   297  2031 60                     rts
   298                          
   299                          
   300                          ; All entry into EasyAsm comes through here.
   301                          ; MAPL = (E)500  MAPH = (8)300  B = $1Exx
   302                          ; A = dispatch index (1-indexed)
   303                          dispatch:
   304  2032 48                     pha
   305  2033 201020                 jsr init
   306  2036 8a                     txa
   307  2037 a8                     tay  ; Y = argument
   308  2038 68                     pla
   309                              ; Continue to invoke_menu_option...
   310                          
   311                          ; A = menu option or 0 for menu, Y = argument (reserved)
   312                          invoke_menu_option:
   313  2039 0a                     asl
   314  203a aa                     tax   ; X = A*2
   315  203b 7c3e20                 jmp (dispatch_jump,x)
   316                          dispatch_jump:
   317  203e c420                   !word do_menu
   318  2040 7023                   !word assemble_to_memory_cmd
   319  2042 862b                   !word assemble_to_disk_cmd
   320  2044 9224                   !word view_annotated_source_cmd
   321  2046 2825                   !word view_symbol_list_cmd
   322  2048 5220                   !word dummy_menu_option
   323  204a 5220                   !word dummy_menu_option
   324  204c 5220                   !word dummy_menu_option
   325  204e 1357                   !word run_test_suite_cmd
   326  2050 392c                   !word restore_source_cmd
   327                          
   328                          dummy_menu_option:
   329  2052 60                     rts
   330                          
   331                          do_banner:
   332  2053 48a9005b68207dff       +kprimm_start
   333  205b 2020202020202020...    !pet "                                           ",13
   334  2087 acacac2000             !pet 172,172,172," ",0
   335  208c 48a91e5b68             +kprimm_end
   336  2091 a203                   ldx #<id_string
   337  2093 a020                   ldy #>id_string
   338  2095 208a2c                 jsr print_cstr
   339  2098 48a9005b68207dff       +kprimm_start
   340  20a0 2c20425920444444...    !pet ", by dddaaannn ",187,187,187,"         ",13,13,0
   341  20be 48a91e5b68             +kprimm_end
   342  20c3 60                     rts
   343                          
   344                          do_menu:
   345  20c4 a993                   lda #147
   346  20c6 48a9005b6820d2ff...    +kcall bsout
   347  20d3 205320                 jsr do_banner
   348                          
   349                              ; Flush keyboard buffer
   350  20d6 8d10d6             -   sta asciikey
   351  20d9 ad10d6                 lda asciikey
   352  20dc d0f8                   bne -
   353                          
   354  20de 48a9005b68207dff       +kprimm_start
   355  20e6 48545450533a2f2f...    !pet "https://github.com/dansanderson/easyasm65",13,13
   356  2111 20312e2041535345...    !pet " 1. assemble and test",13
   357  2127 20322e2041535345...    !pet " 2. assemble to disk",13
   358                              ; !pet " 3. view annotated source",13
   359                              ; !pet " 4. view symbol list",13,13
   360  213c 0d20392e20524553...    !pet 13," 9. restore source",13,13
   361  2151 2052554e2f53544f...    !pet " run/stop: close menu",13,13
   362  2168 20594f5552204348...    !pet " your choice? ",15,166,143,157,0  ; 198 bytes
   363  217b 48a91e5b68             +kprimm_end
   364                          
   365  2180 ad10d6             -   lda asciikey
   366  2183 f0fb                   beq -
   367  2185 8d10d6                 sta asciikey
   368  2188 c903                   cmp #3  ; Stop key
   369  218a f03f                   beq @exit_menu
   370  218c c931                   cmp #'1'
   371  218e 90f0                   bcc -
   372  2190 c939                   cmp #'9'
   373  2192 f004                   beq +
   374                              ; cmp #'4'+1
   375  2194 c933                   cmp #'2'+1
   376  2196 b0e8                   bcs -
   377                          +
   378  2198 48a9005b6820d2ff...    +kcall bsout
   379  21a5 48                     pha
   380  21a6 a90d                   lda #chr_cr
   381  21a8 48a9005b6820d2ff...    +kcall bsout
   382  21b5 48a9005b6820d2ff...    +kcall bsout
   383  21c2 68                     pla
   384  21c3 38                     sec
   385  21c4 e930                   sbc #'1'-1
   386  21c6 a000                   ldy #0
   387  21c8 4c3920                 jmp invoke_menu_option
   388                          
   389                          @exit_menu
   390  21cb 48a9005b68207dff       +kprimm_start
   391  21d3 53544f500d00           !pet "stop",13,0
   392  21d9 48a91e5b68             +kprimm_end
   393  21de a900                   lda #0
   394  21e0 8d9100                 sta $0091  ; Suppress Break Error (naughty!)
   395  21e3 60                     rts
   396                          
   397                          
   398                          ; ------------------------------------------------------------
   399                          ; Assemble to Memory command
   400                          ; ------------------------------------------------------------
   401                          
   402                          ; Input: expr_a = ptr to segment entry
   403                          do_overlap_error_segment:
   404  21e4 48a9005b68207dff       +kprimm_start
   405  21ec 20202400               !pet "  $",0
   406  21f0 48a91e5b68             +kprimm_end
   407  21f5 a300                   ldz #0
   408  21f7 4242eab2e4             ldq [expr_a]
   409  21fc 48                     pha
   410  21fd 8a                     txa
   411  21fe 208a2d                 jsr print_hex8
   412  2201 68                     pla
   413  2202 208a2d                 jsr print_hex8
   414  2205 db                     phz
   415  2206 5a                     phy
   416  2207 48a9005b68207dff       +kprimm_start
   417  220f 2c2000                 !pet ", ",0
   418  2212 48a91e5b68             +kprimm_end
   419  2217 a900                   lda #0
   420  2219 a8                     tay
   421  221a 4b                     taz
   422  221b 68                     pla
   423  221c fa                     plx
   424  221d 20d22c                 jsr print_dec32
   425  2220 48a9005b68207dff       +kprimm_start
   426  2228 2042595445530d00       !pet " bytes",13,0
   427  2230 48a91e5b68             +kprimm_end
   428  2235 60                     rts
   429                          
   430                          do_overlap_error:
   431  2236 206038                 jsr do_any_segments_overlap
   432  2239 b001                   bcs +
   433  223b 60                     rts
   434  223c 48a9005b68207dff   +   +kprimm_start
   435  2244 43414e4e4f542041...    !pet "cannot assemble when segments overlap:",13,0
   436  226c 48a91e5b68             +kprimm_end
   437  2271 4242a5ba               ldq current_segment
   438  2275 424285e4               stq expr_a
   439  2279 20e421                 jsr do_overlap_error_segment
   440  227c 4242a5ec               ldq expr_result
   441  2280 424285e4               stq expr_a
   442  2284 20e421                 jsr do_overlap_error_segment
   443  2287 38                     sec
   444  2288 60                     rts
   445                          
   446                          do_warning_prompt:
   447  2289 a5b9                   lda asm_flags
   448  228b 2940                   and #F_ASM_WARN
   449  228d d002                   bne +
   450  228f 18                     clc
   451  2290 60                     rts
   452  2291 48a9005b68207dff   +   +kprimm_start
   453  2299 0d50524553532041...    !pet 13,"press a key to run, or run/stop: ",15,166,143,157,0
   454  22c0 48a91e5b68             +kprimm_end
   455  22c5 8d10d6             -   sta asciikey
   456  22c8 ad10d6                 lda asciikey
   457  22cb d0f8                   bne -
   458  22cd ad10d6             -   lda asciikey
   459  22d0 f0fb                   beq -
   460  22d2 8d10d6                 sta asciikey
   461  22d5 c903                   cmp #3  ; Stop key
   462  22d7 d01b                   bne +
   463  22d9 48a9005b68207dff       +kprimm_start
   464  22e1 53544f500d0d00         !pet "stop",13,13,0
   465  22e8 48a91e5b68             +kprimm_end
   466  22ed a900                   lda #0
   467  22ef 8d9100                 sta $0091  ; Suppress Break Error (naughty!)
   468  22f2 38                     sec
   469  22f3 60                     rts
   470  22f4 48a9005b68207dff   +   +kprimm_start
   471  22fc 4f4b0d0d00             !pet "ok",13,13,0
   472  2301 48a91e5b68             +kprimm_end
   473  2306 18                     clc
   474  2307 60                     rts
   475                          
   476                          install_segments_to_memory:
   477  2308 38                     sec
   478  2309 201437                 jsr start_segment_traversal
   479                          @loop
   480  230c 208137                 jsr is_end_segment_traversal
   481  230f 9001                   bcc +
   482  2311 60                     rts
   483  2312 a300               +   ldz #0
   484  2314 4242eab2ba             ldq [current_segment]
   485  2319 8d6a23                 sta install_segments_to_memory_dma_to
   486  231c 8e6b23                 stx install_segments_to_memory_dma_to+1
   487  231f 8c6523                 sty install_segments_to_memory_dma_length
   488  2322 9c6623                 stz install_segments_to_memory_dma_length+1
   489  2325 a900                   lda #0
   490  2327 85e5                   sta expr_a+1
   491  2329 85e6                   sta expr_a+2
   492  232b 85e7                   sta expr_a+3
   493  232d a904                   lda #4
   494  232f 85e4                   sta expr_a
   495  2331 4242a5ba               ldq current_segment
   496  2335 424265e4               adcq expr_a
   497  2339 8d6723                 sta install_segments_to_memory_dma_from
   498  233c 8e6823                 stx install_segments_to_memory_dma_from+1
   499  233f 98                     tya
   500  2340 290f                   and #$0f
   501  2342 8d6923                 sta install_segments_to_memory_dma_from+2
   502                          
   503  2345 a900                   lda #0
   504  2347 8d04d7                 sta dmamb
   505  234a a905                   lda #$05
   506  234c 8d02d7                 sta dmaba
   507  234f a923                   lda #>install_segments_to_memory_dma
   508  2351 8d01d7                 sta dmahi
   509  2354 a95e                   lda #<install_segments_to_memory_dma
   510  2356 8d05d7                 sta dmalo_e
   511                          
   512  2359 207a37                 jsr next_segment_traversal_skip_file_markers
   513  235c 80ae                   bra @loop
   514                          
   515                          install_segments_to_memory_dma:
   516  235e 8087               !byte $80, <(attic_segments >>> 20)
   517  2360 8100               !byte $81, $00
   518  2362 0b                 !byte $0b
   519  2363 00                 !byte $00
   520  2364 00                 !byte $00  ; copy
   521                          install_segments_to_memory_dma_length:
   522  2365 0000               !byte $00, $00
   523                          install_segments_to_memory_dma_from:
   524  2367 000000             !byte $00, $00, $00
   525                          install_segments_to_memory_dma_to:
   526  236a 000000             !byte $00, $00, $00
   527  236d 000000             !byte $00, $00, $00
   528                          
   529                          assemble_to_memory_cmd:
   530  2370 48a9005b68207dff       +kprimm_start
   531  2378 2320415353454d42...    !pet "# assembling...",13,13,0
   532  238a 48a91e5b68             +kprimm_end
   533                          
   534                              ; Assemble, abort on assembly error.
   535  238f 205e2c                 jsr stash_source
   536  2392 20d44b                 jsr assemble_source
   537  2395 a5f3                   lda err_code
   538  2397 f033                   beq +
   539  2399 20c02d                 jsr print_error
   540  239c 48a9005b68207dff       +kprimm_start
   541  23a4 0d2320415353454d...    !pet 13,"# assembly encountered an error",13,0
   542  23c6 48a91e5b68             +kprimm_end
   543  23cb 60                     rts
   544                          
   545                              ; Error if segments overlap.
   546  23cc 203622             +   jsr do_overlap_error
   547  23cf 9001                   bcc +
   548  23d1 60                     rts
   549                          
   550                              ; Error if a segment overlaps EasyAsm memory.
   551  23d2 a900               +   lda #$00
   552  23d4 a21e                   ldx #$1e
   553  23d6 a000                   ldy #$00
   554  23d8 a301                   ldz #$01
   555  23da 18                     clc
   556  23db 20bd37                 jsr does_a_segment_overlap
   557  23de 9057                   bcc +
   558  23e0 48a9005b68207dff       +kprimm_start
   559  23e8 5345474d454e5420...    !pet "segment overlaps easyasm $1e00-ff, cannot assemble to memory",13,0
   560  2426 48a91e5b68             +kprimm_end
   561  242b 4242a5ba               ldq current_segment
   562  242f 424285e4               stq expr_a
   563  2433 20e421                 jsr do_overlap_error_segment
   564  2436 60                     rts
   565                          
   566                              ; If warnings emitted, pause before continuing.
   567  2437 208922             +   jsr do_warning_prompt
   568  243a 9001                   bcc +
   569  243c 60                     rts
   570                          
   571  243d 200823             +   jsr install_segments_to_memory
   572  2440 38                     sec
   573  2441 201437                 jsr start_segment_traversal
   574  2444 a300                   ldz #0
   575  2446 4242eab2ba             ldq [current_segment]
   576  244b 1b                     inz
   577  244c ea12ba                 ora [current_segment],z
   578  244f f00a                   beq +  ; Edge case: no assembled instructions
   579  2451 a300                   ldz #0
   580  2453 4242eab2ba             ldq [current_segment]
   581  2458 20081e                 jsr execute_user_program  ; A/X = PC
   582                          +
   583                          
   584  245b 20742c                 jsr restore_source
   585  245e 48a9005b68207dff       +kprimm_start
   586  2466 0d232050524f4752...    !pet 13,"# program returned, source restored",13,0
   587  248c 48a91e5b68             +kprimm_end
   588                          
   589  2491 60                     rts
   590                          
   591                          
   592                          ; ------------------------------------------------------------
   593                          ; View Annotated Source command
   594                          ; ------------------------------------------------------------
   595                          
   596                          view_annotated_source_cmd:
   597  2492 a5b9                   lda asm_flags
   598  2494 0980                   ora #F_ASM_SRC_TO_BUF
   599  2496 85b9                   sta asm_flags
   600                          
   601  2498 48a9005b68207dff       +kprimm_start
   602  24a0 232047454e455241...    !pet "# generating annotated source...",13,13,0
   603  24c3 48a91e5b68             +kprimm_end
   604                          
   605                              ; Assemble, abort on assembly error.
   606  24c8 205e2c                 jsr stash_source
   607  24cb 20d44b                 jsr assemble_source
   608  24ce a5f3                   lda err_code
   609  24d0 f033                   beq +
   610  24d2 20c02d                 jsr print_error
   611  24d5 48a9005b68207dff       +kprimm_start
   612  24dd 0d2320415353454d...    !pet 13,"# assembly encountered an error",13,0
   613  24ff 48a91e5b68             +kprimm_end
   614  2504 60                     rts
   615                          
   616  2505 205030             +   jsr activate_viewer
   617                          
   618  2508 48a9005b68207dff       +kprimm_start
   619  2510 0d23205649455745...    !pet 13,"# viewer ended",13,0
   620  2521 48a91e5b68             +kprimm_end
   621                          
   622  2526 60                     rts
   623                          
   624                          
   625                          ; ------------------------------------------------------------
   626                          ; View Symbols command
   627                          ; ------------------------------------------------------------
   628                          
   629                          write_symbol_list:
   630  2527 60                     rts
   631                          
   632                          view_symbol_list_cmd:
   633  2528 48a9005b68207dff       +kprimm_start
   634  2530 232047454e455241...    !pet "# generating annotated source...",13,13,0
   635  2553 48a91e5b68             +kprimm_end
   636                          
   637                              ; Assemble, abort on assembly error.
   638  2558 205e2c                 jsr stash_source
   639  255b 20d44b                 jsr assemble_source
   640  255e a5f3                   lda err_code
   641  2560 f033                   beq +
   642  2562 20c02d                 jsr print_error
   643  2565 48a9005b68207dff       +kprimm_start
   644  256d 0d2320415353454d...    !pet 13,"# assembly encountered an error",13,0
   645  258f 48a91e5b68             +kprimm_end
   646  2594 60                     rts
   647                          +
   648  2595 202725                 jsr write_symbol_list
   649  2598 205030                 jsr activate_viewer
   650                          
   651  259b 48a9005b68207dff       +kprimm_start
   652  25a3 0d23205649455745...    !pet 13,"# viewer ended",13,0
   653  25b4 48a91e5b68             +kprimm_end
   654                          
   655  25b9 60                     rts
   656                          
   657                          
   658                          ; ------------------------------------------------------------
   659                          ; Assemble to Disk command
   660                          ; ------------------------------------------------------------
   661                          
   662                          ; Inputs: X = tok_pos A, Y = tok_pos B
   663                          ;   tokbuf at those positions = 32-bit segment addresses
   664                          ; Output: C=0: A < B; C=1: A >= B
   665                          ; Uses expr_b, program_counter
   666                          compare_segments_for_sort:
   667  25ba bd007e                 lda tokbuf,x
   668  25bd 85e8                   sta expr_b
   669  25bf bd017e                 lda tokbuf+1,x
   670  25c2 85e9                   sta expr_b+1
   671  25c4 bd027e                 lda tokbuf+2,x
   672  25c7 85ea                   sta expr_b+2
   673  25c9 bd037e                 lda tokbuf+3,x
   674  25cc 85eb                   sta expr_b+3
   675  25ce a300                   ldz #0
   676  25d0 eab2e8                 lda [expr_b],z
   677  25d3 85b7                   sta program_counter
   678  25d5 1b                     inz
   679  25d6 eab2e8                 lda [expr_b],z
   680  25d9 85b8                   sta program_counter+1
   681                          
   682  25db b9007e                 lda tokbuf,y
   683  25de 85e8                   sta expr_b
   684  25e0 b9017e                 lda tokbuf+1,y
   685  25e3 85e9                   sta expr_b+1
   686  25e5 b9027e                 lda tokbuf+2,y
   687  25e8 85ea                   sta expr_b+2
   688  25ea b9037e                 lda tokbuf+3,y
   689  25ed 85eb                   sta expr_b+3
   690  25ef a301                   ldz #1
   691  25f1 a5b8                   lda program_counter+1
   692  25f3 ead2e8                 cmp [expr_b],z
   693  25f6 d006                   bne +
   694  25f8 3b                     dez
   695  25f9 a5b7                   lda program_counter
   696  25fb ead2e8                 cmp [expr_b],z
   697                          +
   698  25fe 60                     rts
   699                          
   700                          ; Inputs: X = tok_pos A, Y = tok_pos B
   701                          ;   tokbuf at those positions = 32-bit segment addresses
   702                          ; Outputs: entries swapped in tokbuf
   703                          ; Uses expr_b
   704                          swap_segments_for_sort:
   705  25ff 20ba25                 jsr compare_segments_for_sort
   706  2602 b001                   bcs +
   707  2604 60                     rts
   708                          +
   709  2605 bd007e                 lda tokbuf,x
   710  2608 85e8                   sta expr_b
   711  260a bd017e                 lda tokbuf+1,x
   712  260d 85e9                   sta expr_b+1
   713  260f bd027e                 lda tokbuf+2,x
   714  2612 85ea                   sta expr_b+2
   715  2614 bd037e                 lda tokbuf+3,x
   716  2617 85eb                   sta expr_b+3
   717                          
   718  2619 b9007e                 lda tokbuf,y
   719  261c 9d007e                 sta tokbuf,x
   720  261f b9017e                 lda tokbuf+1,y
   721  2622 9d017e                 sta tokbuf+1,x
   722  2625 b9027e                 lda tokbuf+2,y
   723  2628 9d027e                 sta tokbuf+2,x
   724  262b b9037e                 lda tokbuf+3,y
   725  262e 9d037e                 sta tokbuf+3,x
   726                          
   727  2631 a5e8                   lda expr_b
   728  2633 99007e                 sta tokbuf,y
   729  2636 a5e9                   lda expr_b+1
   730  2638 99017e                 sta tokbuf+1,y
   731  263b a5ea                   lda expr_b+2
   732  263d 99027e                 sta tokbuf+2,y
   733  2640 a5eb                   lda expr_b+3
   734  2642 99037e                 sta tokbuf+3,y
   735                          
   736  2645 60                     rts
   737                          
   738                          ; Inputs: Y=tokbuf pos, line_pos=strbuf pos
   739                          ; Outputs: strbuf added 4 bytes; line_pos advanced; Y=new tokbuf pos
   740                          add_segment_entry_to_strbuf_for_merge:
   741  2646 a6f2                   ldx line_pos
   742  2648 a304                   ldz #4
   743  264a b9007e             -   lda tokbuf,y
   744  264d 9d007f                 sta strbuf,x
   745  2650 c8                     iny
   746  2651 e8                     inx
   747  2652 3b                     dez
   748  2653 d0f5                   bne -
   749  2655 86f2                   stx line_pos
   750  2657 60                     rts
   751                          
   752                          ; Inputs: A=start A, X=end A+4=start B, Y=end B+4
   753                          ; Outputs: merges sorted entry ranges in tokbuf
   754                          ; Uses expr_a, expr_b, strbuf, line_pos
   755                          merge_segments_for_sort:
   756  2658 48                     pha  ; hoo boy, this is for the very end
   757                          
   758  2659 85e4                   sta expr_a    ; expr_a[0] = A list pos
   759  265b 86e5                   stx expr_a+1  ; expr_a[1] = B list pos
   760  265d 86e6                   stx expr_a+2  ; expr_a[2] = A list end+4
   761  265f 84e7                   sty expr_a+3  ; expr_a[3] = B list end+4
   762  2661 a900                   lda #0
   763  2663 85f2                   sta line_pos  ; line_pos = strbuf pos
   764                          
   765                              ; Assumes each list has at least one element.
   766                          @merge_loop
   767  2665 a6e4                   ldx expr_a
   768  2667 a4e5                   ldy expr_a+1
   769  2669 20ba25                 jsr compare_segments_for_sort
   770  266c b00d                   bcs +
   771                              ; Consume A
   772  266e a4e4                   ldy expr_a
   773  2670 204626                 jsr add_segment_entry_to_strbuf_for_merge
   774  2673 c4e6                   cpy expr_a+2
   775  2675 f01c                   beq @rest_of_b
   776  2677 84e4                   sty expr_a
   777  2679 80ea                   bra @merge_loop
   778                          +   ; Consume B
   779  267b a4e5                   ldy expr_a+1
   780  267d 204626                 jsr add_segment_entry_to_strbuf_for_merge
   781  2680 c4e7                   cpy expr_a+3
   782  2682 f004                   beq @rest_of_a
   783  2684 84e5                   sty expr_a+1
   784  2686 80dd                   bra @merge_loop
   785                          
   786                          @rest_of_a
   787                              ; Consume rest of A
   788  2688 a4e4                   ldy expr_a
   789  268a 204626             -   jsr add_segment_entry_to_strbuf_for_merge
   790  268d c4e6                   cpy expr_a+2
   791  268f d0f9                   bne -
   792  2691 8009                   bra @copy_strbuf_to_tokbuf
   793                          @rest_of_b
   794                              ; Consume rest of B
   795  2693 a4e5                   ldy expr_a+1
   796  2695 204626             -   jsr add_segment_entry_to_strbuf_for_merge
   797  2698 c4e7                   cpy expr_a+3
   798  269a d0f9                   bne -
   799                          @copy_strbuf_to_tokbuf
   800  269c a5f2                   lda line_pos
   801  269e 4b                     taz
   802  269f a200                   ldx #0
   803  26a1 68                     pla
   804  26a2 a8                     tay
   805  26a3 bd007f             -   lda strbuf,x
   806  26a6 99007e                 sta tokbuf,y
   807  26a9 e8                     inx
   808  26aa c8                     iny
   809  26ab 3b                     dez
   810  26ac d0f5                   bne -
   811  26ae 60                     rts
   812                          
   813                          ; Inputs: X = start tok_pos, Y = end tok_pos+1
   814                          ;   tokbuf in that range = list of 32-bit segment addresses
   815                          ; Outputs: tokbuf sorted; tok_pos reset to tokbuf length
   816                          ; Called recursively.
   817                          ; Uses expr_a[0:1], expr_b internally, protected across recursive calls.
   818                          sort_segment_list:
   819  26af 86e4                   stx expr_a
   820  26b1 84e5                   sty expr_a+1
   821  26b3 98                     tya
   822  26b4 38                     sec
   823  26b5 e5e4                   sbc expr_a
   824  26b7 c908                   cmp #8
   825  26b9 b001                   bcs +
   826                              ; < 2 items
   827  26bb 60                     rts
   828  26bc d00c               +   bne ++
   829                              ; = 2 items
   830                              ; (Special-casing 2 entries makes midpoint calculation easier later.)
   831  26be a5e4                   lda expr_a
   832  26c0 aa                     tax
   833  26c1 1a                     inc
   834  26c2 1a                     inc
   835  26c3 1a                     inc
   836  26c4 1a                     inc
   837  26c5 a8                     tay
   838  26c6 20ff25                 jsr swap_segments_for_sort
   839  26c9 60                     rts
   840                          
   841                          ++  ; > 2 items
   842  26ca 43                     asr
   843  26cb 43                     asr  ; A = # of items
   844  26cc 43                     asr  ; A = floor(# of items / 2)
   845  26cd 0a                     asl
   846  26ce 0a                     asl  ; A = tokbuf offset from X to midpoint entry
   847  26cf 65e4                   adc expr_a  ; A = start + midpoint offset
   848                          
   849                              ; sort_segment_list(expr_a[0], A)
   850  26d1 a8                     tay
   851  26d2 48                     pha
   852  26d3 a5e4                   lda expr_a
   853  26d5 48                     pha
   854  26d6 a5e5                   lda expr_a+1
   855  26d8 48                     pha
   856  26d9 a6e4                   ldx expr_a
   857  26db 20af26                 jsr sort_segment_list
   858  26de 68                     pla
   859  26df 85e5                   sta expr_a+1
   860  26e1 68                     pla
   861  26e2 85e4                   sta expr_a
   862  26e4 68                     pla
   863                          
   864                              ; sort_segment_list(A, expr_a[1])
   865  26e5 aa                     tax
   866  26e6 48                     pha
   867  26e7 a5e4                   lda expr_a
   868  26e9 48                     pha
   869  26ea a5e5                   lda expr_a+1
   870  26ec 48                     pha
   871  26ed a8                     tay
   872  26ee 20af26                 jsr sort_segment_list
   873  26f1 68                     pla
   874  26f2 85e5                   sta expr_a+1
   875  26f4 68                     pla
   876  26f5 85e4                   sta expr_a
   877  26f7 68                     pla
   878                          
   879                              ; merge [expr_a[0],A) and [A, expr_a[1])
   880                              ; (Clobbers expr_a, but that's ok)
   881  26f8 aa                     tax
   882  26f9 a5e4                   lda expr_a
   883  26fb a4e5                   ldy expr_a+1
   884  26fd 205826                 jsr merge_segments_for_sort
   885  2700 60                     rts
   886                          
   887                          
   888                          ; Inputs: current_file; current_segment = first segment; assembled segments
   889                          ; Outputs:
   890                          ;   current_segment advanced to next file marker or null terminator
   891                          ;   segment table entry addresses to tokbuf
   892                          ;   tok_pos is index beyond list; number of segments = tok_pos/4
   893                          ;   C=1: too many segments (max 64), result invalid
   894                          generate_segment_list_for_file:
   895  2701 a900                   lda #0
   896  2703 85f1                   sta tok_pos
   897                          
   898                          @loop
   899  2705 a6f1                   ldx tok_pos
   900  2707 a5ba                   lda current_segment
   901  2709 9d007e                 sta tokbuf,x
   902  270c e8                     inx
   903  270d a5bb                   lda current_segment+1
   904  270f 9d007e                 sta tokbuf,x
   905  2712 e8                     inx
   906  2713 a5bc                   lda current_segment+2
   907  2715 9d007e                 sta tokbuf,x
   908  2718 e8                     inx
   909  2719 a5bd                   lda current_segment+3
   910  271b 9d007e                 sta tokbuf,x
   911  271e e8                     inx
   912  271f 86f1                   stx tok_pos
   913                          
   914  2721 e000                   cpx #0
   915  2723 d002                   bne +
   916  2725 38                     sec
   917  2726 60                     rts
   918                          +
   919                          
   920  2727 202f37                 jsr next_segment_traversal
   921  272a 208137                 jsr is_end_segment_traversal
   922  272d 9002                   bcc +
   923  272f 8006                   bra @end
   924  2731 209837             +   jsr is_file_marker_segment_traversal
   925  2734 93cfff                 lbcc @loop
   926                          @end
   927                          
   928                              ; Sort tokbuf by segment PC
   929  2737 a200                   ldx #0
   930  2739 a4f1                   ldy tok_pos
   931  273b 20af26                 jsr sort_segment_list
   932                          
   933  273e 18                     clc
   934  273f 60                     rts
   935                          
   936                          
   937                          ; Input: current_file = file marker
   938                          print_current_filename:
   939  2740 a304                   ldz #4
   940  2742 4242eab2e0             ldq [current_file]
   941  2747 85f4                   sta line_addr
   942  2749 86f5                   stx line_addr+1
   943  274b 84fe                   sty bas_ptr+2
   944  274d 64ff                   stz bas_ptr+3
   945  274f a308                   ldz #8
   946  2751 eab2e0                 lda [current_file],z
   947  2754 a8                     tay
   948  2755 a200                   ldx #0
   949  2757 20ab2c                 jsr print_bas_str
   950  275a 60                     rts
   951                          
   952                          ; Input: current_file = file marker
   953                          print_current_filetype:
   954  275b a309                   ldz #9
   955  275d eab2e0                 lda [current_file],z
   956  2760 2903                   and #F_FILE_MASK
   957  2762 c900                   cmp #F_FILE_CBM
   958  2764 d006                   bne +
   959  2766 a23d                   ldx #<kw_cbm
   960  2768 a052                   ldy #>kw_cbm
   961  276a 800e                   bra ++
   962  276c c901               +   cmp #F_FILE_PLAIN
   963  276e d006                   bne +
   964  2770 a241                   ldx #<kw_plain
   965  2772 a052                   ldy #>kw_plain
   966  2774 8004                   bra ++
   967  2776 a247               +   ldx #<kw_runnable
   968  2778 a052                   ldy #>kw_runnable
   969  277a 208a2c             ++  jsr print_cstr
   970  277d 60                     rts
   971                          
   972                          
   973                          ; Input: current_segment -> segment header
   974                          ; Output:
   975                          ;   program_counter = segment PC
   976                          ;   expr_a = size
   977                          get_header_for_current_segment:
   978  277e a300                   ldz #0
   979  2780 eab2ba                 lda [current_segment],z
   980  2783 85b7                   sta program_counter
   981  2785 1b                     inz
   982  2786 eab2ba                 lda [current_segment],z
   983  2789 85b8                   sta program_counter+1  ; program_counter = segment PC
   984  278b 1b                     inz
   985  278c eab2ba                 lda [current_segment],z
   986  278f 85e4                   sta expr_a
   987  2791 1b                     inz
   988  2792 eab2ba                 lda [current_segment],z
   989  2795 85e5                   sta expr_a+1
   990  2797 a900                   lda #0
   991  2799 85e6                   sta expr_a+2
   992  279b 85e7                   sta expr_a+3  ; expr_a = size
   993  279d 60                     rts
   994                          
   995                          ; Inputs:
   996                          ;   program_counter = PC of last file
   997                          ;   expr_b = size of last file
   998                          ;   current_segment -> current segment header
   999                          ; Outputs:
  1000                          ;   expr_a = size of zero fill
  1001                          calculate_zero_fill:
  1002                              ; this PC - prev PC - expr_b = size of zero fill
  1003  279e a300                   ldz #0
  1004  27a0 eab2ba                 lda [current_segment],z
  1005  27a3 38                     sec
  1006  27a4 e5b7                   sbc program_counter
  1007  27a6 85e4                   sta expr_a
  1008  27a8 1b                     inz
  1009  27a9 eab2ba                 lda [current_segment],z
  1010  27ac e5b8                   sbc program_counter+1
  1011  27ae 85e5                   sta expr_a+1
  1012  27b0 a900                   lda #0
  1013  27b2 85e6                   sta expr_a+2
  1014  27b4 85e7                   sta expr_a+3  ; expr_a = this PC - prev PC
  1015  27b6 4242a5e4               ldq expr_a
  1016  27ba 38                     sec
  1017  27bb 4242e5e8               sbcq expr_b
  1018  27bf 424285e4               stq expr_a    ; expr_a = size of zero fill
  1019  27c3 60                     rts
  1020                          
  1021                          append_zero_fill_dma:
  1022  27c4 8187               !byte $81, <(attic_savefile_start >> 20)
  1023  27c6 0b00               !byte $0b, $00
  1024  27c8 03                 !byte $03
  1025  27c9 0000               append_zero_fill_length: !byte $00, $00
  1026  27cb 000000             !byte $00, $00, $00
  1027  27ce 000000             append_zero_fill_dest: !byte $00, $00, $00
  1028  27d1 000000             !byte $00, $00, $00
  1029                          
  1030                          ; Input: expr_a = number of zeroes to write
  1031                          ;   attic_ptr = dest
  1032                          ; Outputs: attic_ptr advanced
  1033                          append_zero_fill:
  1034  27d4 a5f8                   lda attic_ptr
  1035  27d6 8dce27                 sta append_zero_fill_dest
  1036  27d9 a5f9                   lda attic_ptr+1
  1037  27db 8dcf27                 sta append_zero_fill_dest+1
  1038  27de a5fa                   lda attic_ptr+2
  1039  27e0 290f                   and #$0f
  1040  27e2 8dd027                 sta append_zero_fill_dest+2
  1041                          
  1042  27e5 a5e4                   lda expr_a
  1043  27e7 8dc927                 sta append_zero_fill_length
  1044  27ea a5e5                   lda expr_a+1
  1045  27ec 8dca27                 sta append_zero_fill_length+1
  1046                          
  1047  27ef a900                   lda #$00
  1048  27f1 8d04d7                 sta dmamb
  1049  27f4 a905                   lda #$05
  1050  27f6 8d02d7                 sta dmaba
  1051  27f9 a927                   lda #>append_zero_fill_dma
  1052  27fb 8d01d7                 sta dmahi
  1053  27fe a9c4                   lda #<append_zero_fill_dma
  1054  2800 8d05d7                 sta dmalo_e
  1055                          
  1056  2803 4242a5e4               ldq expr_a
  1057  2807 18                     clc
  1058  2808 424265f8               adcq attic_ptr
  1059  280c 424285f8               stq attic_ptr
  1060  2810 60                     rts
  1061                          
  1062                          append_to_save_file_dma:
  1063  2811 80                 !byte $80
  1064  2812 00                 append_to_save_file_source_mb: !byte $00
  1065  2813 8187               !byte $81, <(attic_savefile_start >> 20)
  1066  2815 0b00               !byte $0b, $00
  1067  2817 00                 !byte $00
  1068  2818 0000               append_to_save_file_length: !byte $00, $00
  1069  281a 000000             append_to_save_file_source: !byte $00, $00, $00
  1070  281d 000000             append_to_save_file_dest: !byte $00, $00, $00
  1071  2820 000000             !byte $00, $00, $00
  1072                          
  1073                          ; Inputs: expr_result = start addr (32-bit); expr_a = length (16-bit)
  1074                          ;   attic_ptr = dest
  1075                          ; Outputs: attic_ptr advanced
  1076                          append_to_save_file:
  1077                              ; Start address: $0abcdefg
  1078                              ; append_to_save_file_source_mb = $ab
  1079                              ; append_to_save_file_source = $fg $de $0c
  1080  2823 a5ef                   lda expr_result+3
  1081  2825 0a                     asl
  1082  2826 0a                     asl
  1083  2827 0a                     asl
  1084  2828 0a                     asl
  1085  2829 85ef                   sta expr_result+3  ; (corrupt expr_result+3)
  1086  282b a5ee                   lda expr_result+2
  1087  282d 4a                     lsr
  1088  282e 4a                     lsr
  1089  282f 4a                     lsr
  1090  2830 4a                     lsr
  1091  2831 05ef                   ora expr_result+3
  1092  2833 8d1228                 sta append_to_save_file_source_mb
  1093  2836 a5ee                   lda expr_result+2
  1094  2838 290f                   and #$0f
  1095  283a 8d1c28                 sta append_to_save_file_source+2
  1096  283d a5ed                   lda expr_result+1
  1097  283f 8d1b28                 sta append_to_save_file_source+1
  1098  2842 a5ec                   lda expr_result
  1099  2844 8d1a28                 sta append_to_save_file_source
  1100                          
  1101  2847 a5e4                   lda expr_a
  1102  2849 8d1828                 sta append_to_save_file_length
  1103  284c a5e5                   lda expr_a+1
  1104  284e 8d1928                 sta append_to_save_file_length+1
  1105                          
  1106  2851 a5f8                   lda attic_ptr
  1107  2853 8d1d28                 sta append_to_save_file_dest
  1108  2856 a5f9                   lda attic_ptr+1
  1109  2858 8d1e28                 sta append_to_save_file_dest+1
  1110  285b a5fa                   lda attic_ptr+2
  1111  285d 290f                   and #$0f
  1112  285f 8d1f28                 sta append_to_save_file_dest+2
  1113                          
  1114  2862 a900                   lda #$00
  1115  2864 8d04d7                 sta dmamb
  1116  2867 a905                   lda #$05
  1117  2869 8d02d7                 sta dmaba
  1118  286c a928                   lda #>append_to_save_file_dma
  1119  286e 8d01d7                 sta dmahi
  1120  2871 a911                   lda #<append_to_save_file_dma
  1121  2873 8d05d7                 sta dmalo_e
  1122                          
  1123  2876 4242a5e4               ldq expr_a
  1124  287a 18                     clc
  1125  287b 424265f8               adcq attic_ptr
  1126  287f 424285f8               stq attic_ptr
  1127  2883 60                     rts
  1128                          
  1129                          ; Inputs: program_counter = PC, expr_a = size
  1130                          print_segment_msg:
  1131                              ; Print segment msg
  1132  2884 48a9005b68207dff       +kprimm_start
  1133  288c 20202400               !pet "  $",0
  1134  2890 48a91e5b68             +kprimm_end
  1135  2895 a5b8                   lda program_counter+1
  1136  2897 208a2d                 jsr print_hex8
  1137  289a a5b7                   lda program_counter
  1138  289c 208a2d                 jsr print_hex8
  1139  289f 48a9005b68207dff       +kprimm_start
  1140  28a7 2c2000                 !pet ", ",0
  1141  28aa 48a91e5b68             +kprimm_end
  1142  28af 4242a5e4               ldq expr_a
  1143  28b3 20d22c                 jsr print_dec32
  1144  28b6 48a9005b68207dff       +kprimm_start
  1145  28be 2042595445530d00       !pet " bytes",13,0
  1146  28c6 48a91e5b68             +kprimm_end
  1147  28cb 60                     rts
  1148                          
  1149                          ; Writes formatted file to attic_savefile_start
  1150                          ; Input: current_file; tokbuf, tok_pos=end with sorted segments
  1151                          write_file_to_attic:
  1152                              ; Stash current_segment so we can reuse some routines.
  1153  28cc 4242a5ba               ldq current_segment
  1154  28d0 424285fc               stq bas_ptr
  1155                          
  1156  28d4 4242ad007e             ldq tokbuf
  1157  28d9 424285ba               stq current_segment
  1158  28dd 207e27                 jsr get_header_for_current_segment
  1159                          
  1160  28e0 a973                   lda #^attic_savefile_start
  1161  28e2 85fa                   sta attic_ptr+2
  1162  28e4 a908                   lda #<(attic_savefile_start >> 24)
  1163  28e6 85fb                   sta attic_ptr+3
  1164                          
  1165  28e8 a309                   ldz #9
  1166  28ea eab2e0                 lda [current_file],z
  1167  28ed 2903                   and #F_FILE_MASK
  1168  28ef c902                   cmp #F_FILE_RUNNABLE
  1169  28f1 f00b                   beq @start_runnable
  1170                          
  1171                              ; Set Attic memory start position to align with PC
  1172                              ; (required for SAVE later to get the PC correct)
  1173  28f3 a5b7                   lda program_counter
  1174  28f5 85f8                   sta attic_ptr
  1175  28f7 1b                     inz
  1176  28f8 a5b8                   lda program_counter+1
  1177  28fa 85f9                   sta attic_ptr+1
  1178  28fc 8023                   bra @start_segment_loop
  1179                          
  1180                          @start_runnable
  1181                              ; Set Attic memory start position to source_start + 1.
  1182  28fe a901                   lda #<(source_start+1)
  1183  2900 85f8                   sta attic_ptr
  1184  2902 a920                   lda #>(source_start+1)
  1185  2904 85f9                   sta attic_ptr+1
  1186                          
  1187                              ; Write the runnable bootstrap.
  1188  2906 a900                   lda #<bootstrap_basic_preamble
  1189  2908 a257                   ldx #>bootstrap_basic_preamble
  1190  290a a005                   ldy #$05
  1191  290c a300                   ldz #$00
  1192  290e 424285ec               stq expr_result
  1193  2912 a913                   lda #<(bootstrap_basic_preamble_end-bootstrap_basic_preamble)
  1194  2914 a200                   ldx #>(bootstrap_basic_preamble_end-bootstrap_basic_preamble)
  1195  2916 a000                   ldy #$00
  1196  2918 a300                   ldz #$00
  1197  291a 424285e4               stq expr_a
  1198  291e 202328                 jsr append_to_save_file
  1199                          
  1200                          @start_segment_loop
  1201                          
  1202  2921 a000                   ldy #0  ; token list position
  1203                          @segment_loop
  1204  2923 c4f1                   cpy tok_pos
  1205  2925 f34900                 lbeq @end_segment_loop
  1206  2928 5a                     phy  ; Stash segment list position
  1207                          
  1208                              ; current_segment = this segment's address (from segment list)
  1209  2929 b9007e                 lda tokbuf,y
  1210  292c 85ba                   sta current_segment
  1211  292e b9017e                 lda tokbuf+1,y
  1212  2931 85bb                   sta current_segment+1
  1213  2933 b9027e                 lda tokbuf+2,y
  1214  2936 85bc                   sta current_segment+2
  1215  2938 b9037e                 lda tokbuf+3,y
  1216  293b 85bd                   sta current_segment+3
  1217                          
  1218  293d c000                   cpy #0
  1219  293f f006                   beq +
  1220                              ; Not first segment, fill with zeroes
  1221                              ; Expects program_counter and expr_b=size from previous loop
  1222  2941 209e27                 jsr calculate_zero_fill
  1223  2944 20d427                 jsr append_zero_fill
  1224                          +
  1225                          
  1226  2947 207e27                 jsr get_header_for_current_segment
  1227                              ; program_counter = PC, expr_a = size
  1228  294a 4242a5e4               ldq expr_a
  1229  294e 424285e8               stq expr_b  ; Remember size for zero fill later
  1230                          
  1231  2952 208428                 jsr print_segment_msg
  1232  2955 a900                   lda #0
  1233  2957 aa                     tax
  1234  2958 a8                     tay
  1235  2959 4b                     taz
  1236  295a a904                   lda #4  ; Q = 4
  1237  295c 18                     clc
  1238  295d 424265ba               adcq current_segment
  1239  2961 424285ec               stq expr_result
  1240                              ; expr_result = start = current_segment + 4
  1241  2965 202328                 jsr append_to_save_file
  1242                          
  1243  2968 7a                     ply  ; Advance segment list position
  1244  2969 c8                     iny
  1245  296a c8                     iny
  1246  296b c8                     iny
  1247  296c c8                     iny
  1248  296d 83b4ff                 lbra @segment_loop
  1249                          
  1250                          @end_segment_loop
  1251                              ; Restore outer file loop's current_segment
  1252  2970 4242a5fc               ldq bas_ptr
  1253  2974 424285ba               stq current_segment
  1254  2978 60                     rts
  1255                          
  1256                          
  1257                          ; Input: assembled segment table with file markers
  1258                          ; Output: err_code>0 fatal error, abort
  1259                          create_files_for_segments:
  1260  2979 18                     clc
  1261  297a 201437                 jsr start_segment_traversal
  1262                          
  1263                              ; No segments at all? Say so, exit ok.
  1264  297d 208137                 jsr is_end_segment_traversal
  1265  2980 901d                   bcc +
  1266  2982 48a9005b68207dff       +kprimm_start
  1267  298a 4e4f5448494e4720...    !pet "nothing to do",13,0
  1268  2999 48a91e5b68             +kprimm_end
  1269  299e 60                     rts
  1270                          +
  1271                              ; First segment not a file marker? Error.
  1272  299f 209837                 jsr is_file_marker_segment_traversal
  1273  29a2 b00b                   bcs +
  1274  29a4 a911                   lda #err_segment_without_a_file
  1275  29a6 85f3                   sta err_code
  1276  29a8 a900                   lda #$00
  1277  29aa 85f4                   sta line_addr
  1278  29ac 85f5                   sta line_addr+1
  1279  29ae 60                     rts
  1280                          +
  1281                          
  1282                          @file_loop
  1283                              ; current_segment is a file marker.
  1284  29af 4242a5ba               ldq current_segment
  1285  29b3 424285e0               stq current_file
  1286  29b7 202f37                 jsr next_segment_traversal
  1287  29ba a922                   lda #chr_doublequote
  1288  29bc 48a9005b6820d2ff...    +kcall bsout
  1289  29c9 204027                 jsr print_current_filename
  1290  29cc 48a9005b68207dff       +kprimm_start
  1291  29d4 222c2000               !pet "\", ",0
  1292  29d8 48a91e5b68             +kprimm_end
  1293  29dd 205b27                 jsr print_current_filetype
  1294                          
  1295                              ; Check for empty file states.
  1296  29e0 208137                 jsr is_end_segment_traversal
  1297  29e3 b005                   bcs +
  1298  29e5 209837                 jsr is_file_marker_segment_traversal
  1299  29e8 9035                   bcc ++
  1300  29ea 48a9005b68207dff   +   +kprimm_start
  1301  29f2 3a204e4f20534547...    !pet ": no segments for file, skipping",13,0
  1302  2a14 48a91e5b68             +kprimm_end
  1303  2a19 209837                 jsr is_file_marker_segment_traversal
  1304  2a1c b091                   bcs @file_loop
  1305                              ; Early end of segments.
  1306  2a1e 60                     rts
  1307  2a1f a93a               ++  lda #':'
  1308  2a21 48a9005b6820d2ff...    +kcall bsout
  1309  2a2e a90d                   lda #chr_cr
  1310  2a30 48a9005b6820d2ff...    +kcall bsout
  1311                          
  1312                              ; Generate segment list for file on tokbuf, sorted by PC.
  1313                              ; This advances current_segment to the next file marker,
  1314                              ; for the end of the file loop to test.
  1315  2a3d 200127                 jsr generate_segment_list_for_file
  1316  2a40 900b                   bcc +
  1317  2a42 a906                   lda #err_out_of_memory
  1318  2a44 85f3                   sta err_code
  1319  2a46 a900                   lda #$00
  1320  2a48 85f4                   sta line_addr
  1321  2a4a 85f5                   sta line_addr+1
  1322  2a4c 60                     rts
  1323                          +
  1324                              ; Confirm runnable type only has one segment at bootstrap location
  1325  2a4d a309                   ldz #9
  1326  2a4f eab2e0                 lda [current_file],z
  1327  2a52 2903                   and #F_FILE_MASK
  1328  2a54 c902                   cmp #F_FILE_RUNNABLE
  1329  2a56 d02b                   bne ++
  1330  2a58 a5f1                   lda tok_pos
  1331  2a5a c904                   cmp #4
  1332  2a5c d01a                   bne +
  1333  2a5e 4242ad007e             ldq tokbuf
  1334  2a63 424285e4               stq expr_a
  1335  2a67 a300                   ldz #0
  1336  2a69 eab2e4                 lda [expr_a],z
  1337  2a6c c914                   cmp #<bootstrap_ml_start
  1338  2a6e d008                   bne +
  1339  2a70 1b                     inz
  1340  2a71 eab2e4                 lda [expr_a],z
  1341  2a74 c920                   cmp #>bootstrap_ml_start
  1342  2a76 f00b                   beq ++
  1343  2a78 a914               +   lda #err_runnable_wrong_segments
  1344  2a7a 85f3                   sta err_code
  1345  2a7c a900                   lda #$00
  1346  2a7e 85f4                   sta line_addr
  1347  2a80 85f5                   sta line_addr+1
  1348  2a82 60                     rts
  1349                          ++
  1350                          
  1351  2a83 20cc28                 jsr write_file_to_attic
  1352  2a86 a5fa                   lda attic_ptr+2
  1353  2a88 c973                   cmp #^attic_savefile_start
  1354  2a8a f00b                   beq +
  1355                              ; Total file size exceeds 64 KB, abort with error
  1356  2a8c a906                   lda #err_out_of_memory
  1357  2a8e 85f3                   sta err_code
  1358  2a90 a900                   lda #$00
  1359  2a92 85f4                   sta line_addr
  1360  2a94 85f5                   sta line_addr+1
  1361  2a96 60                     rts
  1362                          +
  1363                          
  1364                              ; Copy "@:" and filename to strbuf, use it for filename
  1365  2a97 a940                   lda #'@'
  1366  2a99 8d007f                 sta strbuf
  1367  2a9c a93a                   lda #':'
  1368  2a9e 8d017f                 sta strbuf+1
  1369  2aa1 a304                   ldz #4
  1370  2aa3 4242eab2e0             ldq [current_file]  ; Q = address of filename
  1371  2aa8 424285e4               stq expr_a
  1372  2aac a308                   ldz #8
  1373  2aae eab2e0                 lda [current_file],z  ; A = filename length
  1374  2ab1 a8                     tay     ; Y = length
  1375  2ab2 a202                   ldx #2  ; strbuf pos
  1376  2ab4 a300                   ldz #0  ; data pos
  1377  2ab6 eab2e4             -   lda [expr_a],z
  1378  2ab9 9d007f                 sta strbuf,x
  1379  2abc e8                     inx
  1380  2abd 1b                     inz
  1381  2abe 88                     dey
  1382  2abf d0f5                   bne -
  1383                          
  1384                              ; Set up the file
  1385  2ac1 a988                   lda #($80 | <(attic_savefile_start >> 24)); file MB
  1386  2ac3 a073                   ldy #^attic_savefile_start
  1387  2ac5 a205                   ldx #5  ; strbuf bank
  1388  2ac7 48a9005b68206bff...    +kcall setbnk
  1389  2ad4 a200                   ldx #<strbuf
  1390  2ad6 a07f                   ldy #>strbuf
  1391  2ad8 a308                   ldz #8
  1392  2ada eab2e0                 lda [current_file],z  ; A = filename length
  1393  2add 1a                     inc
  1394  2ade 1a                     inc  ; For "@:" prefix
  1395  2adf 48a9005b6820bdff...    +kcall setnam
  1396  2aec a902                   lda #2    ; logical address 2
  1397  2aee a201                   ldx #1    ; default device
  1398  2af0 a002                   ldy #2    ; disks want a secondary address
  1399  2af2 48a9005b6820baff...    +kcall setlfs
  1400                          
  1401                              ; Determine the starting address for SAVE
  1402  2aff a309                   ldz #9
  1403  2b01 eab2e0                 lda [current_file],z
  1404  2b04 2903                   and #F_FILE_MASK
  1405  2b06 c902                   cmp #F_FILE_RUNNABLE
  1406  2b08 f01c                   beq +
  1407                              ; cbm starts at first PC
  1408  2b0a a000                   ldy #0
  1409  2b0c 4242b9007e             ldq tokbuf,y
  1410  2b11 424285e8               stq expr_b
  1411  2b15 a300                   ldz #0
  1412  2b17 eab2e8                 lda [expr_b],z
  1413  2b1a 8dfe00                 sta $00fe
  1414  2b1d 1b                     inz
  1415  2b1e eab2e8                 lda [expr_b],z
  1416  2b21 8dff00                 sta $00ff
  1417  2b24 800a                   bra ++
  1418                          +   ; Runnable starts at source_start+1
  1419  2b26 a901                   lda #<(source_start+1)
  1420  2b28 8dfe00                 sta $00fe
  1421  2b2b a920                   lda #>(source_start+1)
  1422  2b2d 8dff00                 sta $00ff
  1423                          
  1424                              ; X/Y = 16-bit end address + 1
  1425  2b30 a6f8               ++  ldx attic_ptr
  1426  2b32 a4f9                   ldy attic_ptr+1
  1427  2b34 201a1e                 jsr save_program
  1428  2b37 b007                   bcs @kernal_disk_error
  1429                          
  1430                              ; There might be a drive error at this point. Reading it would require
  1431                              ; more dispatch code to open the command channel, so I'm going to leave it
  1432                              ; for now and let the user type the @ command to test disk status.
  1433                          
  1434                              ; (current_segment advanced to next file marker or end by
  1435                              ; generate_segment_list_for_file earlier. Preserved by
  1436                              ; write_file_to_attic.)
  1437  2b39 208137                 jsr is_end_segment_traversal
  1438  2b3c 9371fe                 lbcc @file_loop
  1439  2b3f 60                     rts
  1440                          
  1441                          @kernal_disk_error
  1442                              ; A = error code
  1443  2b40 48                     pha
  1444  2b41 48a9005b6820ccff...    +kcall clrch
  1445  2b4e 68                     pla
  1446  2b4f 3a                     dec
  1447  2b50 0a                     asl
  1448  2b51 aa                     tax
  1449  2b52 bd804e                 lda kernal_error_messages+1,x
  1450  2b55 a8                     tay
  1451  2b56 bd7f4e                 lda kernal_error_messages,x
  1452  2b59 aa                     tax
  1453  2b5a 208a2c                 jsr print_cstr
  1454  2b5d a92c                   lda #','
  1455  2b5f 48a9005b6820d2ff...    +kcall bsout
  1456  2b6c a920                   lda #' '
  1457  2b6e 48a9005b6820d2ff...    +kcall bsout
  1458  2b7b a912                   lda #err_disk_error
  1459  2b7d 85f3                   sta err_code
  1460  2b7f a900                   lda #$00
  1461  2b81 85f4                   sta line_addr
  1462  2b83 85f5                   sta line_addr+1
  1463  2b85 60                     rts
  1464                          
  1465                          
  1466                          assemble_to_disk_cmd:
  1467  2b86 48a9005b68207dff       +kprimm_start
  1468  2b8e 2320415353454d42...    !pet "# assembling to disk...",13,13,0
  1469  2ba8 48a91e5b68             +kprimm_end
  1470                          
  1471                              ; Assemble, abort on assembly error.
  1472  2bad 205e2c                 jsr stash_source
  1473  2bb0 20d44b                 jsr assemble_source
  1474  2bb3 a5f3                   lda err_code
  1475  2bb5 d34500                 lbne @assemble_to_disk_error
  1476                          
  1477                              ; Error if segments overlap.
  1478  2bb8 203622                 jsr do_overlap_error
  1479  2bbb b33b00                 lbcs @assemble_to_disk_error_no_pos
  1480                          
  1481                              ; If warnings emitted, pause before continuing.
  1482  2bbe 208922                 jsr do_warning_prompt
  1483  2bc1 9001                   bcc +
  1484  2bc3 60                     rts
  1485                          +
  1486                          
  1487  2bc4 207929                 jsr create_files_for_segments
  1488  2bc7 a5f3                   lda err_code
  1489  2bc9 d02d                   bne @assemble_to_disk_error_no_pos
  1490                          
  1491  2bcb 48a9005b68207dff       +kprimm_start
  1492  2bd3 0d0d232041535345...    !pet 13,13,"# assemble to disk complete",13,0
  1493  2bf2 48a91e5b68             +kprimm_end
  1494  2bf7 60                     rts
  1495                          
  1496                          @assemble_to_disk_error_no_pos
  1497  2bf8 a9ff                   lda #$ff
  1498  2bfa 85f2                   sta line_pos
  1499                          @assemble_to_disk_error
  1500  2bfc 20c02d                 jsr print_error
  1501  2bff 48a9005b68207dff       +kprimm_start
  1502  2c07 0d0d232041535345...    !pet 13,13,"# assemble to disk aborted due to error",13,13,0
  1503  2c33 48a91e5b68             +kprimm_end
  1504  2c38 60                     rts
  1505                          
  1506                          
  1507                          ; ------------------------------------------------------------
  1508                          ; Restore Source command
  1509                          ; ------------------------------------------------------------
  1510                          
  1511                          restore_source_cmd:
  1512  2c39 20742c                 jsr restore_source
  1513                          
  1514  2c3c 48a9005b68207dff       +kprimm_start
  1515  2c44 0d2320534f555243...    !pet 13,"# source restored",13,0
  1516  2c58 48a91e5b68             +kprimm_end
  1517                          
  1518  2c5d 60                     rts
  1519                          
  1520                          
  1521                          stash_source:
  1522  2c5e 8d07d7                 sta dmaimm
  1523  2c61 8000                   !byte $80, $00
  1524  2c63 8187                   !byte $81, attic_source_stash >> 20
  1525  2c65 0b00                   !byte $0b, $00
  1526  2c67 0000d7                 !byte $00, $00, $d7
  1527  2c6a 002000                 !byte <source_start, >source_start, $00
  1528  2c6d 006000                 !byte <attic_source_stash, >attic_source_stash, (attic_source_stash >> 16) & $0f
  1529  2c70 000000                 !byte $00, $00, $00
  1530                          
  1531  2c73 60                     rts
  1532                          
  1533                          
  1534                          restore_source:
  1535  2c74 8d07d7                 sta dmaimm
  1536  2c77 8087                   !byte $80, attic_source_stash >> 20
  1537  2c79 8100                   !byte $81, $00
  1538  2c7b 0b00                   !byte $0b, $00
  1539  2c7d 0000d7                 !byte $00, $00, $d7
  1540  2c80 006000                 !byte <attic_source_stash, >attic_source_stash, (attic_source_stash >> 16) & $0f
  1541  2c83 002000                 !byte <source_start, >source_start, $00
  1542  2c86 000000                 !byte $00, $00, $00
  1543                          
  1544  2c89 60                     rts
  1545                          
  1546                          
  1547                          ; ------------------------------------------------------------
  1548                          ; Utilities
  1549                          ; ------------------------------------------------------------
  1550                          
  1551                          ; Print a C-style string
  1552                          ; Input: X/Y address (bank 5)
  1553                          print_cstr:
  1554                              ; Manage B manually, for speed
  1555  2c8a a900                   lda #kernal_base_page
  1556  2c8c 5b                     tab
  1557                          
  1558  2c8d 86fc                   stx $fc   ; B=0
  1559  2c8f 84fd                   sty $fd
  1560  2c91 a905                   lda #$05
  1561  2c93 85fe                   sta $fe
  1562  2c95 a900                   lda #$00
  1563  2c97 85ff                   sta $ff
  1564                          
  1565  2c99 a300               -   ldz #0
  1566  2c9b eab2fc                 lda [$fc],z
  1567  2c9e f007                   beq +
  1568  2ca0 20d2ff                 jsr bsout
  1569  2ca3 e3fc                   inw $fc
  1570  2ca5 80f2                   bra -
  1571                          +
  1572                              ; Restore B
  1573  2ca7 a91e                   lda #easyasm_base_page
  1574  2ca9 5b                     tab
  1575  2caa 60                     rts
  1576                          
  1577                          
  1578                          ; Print a string from a source line
  1579                          ; Input: line_addr, X=line pos, Y=length; bas_ptr bank and megabyte
  1580                          print_bas_str:
  1581  2cab a5f4                   lda line_addr
  1582  2cad 8dfc00                 sta $00fc
  1583  2cb0 a5f5                   lda line_addr+1
  1584  2cb2 8dfd00                 sta $00fd
  1585  2cb5 a5fe                   lda bas_ptr+2
  1586  2cb7 8dfe00                 sta $00fe
  1587  2cba a5ff                   lda bas_ptr+3
  1588  2cbc 8dff00                 sta $00ff
  1589                          
  1590                              ; Manage B manually, for speed
  1591  2cbf a900                   lda #kernal_base_page
  1592  2cc1 5b                     tab
  1593                          
  1594  2cc2 8a                     txa
  1595  2cc3 4b                     taz
  1596  2cc4 eab2fc             -   lda [$fc],z
  1597  2cc7 20d2ff                 jsr bsout
  1598  2cca 1b                     inz
  1599  2ccb 88                     dey
  1600  2ccc d0f6                   bne -
  1601                          
  1602                              ; Restore B
  1603  2cce a91e                   lda #easyasm_base_page
  1604  2cd0 5b                     tab
  1605  2cd1 60                     rts
  1606                          
  1607                          
  1608                          ; Input:
  1609                          ;   Q = 32-bit value (ZYXA)
  1610                          ;   C: 0=unsigned, 1=signed
  1611                          print_dec32:
  1612                              ; Use strbuf like so:
  1613                              ; $00: negative sign or null
  1614                              ; $01-$0B: 10 final characters, null terminated
  1615                              ; $0C-$10: 5 BCD bytes
  1616                              ; $11-$14: 4 binary bytes
  1617  2cd2 8d117f                 sta strbuf+$11
  1618  2cd5 8e127f                 stx strbuf+$12
  1619  2cd8 8c137f                 sty strbuf+$13
  1620  2cdb 9c147f                 stz strbuf+$14
  1621  2cde a210                   ldx #$10
  1622  2ce0 a900                   lda #0
  1623  2ce2 9d007f             -   sta strbuf,x
  1624  2ce5 ca                     dex
  1625  2ce6 10fa                   bpl -
  1626                          
  1627  2ce8 901a                   bcc @unsigned_continue
  1628  2cea 6b                     tza
  1629  2ceb 1017                   bpl @unsigned_continue
  1630  2ced a9ff                   lda #$ff       ; Negate value
  1631  2cef aa                     tax
  1632  2cf0 a8                     tay
  1633  2cf1 4b                     taz
  1634  2cf2 42424d117f             eorq strbuf+$11
  1635  2cf7 42421a                 inq
  1636  2cfa 42428d117f             stq strbuf+$11
  1637  2cff a92d                   lda #'-'       ; Put negative sign in string buffer
  1638  2d01 8d007f                 sta strbuf
  1639                          @unsigned_continue
  1640                          
  1641                              ; Using BCD mode, double-with-carry each binary digit of $11-$14 into
  1642                              ; $0C-$10. Do 16 bits at a time.
  1643  2d04 f8                     sed
  1644  2d05 a210                   ldx #16
  1645  2d07 eb137f             -   row strbuf+$13
  1646  2d0a a005                   ldy #5
  1647  2d0c b90b7f             --  lda strbuf+$0c-1,y
  1648  2d0f 790b7f                 adc strbuf+$0c-1,y
  1649  2d12 990b7f                 sta strbuf+$0c-1,y
  1650  2d15 88                     dey
  1651  2d16 d0f4                   bne --
  1652  2d18 ca                     dex
  1653  2d19 d0ec                   bne -
  1654  2d1b a210                   ldx #16
  1655  2d1d eb117f             -   row strbuf+$11
  1656  2d20 a005                   ldy #5
  1657  2d22 b90b7f             --  lda strbuf+$0c-1,y
  1658  2d25 790b7f                 adc strbuf+$0c-1,y
  1659  2d28 990b7f                 sta strbuf+$0c-1,y
  1660  2d2b 88                     dey
  1661  2d2c d0f4                   bne --
  1662  2d2e ca                     dex
  1663  2d2f d0ec                   bne -
  1664  2d31 d8                     cld
  1665                          
  1666                              ; Convert BCD in $0C-$10 to PETSCII digits in $01-$0B.
  1667  2d32 a204                   ldx #4
  1668  2d34 8a                 -   txa
  1669  2d35 0a                     asl
  1670  2d36 a8                     tay   ; Y = 2*x
  1671  2d37 bd0c7f                 lda strbuf+$0c,x
  1672  2d3a 4a                     lsr
  1673  2d3b 4a                     lsr
  1674  2d3c 4a                     lsr
  1675  2d3d 4a                     lsr
  1676  2d3e 18                     clc
  1677  2d3f 6930                   adc #'0'
  1678  2d41 99017f                 sta strbuf+$01,y
  1679  2d44 bd0c7f                 lda strbuf+$0c,x
  1680  2d47 290f                   and #$0f
  1681  2d49 18                     clc
  1682  2d4a 6930                   adc #'0'
  1683  2d4c 99027f                 sta strbuf+$02,y
  1684  2d4f ca                     dex
  1685  2d50 10e2                   bpl -
  1686                          
  1687                              ; Slide PETSCII digits left to eliminate leading zeroes.
  1688  2d52 ad017f             -   lda strbuf+$01
  1689  2d55 c930                   cmp #'0'
  1690  2d57 d014                   bne @written_continue
  1691  2d59 a202                   ldx #$02
  1692  2d5b bd007f             --  lda strbuf,x
  1693  2d5e 9dff7e                 sta strbuf-1,x
  1694  2d61 e8                     inx
  1695  2d62 e00b                   cpx #$0b
  1696  2d64 d0f5                   bne --
  1697  2d66 a900                   lda #0
  1698  2d68 9dff7e                 sta strbuf-1,x
  1699  2d6b 80e5                   bra -
  1700                          
  1701                          @written_continue
  1702  2d6d a900                   lda #0
  1703  2d6f 8d0c7f                 sta strbuf+$0c
  1704  2d72 ad017f                 lda strbuf+$01  ; Edge case: 0
  1705  2d75 d005                   bne +
  1706  2d77 a930                   lda #'0'
  1707  2d79 8d017f                 sta strbuf+$01
  1708                          +
  1709                              ; Test for negative sign, and either print from sign or from first digit.
  1710  2d7c a200                   ldx #<strbuf
  1711  2d7e a07f                   ldy #>strbuf
  1712  2d80 ad007f                 lda strbuf
  1713  2d83 d001                   bne +
  1714  2d85 e8                     inx      ; (assume doesn't cross a page boundary)
  1715  2d86 208a2c             +   jsr print_cstr
  1716  2d89 60                     rts
  1717                          
  1718                          
  1719                          ; Input: A = 8-bit value
  1720                          print_hex8:
  1721  2d8a 20ab2d                 jsr hex_az
  1722  2d8d 48                     pha
  1723  2d8e 6b                     tza
  1724  2d8f 48a9005b6820d2ff...    +kcall bsout
  1725  2d9c 68                     pla
  1726  2d9d 48a9005b6820d2ff...    +kcall bsout
  1727  2daa 60                     rts
  1728                          
  1729                          ; Input: A = byte
  1730                          ; Output: A/Z = hex digits
  1731                          hex_az:
  1732  2dab 48                     pha
  1733  2dac 4a                     lsr
  1734  2dad 4a                     lsr
  1735  2dae 4a                     lsr
  1736  2daf 4a                     lsr
  1737  2db0 20b52d                 jsr hex_nyb
  1738  2db3 4b                     taz
  1739  2db4 68                     pla
  1740                          
  1741                          hex_nyb:
  1742  2db5 290f                   and #15
  1743  2db7 c90a                   cmp #10
  1744  2db9 9002                   bcc +
  1745  2dbb 6906                   adc #6
  1746  2dbd 6930               +   adc #'0'
  1747  2dbf 60                     rts
  1748                          
  1749                          ; Input: err_code, line_pos, line_addr
  1750                          ; - If line_pos = $FF, don't print line
  1751                          ; - If line_addr = $0000, don't print line number
  1752                          print_error:
  1753  2dc0 a5f3                   lda err_code
  1754  2dc2 d001                   bne +        ; zero = no error
  1755  2dc4 60                     rts
  1756                          +
  1757                          
  1758  2dc5 3a                     dec
  1759  2dc6 0a                     asl
  1760  2dc7 aa                     tax
  1761  2dc8 bdec4b                 lda err_message_tbl+1,x
  1762  2dcb a8                     tay
  1763  2dcc bdeb4b                 lda err_message_tbl,x
  1764  2dcf aa                     tax
  1765  2dd0 208a2c                 jsr print_cstr
  1766                          
  1767  2dd3 a5f4                   lda line_addr
  1768  2dd5 05f5                   ora line_addr+1
  1769  2dd7 d010                   bne +
  1770  2dd9 a90d                   lda #chr_cr
  1771  2ddb 48a9005b6820d2ff...    +kcall bsout
  1772  2de8 60                     rts
  1773                          +
  1774                          
  1775  2de9 48a9005b68207dff       +kprimm_start
  1776  2df1 20494e204c494e45...    !pet " in line ",0
  1777  2dfb 48a91e5b68             +kprimm_end
  1778                          
  1779  2e00 a5f4                   lda line_addr
  1780  2e02 85fc                   sta bas_ptr
  1781  2e04 a5f5                   lda line_addr+1
  1782  2e06 85fd                   sta bas_ptr+1
  1783  2e08 a303                   ldz #3
  1784  2e0a eab2fc                 lda [bas_ptr],z        ; line number high
  1785  2e0d aa                     tax
  1786  2e0e 3b                     dez
  1787  2e0f eab2fc                 lda [bas_ptr],z        ; line number low
  1788  2e12 a000                   ldy #0
  1789  2e14 a300                   ldz #0
  1790  2e16 18                     clc                    ; request unsigned
  1791  2e17 48                     pha
  1792  2e18 da                     phx
  1793  2e19 20d22c                 jsr print_dec32
  1794  2e1c a90d                   lda #chr_cr
  1795  2e1e 48a9005b6820d2ff...    +kcall bsout
  1796                          
  1797                              ; Skip printing line if line_pos = $ff
  1798  2e2b a5f2                   lda line_pos
  1799  2e2d c9ff                   cmp #$ff
  1800  2e2f d003                   bne +
  1801  2e31 68                     pla
  1802  2e32 68                     pla
  1803  2e33 60                     rts
  1804                          
  1805                              ; Print line number again.
  1806  2e34 a90d               +   lda #chr_cr
  1807  2e36 48a9005b6820d2ff...    +kcall bsout
  1808  2e43 fa                     plx
  1809  2e44 68                     pla
  1810  2e45 a000                   ldy #0
  1811  2e47 a300                   ldz #0
  1812  2e49 18                     clc                    ; request unsigned
  1813  2e4a 20d22c                 jsr print_dec32
  1814                              ; Sneak a peek at strbuf to get the line number length + 1
  1815  2e4d a200                   ldx #0
  1816  2e4f e8                 -   inx
  1817  2e50 bd007f                 lda strbuf,x
  1818  2e53 d0fa                   bne -
  1819  2e55 da                     phx
  1820                          
  1821                              ; Print the source code line
  1822  2e56 a920                   lda #chr_spc
  1823  2e58 48a9005b6820d2ff...    +kcall bsout
  1824  2e65 e3fc                   inw bas_ptr
  1825  2e67 e3fc                   inw bas_ptr
  1826  2e69 e3fc                   inw bas_ptr
  1827  2e6b e3fc                   inw bas_ptr
  1828  2e6d a300                   ldz #0
  1829  2e6f a200                   ldx #0
  1830  2e71 eab2fc             -   lda [bas_ptr],z
  1831  2e74 9d007f                 sta strbuf,x
  1832  2e77 f004                   beq +
  1833  2e79 1b                     inz
  1834  2e7a e8                     inx
  1835  2e7b 80f4                   bra -
  1836  2e7d a200               +   ldx #<strbuf
  1837  2e7f a07f                   ldy #>strbuf
  1838  2e81 208a2c                 jsr print_cstr
  1839  2e84 a90d                   lda #chr_cr
  1840  2e86 48a9005b6820d2ff...    +kcall bsout
  1841                          
  1842                              ; Print an error position marker
  1843  2e93 fa                     plx           ; Indent by width of line number + 1
  1844  2e94 a920               -   lda #chr_spc
  1845  2e96 48a9005b6820d2ff...    +kcall bsout
  1846  2ea3 ca                     dex
  1847  2ea4 d0ee                   bne -
  1848  2ea6 a6f2                   ldx line_pos   ; Indent by line_pos - 4
  1849  2ea8 ca                     dex
  1850  2ea9 ca                     dex
  1851  2eaa ca                     dex
  1852  2eab ca                     dex
  1853  2eac f012                   beq +
  1854  2eae a920               -   lda #chr_spc
  1855  2eb0 48a9005b6820d2ff...    +kcall bsout
  1856  2ebd ca                     dex
  1857  2ebe d0ee                   bne -
  1858  2ec0 a95e               +   lda #chr_uparrow
  1859  2ec2 48a9005b6820d2ff...    +kcall bsout
  1860  2ecf a90d                   lda #chr_cr
  1861  2ed1 48a9005b6820d2ff...    +kcall bsout
  1862                          
  1863  2ede 60                     rts
  1864                          
  1865                          
  1866                          ; (Used by print_warning and do_warn)
  1867                          ; Inits bas_ptr=line_addr for caller to use
  1868                          print_warning_line_number:
  1869  2edf 48a9005b68207dff       +kprimm_start
  1870  2ee7 4c494e452000           !pet "line ",0
  1871  2eed 48a91e5b68             +kprimm_end
  1872  2ef2 a5f4                   lda line_addr
  1873  2ef4 85fc                   sta bas_ptr
  1874  2ef6 a5f5                   lda line_addr+1
  1875  2ef8 85fd                   sta bas_ptr+1
  1876  2efa a303                   ldz #3
  1877  2efc eab2fc                 lda [bas_ptr],z        ; line number high
  1878  2eff aa                     tax
  1879  2f00 3b                     dez
  1880  2f01 eab2fc                 lda [bas_ptr],z        ; line number low
  1881  2f04 a000                   ldy #0
  1882  2f06 a300                   ldz #0
  1883  2f08 18                     clc                    ; request unsigned
  1884  2f09 20d22c                 jsr print_dec32
  1885  2f0c 48a9005b68207dff       +kprimm_start
  1886  2f14 3a2000                 !pet ": ",0
  1887  2f17 48a91e5b68             +kprimm_end
  1888  2f1c 60                     rts
  1889                          
  1890                          
  1891                          ; Input: A=warning ID
  1892                          ; Output: prints message with line number, sets F_ASM_WARN
  1893                          print_warning:
  1894  2f1d 48                     pha
  1895  2f1e 20df2e                 jsr print_warning_line_number
  1896  2f21 68                     pla
  1897  2f22 3a                     dec
  1898  2f23 0a                     asl
  1899  2f24 aa                     tax
  1900  2f25 bd3c4e                 lda warn_message_tbl+1,x
  1901  2f28 a8                     tay
  1902  2f29 bd3b4e                 lda warn_message_tbl,x
  1903  2f2c aa                     tax
  1904  2f2d 208a2c                 jsr print_cstr
  1905                          
  1906  2f30 a90d                   lda #chr_cr
  1907  2f32 48a9005b6820d2ff...    +kcall bsout
  1908                          
  1909  2f3f a5b9                   lda asm_flags
  1910  2f41 0940                   ora #F_ASM_WARN
  1911  2f43 85b9                   sta asm_flags
  1912  2f45 60                     rts
  1913                          
  1914                          
  1915                          ; Test whether A is a letter
  1916                          ; Input: A=char
  1917                          ; Output: C: 0=no 1=yes
  1918                          is_letter:
  1919                              ; I'm leaving Acme's converstion table set to "raw" so I'm forced to
  1920                              ; understand this explicitly. PETSCII has two sets of uppercase letters.
  1921  2f46 c941                   cmp #'A'     ; $41 = PETSCII lower A
  1922  2f48 9017                   bcc ++
  1923  2f4a c95b                   cmp #'Z'+1   ; $5A = PETSCII lower Z
  1924  2f4c 9012                   bcc +
  1925  2f4e c961                   cmp #'a'     ; $61 = PETSCII upper A
  1926  2f50 900f                   bcc ++
  1927  2f52 c97b                   cmp #'z'+1   ; $7A = PETSCII upper A
  1928  2f54 900a                   bcc +
  1929  2f56 c9c1                   cmp #193     ; $C1 = PETSCII Shift-A
  1930  2f58 9007                   bcc ++
  1931  2f5a c9db                   cmp #218+1   ; $DA = PETSCII Shift-Z
  1932  2f5c 9002                   bcc +
  1933  2f5e 18                     clc
  1934  2f5f 60                     rts
  1935  2f60 38                 +   sec
  1936  2f61 60                 ++  rts
  1937                          
  1938                          
  1939                          ; Test whether A is a secondary identifier character
  1940                          ; Input: A=char
  1941                          ; Output: C: 0=no 1=yes
  1942                          is_secondary_ident_char:
  1943  2f62 c930                   cmp #'0'
  1944  2f64 9004                   bcc +
  1945  2f66 c93a                   cmp #'9'+1
  1946  2f68 900c                   bcc ++
  1947  2f6a c95f               +   cmp #chr_backarrow
  1948  2f6c f008                   beq ++
  1949  2f6e c9a4                   cmp #chr_megaat
  1950  2f70 f004                   beq ++
  1951  2f72 c92e                   cmp #'.'
  1952  2f74 d002                   bne +++
  1953  2f76 38                 ++  sec
  1954  2f77 60                     rts
  1955  2f78 4c462f             +++ jmp is_letter
  1956                          
  1957                          ; Test whether A is whitespace on a line
  1958                          ; (Does not include CR.)
  1959                          ; Input: A=char
  1960                          ; Output: C: 0=no 1=yes
  1961                          is_space:
  1962  2f7b c920                   cmp #chr_spc
  1963  2f7d f00b                   beq +
  1964  2f7f c9a0                   cmp #chr_shiftspc
  1965  2f81 f007                   beq +
  1966  2f83 c909                   cmp #chr_tab
  1967  2f85 f003                   beq +
  1968  2f87 18                     clc
  1969  2f88 8001                   bra ++
  1970  2f8a 38                 +   sec
  1971  2f8b 60                 ++  rts
  1972                          
  1973                          ; Input: A=char
  1974                          ; Output: A=lowercase letter, or original char if not letter
  1975                          to_lowercase:
  1976  2f8c 20462f                 jsr is_letter
  1977  2f8f 900e                   bcc +
  1978  2f91 c95b                   cmp #'Z'+1
  1979  2f93 900a                   bcc +           ; already lower
  1980  2f95 38                     sec
  1981  2f96 e920                   sbc #'a'-'A'
  1982  2f98 c9a1                   cmp #193-('a'-'A')
  1983  2f9a 9003                   bcc +           ; lowered from first upper bank
  1984  2f9c 38                     sec
  1985  2f9d e960                   sbc #193-'a'    ; lowered from second upper bank
  1986  2f9f 60                 +   rts
  1987                          
  1988                          
  1989                          ; Input: strbuf contains null-terminated string
  1990                          ; Output: letters of strbuf changed to lowercase
  1991                          strbuf_to_lowercase:
  1992  2fa0 a200                   ldx #0
  1993  2fa2 bd007f             -   lda strbuf,x
  1994  2fa5 f009                   beq +
  1995  2fa7 208c2f                 jsr to_lowercase
  1996  2faa 9d007f                 sta strbuf,x
  1997  2fad e8                     inx
  1998  2fae 80f2                   bra -
  1999  2fb0 60                 +   rts
  2000                          
  2001                          
  2002                          ; Input: strbuf, code_ptr; X=strbuf start pos, Z=max length
  2003                          ; Output:
  2004                          ;   strbuf < code_ptr: A=$ff
  2005                          ;   strbuf = code_ptr: A=$00
  2006                          ;   strbuf > code_ptr; A=$01
  2007                          ;   X=strbuf last pos
  2008                          strbuf_cmp_code_ptr:
  2009  2fb1 a000                   ldy #0
  2010  2fb3 c200               -   cpz #0
  2011  2fb5 f016                   beq @is_equal
  2012  2fb7 bd007f                 lda strbuf,x
  2013  2fba d1f6                   cmp (code_ptr),y
  2014  2fbc 900c                   bcc @is_less_than
  2015  2fbe d010                   bne @is_greater_than
  2016  2fc0 bd007f                 lda strbuf,x
  2017  2fc3 f008                   beq @is_equal  ; null term before max length
  2018  2fc5 e8                     inx
  2019  2fc6 c8                     iny
  2020  2fc7 3b                     dez
  2021  2fc8 80e9                   bra -
  2022                          
  2023                          @is_less_than:
  2024  2fca a9ff                   lda #$ff
  2025  2fcc 60                     rts
  2026                          @is_equal:
  2027  2fcd a900                   lda #$00
  2028  2fcf 60                     rts
  2029                          @is_greater_than:
  2030  2fd0 a901                   lda #$01
  2031  2fd2 60                     rts
  2032                          
  2033                          
  2034                          ; ------------------------------------------------------------
  2035                          ; Viewer
  2036                          ; ------------------------------------------------------------
  2037                          ; attic_viewer_lines: (addr16) = lower 16 of viewer buffer address
  2038                          ; attic_viewer_buffer: 0-terminated lines
  2039                          init_viewer:
  2040  2fd3 a900                   lda #<attic_viewer_lines
  2041  2fd5 85d8                   sta viewer_line_next
  2042  2fd7 a900                   lda #>attic_viewer_lines
  2043  2fd9 85d9                   sta viewer_line_next+1
  2044  2fdb a974                   lda #^attic_viewer_lines
  2045  2fdd 85da                   sta viewer_line_next+2
  2046  2fdf a908                   lda #<(attic_viewer_lines >>> 24)
  2047  2fe1 85db                   sta viewer_line_next+3
  2048                          
  2049  2fe3 a300                   ldz #0
  2050  2fe5 a900                   lda #<attic_viewer_buffer
  2051  2fe7 85dc                   sta viewer_buffer_next
  2052  2fe9 ea92d8                 sta [viewer_line_next],z
  2053  2fec 1b                     inz
  2054  2fed a920                   lda #>attic_viewer_buffer
  2055  2fef 85dd                   sta viewer_buffer_next+1
  2056  2ff1 ea92d8                 sta [viewer_line_next],z
  2057  2ff4 a974                   lda #^attic_viewer_buffer
  2058  2ff6 85de                   sta viewer_buffer_next+2
  2059  2ff8 a908                   lda #<(attic_viewer_buffer >>> 24)
  2060  2ffa 85df                   sta viewer_buffer_next+3
  2061                          
  2062  2ffc e3d8                   inw viewer_line_next
  2063  2ffe e3d8                   inw viewer_line_next
  2064  3000 60                     rts
  2065                          
  2066                          ; Inputs: A=char to print
  2067                          ; Outputs:
  2068                          ;   C=0 success
  2069                          ;   C=1 out of memory
  2070                          bufprint_chr:
  2071                              ; (Assumes 0 < high byte <= $ff within buffer.)
  2072  3001 a6dd                   ldx viewer_buffer_next+1
  2073  3003 d002                   bne +
  2074  3005 38                     sec
  2075  3006 60                     rts
  2076                          +
  2077                              ; Convert carriage returns to null terminators.
  2078  3007 c90d                   cmp #chr_cr
  2079  3009 d002                   bne +
  2080  300b a900                   lda #0
  2081                          +
  2082  300d a300                   ldz #0
  2083  300f ea92dc                 sta [viewer_buffer_next],z
  2084  3012 e3dc                   inw viewer_buffer_next
  2085                          
  2086                              ; Null terminator adds a line record.
  2087  3014 c900                   cmp #0
  2088  3016 d00f                   bne +
  2089  3018 a5dc                   lda viewer_buffer_next
  2090  301a ea92d8                 sta [viewer_line_next],z
  2091  301d 1b                     inz
  2092  301e a5dd                   lda viewer_buffer_next+1
  2093  3020 ea92d8                 sta [viewer_line_next],z
  2094  3023 e3d8                   inw viewer_line_next
  2095  3025 e3d8                   inw viewer_line_next
  2096                          +
  2097                          
  2098  3027 18                     clc
  2099  3028 60                     rts
  2100                          
  2101                          ; Macro to print a PETSCII string literal to the view buffer
  2102                          ; Automatically null-terminates, so the argument doesn't have to.
  2103                          ; String must be < 255 characters
  2104                          !macro bufprint_strlit .str {
  2105                              lda #<.data
  2106                              sta code_ptr
  2107                              lda #>.data
  2108                              sta code_ptr+1
  2109                              ldy #0
  2110                          -   lda (code_ptr),y
  2111                              phy
  2112                              jsr bufprint_chr
  2113                              ply
  2114                              lda (code_ptr),y
  2115                              bne -
  2116                              bra +
  2117                          .data !pet .str,0
  2118                          +
  2119                          }
  2120                          
  2121                          ; Input: A=value whose hex value to write to the buffer
  2122                          bufprint_hex8:
  2123  3029 20ab2d                 jsr hex_az
  2124  302c 48                     pha
  2125  302d 6b                     tza
  2126  302e 200130                 jsr bufprint_chr
  2127  3031 68                     pla
  2128  3032 200130                 jsr bufprint_chr
  2129  3035 60                     rts
  2130                          
  2131                          ; Input: bas_ptr = start of text of source line
  2132                          bufprint_line:
  2133  3036 a300                   ldz #0
  2134  3038 a200                   ldx #0
  2135  303a eab2fc             -   lda [bas_ptr],z
  2136  303d f00b                   beq +
  2137  303f dadb                   phx : phz
  2138  3041 200130                 jsr bufprint_chr
  2139  3044 fbfa                   plz : plx
  2140  3046 1b                     inz
  2141  3047 e8                     inx
  2142  3048 80f0                   bra -
  2143                          +
  2144  304a a900                   lda #0
  2145  304c 200130                 jsr bufprint_chr
  2146  304f 60                     rts
  2147                          
  2148                          
  2149                          activate_viewer:
  2150  3050 60                     rts
  2151                          
  2152                          
  2153                          ; ------------------------------------------------------------
  2154                          ; Tokenizer
  2155                          ; ------------------------------------------------------------
  2156                          
  2157                          ; Skip over whitespace, and also a line comment if found after whitespace
  2158                          ; Input: bas_ptr = line_addr, line_pos
  2159                          ; Output: line_pos advanced maybe; A=last read, Zero flag if zero
  2160                          accept_whitespace_and_comment:
  2161  3051 a5f2                   lda line_pos
  2162  3053 4b                     taz
  2163  3054 eab2fc             -   lda [bas_ptr],z
  2164  3057 aa                     tax
  2165  3058 207b2f                 jsr is_space
  2166  305b 9003                   bcc +
  2167  305d 1b                     inz
  2168  305e 80f4                   bra -
  2169  3060 c93b               +   cmp #';'   ; Traditional line comments
  2170  3062 f00d                   beq @do_comment
  2171  3064 c92f                   cmp #'/'   ; C-style line comments
  2172  3066 d010                   bne ++
  2173  3068 1b                     inz
  2174  3069 eab2fc                 lda [bas_ptr],z
  2175  306c 3b                     dez
  2176  306d c92f                   cmp #'/'
  2177  306f d007                   bne ++
  2178                          @do_comment
  2179  3071 1b                 -   inz            ; Ignore comment to end of line
  2180  3072 eab2fc                 lda [bas_ptr],z
  2181  3075 aa                     tax
  2182  3076 d0f9                   bne -
  2183                          
  2184  3078 64f2               ++  stz line_pos
  2185  307a 8a                     txa   ; Set flags
  2186  307b 60                     rts
  2187                          
  2188                          
  2189                          ; Consume identifier
  2190                          ; Input:
  2191                          ;   bas_ptr = line_addr
  2192                          ;   Z = line_pos
  2193                          ;   C: 0=must start with letter, 1=allow non-letter start
  2194                          ; Output:
  2195                          ;   If found, C=1, Z advanced (line_pos not)
  2196                          ;   If not found, C=0, Z = unchanged
  2197                          accept_ident:
  2198  307c b00a                   bcs +
  2199                              ; Must start with letter
  2200  307e eab2fc                 lda [bas_ptr],z
  2201  3081 20462f                 jsr is_letter
  2202  3084 b002                   bcs +
  2203  3086 18                     clc
  2204  3087 60                     rts
  2205                          +
  2206                              ; Can be followed by letter, number, back-arrow, Mega+@
  2207  3088 1b                 -   inz
  2208  3089 eab2fc                 lda [bas_ptr],z
  2209  308c 20622f                 jsr is_secondary_ident_char
  2210  308f b0f7                   bcs -
  2211  3091 38                     sec
  2212  3092 60                     rts
  2213                          
  2214                          
  2215                          ; Input: expr_result
  2216                          ; Output: expr_result = expr_result * 10
  2217                          ;   Overwrites expr_a
  2218                          ;   Preserves Z
  2219                          expr_times_ten:
  2220  3093 db                     phz
  2221  3094 4242a5ec               ldq expr_result
  2222  3098 42422a                 rolq
  2223  309b 424285e4               stq expr_a
  2224  309f 42422a                 rolq
  2225  30a2 42422a                 rolq
  2226  30a5 424265e4               adcq expr_a
  2227  30a9 424285ec               stq expr_result
  2228  30ad fb                     plz
  2229  30ae 60                     rts
  2230                          
  2231                          ; Accept a number/char literal
  2232                          ; Input: bas_ptr=line_addr, line_pos
  2233                          ; Output:
  2234                          ;  C: 0=not found, line_pos unchanged
  2235                          ;  C: 1=found; expr_result=value; line_pos advanced
  2236                          ;  expr_flags F_EXPR_FORCE16 bit set if hex or dec literal has a leading zero
  2237                          accept_literal:
  2238                              ; Init expr zero flag to 0.
  2239  30af a5f0                   lda expr_flags
  2240  30b1 29fb                   and #!F_EXPR_FORCE16
  2241  30b3 85f0                   sta expr_flags
  2242                          
  2243  30b5 a5f2                   lda line_pos
  2244  30b7 4b                     taz
  2245                          
  2246  30b8 a900                   lda #0
  2247  30ba 85ec                   sta expr_result
  2248  30bc 85ed                   sta expr_result+1
  2249  30be 85ee                   sta expr_result+2
  2250  30c0 85ef                   sta expr_result+3
  2251                          
  2252  30c2 eab2fc                 lda [bas_ptr],z
  2253  30c5 c927                   cmp #chr_singlequote
  2254  30c7 d014                   bne ++
  2255                              ; Char literal
  2256  30c9 1b                     inz
  2257  30ca eab2fc                 lda [bas_ptr],z
  2258  30cd aa                     tax
  2259  30ce 1b                     inz
  2260  30cf eab2fc                 lda [bas_ptr],z
  2261  30d2 c927                   cmp #chr_singlequote
  2262  30d4 d32300                 lbne @not_found
  2263  30d7 86ec                   stx expr_result
  2264  30d9 1b                     inz
  2265  30da 83f200                 lbra @found
  2266                          
  2267  30dd a200               ++  ldx #0
  2268  30df 86e9                   stx expr_b+1
  2269  30e1 86ea                   stx expr_b+2
  2270  30e3 86eb                   stx expr_b+3
  2271                          
  2272  30e5 c924                   cmp #'$'
  2273  30e7 f34c00                 lbeq @do_hex_literal
  2274  30ea c925                   cmp #'%'
  2275  30ec f3ac00                 lbeq @do_binary_literal
  2276  30ef c930                   cmp #'0'
  2277  30f1 930600                 lbcc @not_found
  2278  30f4 c93a                   cmp #'9'+1
  2279  30f6 930600                 lbcc @do_decimal_literal
  2280                          
  2281                          @not_found
  2282  30f9 a5f2                   lda line_pos
  2283  30fb 4b                     taz
  2284  30fc 18                     clc
  2285  30fd 60                     rts
  2286                          
  2287                          @do_decimal_literal
  2288  30fe c930                   cmp #'0'
  2289  3100 d008                   bne +
  2290  3102 48                     pha
  2291  3103 a5f0                   lda expr_flags
  2292  3105 0904                   ora #F_EXPR_FORCE16
  2293  3107 85f0                   sta expr_flags
  2294  3109 68                     pla
  2295                          +
  2296                          @do_decimal_literal_loop
  2297  310a c930                   cmp #'0'
  2298  310c 93c000                 lbcc @found
  2299  310f c93a                   cmp #'9'+1
  2300  3111 b3bb00                 lbcs @found
  2301  3114 209330                 jsr expr_times_ten
  2302  3117 eab2fc                 lda [bas_ptr],z
  2303  311a 38                     sec
  2304  311b e930                   sbc #'0'
  2305  311d 85e8                   sta expr_b
  2306  311f db                     phz
  2307  3120 4242a5e8               ldq expr_b
  2308  3124 18                     clc
  2309  3125 424265ec               adcq expr_result
  2310  3129 424285ec               stq expr_result
  2311  312d fb                     plz
  2312  312e 1b                     inz
  2313  312f eab2fc                 lda [bas_ptr],z
  2314  3132 83d6ff                 lbra @do_decimal_literal_loop
  2315                          
  2316                          @do_hex_literal
  2317                              ; Set up first digit, confirm it's a hex digit
  2318  3135 1b                     inz
  2319  3136 eab2fc                 lda [bas_ptr],z
  2320  3139 c930                   cmp #'0'
  2321  313b 93bcff                 lbcc @not_found
  2322  313e d008                   bne +
  2323  3140 48                     pha
  2324  3141 a5f0                   lda expr_flags
  2325  3143 0904                   ora #F_EXPR_FORCE16
  2326  3145 85f0                   sta expr_flags
  2327  3147 68                     pla
  2328  3148 c93a               +   cmp #'9'+1
  2329  314a 900d                   bcc +
  2330  314c 208c2f                 jsr to_lowercase
  2331  314f c941                   cmp #'A'
  2332  3151 93a6ff                 lbcc @not_found
  2333  3154 c947                   cmp #'F'+1
  2334  3156 b3a1ff                 lbcs @not_found
  2335                          +
  2336                          
  2337                          @do_hex_literal_loop
  2338  3159 c930                   cmp #'0'
  2339  315b 937100                 lbcc @found
  2340  315e c93a                   cmp #'9'+1
  2341  3160 b005                   bcs +
  2342                              ; 0-9
  2343  3162 38                     sec
  2344  3163 e930                   sbc #'0'
  2345  3165 8010                   bra +++
  2346                          
  2347  3167 208c2f             +   jsr to_lowercase
  2348  316a c941                   cmp #'A'
  2349  316c 936000                 lbcc @found
  2350  316f c947                   cmp #'F'+1
  2351  3171 b35b00                 lbcs @found
  2352                              ; A-F
  2353  3174 38                     sec
  2354  3175 e937                   sbc #'A'-10
  2355                          
  2356  3177 85e8               +++ sta expr_b
  2357  3179 db                     phz
  2358  317a 18                     clc
  2359  317b 4242a5ec               ldq expr_result
  2360  317f 42422a                 rolq
  2361  3182 42422a                 rolq
  2362  3185 42422a                 rolq
  2363  3188 42422a                 rolq
  2364  318b 424265e8               adcq expr_b
  2365  318f 424285ec               stq expr_result
  2366  3193 fb                     plz
  2367  3194 1b                     inz
  2368  3195 eab2fc                 lda [bas_ptr],z
  2369  3198 80bf                   bra @do_hex_literal_loop
  2370                          
  2371                          @do_binary_literal
  2372                              ; Set up first digit, confirm it's a binary digit
  2373  319a 1b                     inz
  2374  319b eab2fc                 lda [bas_ptr],z
  2375  319e c930                   cmp #'0'
  2376  31a0 f00d                   beq +
  2377  31a2 c92e                   cmp #'.'
  2378  31a4 f009                   beq +
  2379  31a6 c931                   cmp #'1'
  2380  31a8 f005                   beq +
  2381  31aa c923                   cmp #'#'
  2382  31ac d34bff                 lbne @not_found
  2383                          
  2384                          +
  2385  31af c931               --- cmp #'1'
  2386  31b1 f010                   beq ++
  2387  31b3 c923                   cmp #'#'
  2388  31b5 f00c                   beq ++
  2389  31b7 c930                   cmp #'0'
  2390  31b9 f005                   beq +
  2391  31bb c92e                   cmp #'.'
  2392  31bd d30f00                 lbne @found
  2393                          +   ; 0
  2394  31c0 18                     clc
  2395  31c1 8001                   bra +++
  2396                          ++  ; 1
  2397  31c3 38                     sec
  2398  31c4 424226ec           +++ rolq expr_result
  2399  31c8 1b                     inz
  2400  31c9 eab2fc                 lda [bas_ptr],z
  2401  31cc 80e1                   bra ---
  2402                          
  2403                          @found
  2404  31ce 64f2                   stz line_pos
  2405  31d0 38                     sec
  2406  31d1 60                     rts
  2407                          
  2408                          
  2409                          ; Locate a substring of strbuf in a null-terminated list of null-terminated lowercase strings
  2410                          ; Input:
  2411                          ;   strbuf
  2412                          ;   A=starting count position
  2413                          ;   X=strbuf start pos
  2414                          ;   code_ptr = first char of first item in match list
  2415                          ;   C: 0=no restrictions; 1=next cannot be ident char
  2416                          ; Output:
  2417                          ;   If found, C=1, Y=entry number counted from zero, X=strbuf pos of next char
  2418                          ;   If not found, C=0
  2419                          find_item_count = expr_a
  2420                          find_start_pos = expr_a+1
  2421                          find_item_length = expr_a+2
  2422                          find_word_boundary = expr_a+3
  2423                          find_in_token_list:
  2424  31d2 85e4                   sta find_item_count
  2425  31d4 86e5                   stx find_start_pos
  2426  31d6 a900                   lda #0
  2427  31d8 9001                   bcc +
  2428  31da 1a                     inc
  2429  31db 85e7               +   sta find_word_boundary
  2430                          
  2431                          @next_item
  2432  31dd a300                   ldz #0
  2433  31df b2f6                   lda (code_ptr),z
  2434  31e1 f030                   beq @find_fail
  2435                              ; Z = item length
  2436  31e3 1b                 -   inz
  2437  31e4 b2f6                   lda (code_ptr),z
  2438  31e6 d0fb                   bne -
  2439  31e8 64e6                   stz find_item_length
  2440                          
  2441  31ea a6e5                   ldx find_start_pos
  2442  31ec 20b12f                 jsr strbuf_cmp_code_ptr
  2443  31ef d00c                   bne +
  2444                              ; Item of length N has matched N characters in strbuf.
  2445                              ; Word boundary not requested? Accept prefix.
  2446  31f1 a5e7                   lda find_word_boundary
  2447  31f3 f01a                   beq @find_success
  2448                              ; Word boundary requested, next strbuf char must be non-word char.
  2449  31f5 bd007f                 lda strbuf,x
  2450  31f8 20622f                 jsr is_secondary_ident_char
  2451  31fb 9012                   bcc @find_success
  2452                              ; strbuf has more word chars, so this is not a match.
  2453                          +
  2454                          
  2455  31fd 18                     clc
  2456  31fe a5e6                   lda find_item_length
  2457  3200 1a                     inc  ; null terminator
  2458  3201 65f6                   adc code_ptr
  2459  3203 85f6                   sta code_ptr
  2460  3205 a900                   lda #0
  2461  3207 65f7                   adc code_ptr+1
  2462  3209 85f7                   sta code_ptr+1
  2463  320b e6e4                   inc find_item_count
  2464  320d 80ce                   bra @next_item
  2465                          
  2466                          @find_success
  2467  320f 38                     sec
  2468  3210 a4e4                   ldy find_item_count
  2469  3212 60                     rts
  2470                          
  2471                          @find_fail
  2472  3213 18                     clc
  2473  3214 60                     rts
  2474                          
  2475                          
  2476                          ; Tokenize mnemonic.
  2477                          ; Input: strbuf = lowercase line, line_pos at first char
  2478                          ; Output:
  2479                          ;   If found, C=1, X=token number, Y=flags, line_pos advanced
  2480                          ;   If not found, C=0, line_pos unchanged
  2481                          tokenize_mnemonic:
  2482  3215 a6f2                   ldx line_pos
  2483  3217 a931                   lda #<mnemonics
  2484  3219 85f6                   sta code_ptr
  2485  321b a94f                   lda #>mnemonics
  2486  321d 85f7                   sta code_ptr+1
  2487  321f 38                     sec  ; Must not immediately precede an identifier character.
  2488  3220 a901                   lda #1  ; Start counting mnemonics at 1
  2489  3222 20d231                 jsr find_in_token_list
  2490  3225 902d                   bcc @end
  2491  3227 86f2                   stx line_pos  ; new line_pos
  2492                              ; X = line_pos, Y = mnemonic ID, Z = flags
  2493                              ; (Final: X = mnemonic ID, Y = flags)
  2494                          
  2495                              ; Check for +1/+2 suffix
  2496  3229 a300                   ldz #0
  2497  322b bd007f                 lda strbuf,x
  2498  322e c92b                   cmp #'+'
  2499  3230 d01d                   bne @end_ok
  2500  3232 e8                     inx
  2501  3233 bd007f                 lda strbuf,x
  2502  3236 c931                   cmp #'1'
  2503  3238 d004                   bne +
  2504  323a a302                   ldz #F_ASM_FORCE8
  2505  323c 8006                   bra @end_forcewidth
  2506  323e c932               +   cmp #'2'
  2507  3240 d00d                   bne @end_ok
  2508  3242 a304                   ldz #F_ASM_FORCE16
  2509                          @end_forcewidth
  2510  3244 e8                     inx
  2511  3245 bd007f                 lda strbuf,x
  2512  3248 20622f                 jsr is_secondary_ident_char
  2513  324b b002                   bcs @end_ok  ; Roll back to previous line_pos
  2514  324d 86f2                   stx line_pos
  2515                          @end_ok
  2516  324f 38                     sec  ; C = 1
  2517  3250 98                     tya
  2518  3251 aa                     tax  ; X = mnemonic ID
  2519  3252 6b                     tza
  2520  3253 a8                     tay  ; Y = flags
  2521                          @end
  2522  3254 60                     rts
  2523                          
  2524                          
  2525                          ; Tokenize pseudoop.
  2526                          ; Input: strbuf = lowercase line, line_pos at first char
  2527                          ; Output:
  2528                          ;   If found, C=1, X=token number, line_pos advanced
  2529                          ;   If not found, C=0, line_pos unchanged
  2530                          tokenize_pseudoop:
  2531  3255 a6f2                   ldx line_pos
  2532  3257 bd007f                 lda strbuf,x
  2533  325a c921                   cmp #'!'
  2534  325c d01a                   bne @not_found
  2535  325e e8                     inx
  2536  325f a9c0                   lda #<pseudoops
  2537  3261 85f6                   sta code_ptr
  2538  3263 a951                   lda #>pseudoops
  2539  3265 85f7                   sta code_ptr+1
  2540  3267 38                     sec  ; Must not immediately precede an identifier character.
  2541  3268 a900                   lda #0  ; list starting pos
  2542  326a 20d231                 jsr find_in_token_list
  2543  326d 9009                   bcc @not_found
  2544  326f 86f2                   stx line_pos  ; new line pos
  2545  3271 98                     tya
  2546  3272 18                     clc
  2547  3273 6993                   adc #tokid_after_mnemonics  ; Y+tokid_after_mnemonics = pseudoop token ID
  2548  3275 aa                     tax
  2549  3276 38                     sec
  2550  3277 60                     rts
  2551                          @not_found
  2552  3278 18                     clc
  2553  3279 60                     rts
  2554                          
  2555                          
  2556                          ; Tokenize pluses and minuses.
  2557                          ; Input: strbuf = lowercase line, line_pos at first char
  2558                          ; Output:
  2559                          ;   If found, C=1, tokbuf written, tok_pos and line_pos advanced
  2560                          ;      (tk_pluses, pos, len) or (tk_minuses, pos, len)
  2561                          ;   If not found, C=0, tok_pos and line_pos unchanged
  2562                          ;
  2563                          ; Note: This matches plus/minus operators as well as relative labels. The
  2564                          ; parser needs to handle this.
  2565                          tokenize_pluses_and_minuses:
  2566  327a a6f2                   ldx line_pos
  2567  327c bd007f                 lda strbuf,x
  2568  327f c92b                   cmp #'+'
  2569  3281 d011                   bne @maybe_minus
  2570  3283 a000                   ldy #0  ; length
  2571  3285 c8                 -   iny
  2572  3286 e8                     inx
  2573  3287 f007                   beq +
  2574  3289 bd007f                 lda strbuf,x
  2575  328c c92b                   cmp #'+'
  2576  328e f0f5                   beq -
  2577                          +
  2578  3290 a9ba                   lda #tk_pluses
  2579  3292 8015                   bra @found
  2580                          
  2581                          @maybe_minus
  2582  3294 c92d                   cmp #'-'
  2583  3296 f002                   beq +
  2584                              ; Neither + nor -
  2585  3298 18                     clc
  2586  3299 60                     rts
  2587                          +
  2588  329a a000                   ldy #0  ; length
  2589  329c c8                 -   iny
  2590  329d e8                     inx
  2591  329e f007                   beq +
  2592  32a0 bd007f                 lda strbuf,x
  2593  32a3 c92d                   cmp #'-'
  2594  32a5 f0f5                   beq -
  2595                          +
  2596  32a7 a9bb                   lda #tk_minuses
  2597                          
  2598                          @found
  2599                              ; A=tok type, Y=len, line_pos=pos
  2600  32a9 a6f1                   ldx tok_pos
  2601  32ab 9d007e                 sta tokbuf,x
  2602  32ae e8                     inx
  2603  32af a5f2                   lda line_pos
  2604  32b1 9d007e                 sta tokbuf,x
  2605  32b4 e8                     inx
  2606  32b5 98                     tya
  2607  32b6 9d007e                 sta tokbuf,x
  2608  32b9 e8                     inx
  2609  32ba 18                     clc
  2610  32bb 65f2                   adc line_pos
  2611  32bd 85f2                   sta line_pos  ; line_pos += length
  2612  32bf 8a                     txa
  2613  32c0 85f1                   sta tok_pos   ; tok_pos += 3
  2614  32c2 38                     sec
  2615  32c3 60                     rts
  2616                          
  2617                          
  2618                          ; Tokenize punctuation tokens.
  2619                          ; Input: strbuf = lowercase line, line_pos at first char
  2620                          ; Output:
  2621                          ;   If found, C=1, X=token number, line_pos advanced
  2622                          ;   If not found, C=0, line_pos unchanged
  2623                          ;
  2624                          ; Note: Tokens spelled with letters that can also be labels are lexed as
  2625                          ; labels (xor, div, runnable, cbm, raw, x, y, z, sp).
  2626                          tokenize_other:
  2627  32c4 a6f2                   ldx line_pos
  2628  32c6 a9fa                   lda #<other_tokens
  2629  32c8 85f6                   sta code_ptr
  2630  32ca a951                   lda #>other_tokens
  2631  32cc 85f7                   sta code_ptr+1
  2632  32ce 18                     clc  ; Allow an identifier character immediately after.
  2633  32cf a900                   lda #0  ; list starting pos
  2634  32d1 20d231                 jsr find_in_token_list
  2635  32d4 9008                   bcc @end
  2636  32d6 86f2                   stx line_pos  ; new line pos
  2637  32d8 98                     tya
  2638  32d9 18                     clc
  2639  32da 69a0                   adc #last_po  ; Y+last_po = non-keyword token ID
  2640  32dc aa                     tax
  2641  32dd 38                     sec
  2642                          @end
  2643  32de 60                     rts
  2644                          
  2645                          
  2646                          ; Load a full source line into strbuf, lowercased.
  2647                          ;
  2648                          ; This leaves the first four bytes of strbuf untouched to maintain an index
  2649                          ; correspondence with line_addr, so line_pos can index into both of them.
  2650                          ; Tokens are stored with line locations based on line_pos.
  2651                          ;
  2652                          ; Input: line_addr
  2653                          ; Output: line_addr copied to strbuf, lowercased
  2654                          load_line_to_strbuf:
  2655  32df a5f4                   lda line_addr
  2656  32e1 85fc                   sta bas_ptr
  2657  32e3 a5f5                   lda line_addr+1
  2658  32e5 85fd                   sta bas_ptr+1
  2659  32e7 a004                   ldy #4
  2660  32e9 a304                   ldz #4
  2661  32eb eab2fc             -   lda [bas_ptr],z
  2662  32ee f00a                   beq +
  2663  32f0 208c2f                 jsr to_lowercase
  2664  32f3 99007f                 sta strbuf,y
  2665  32f6 c8                     iny
  2666  32f7 1b                     inz
  2667  32f8 80f1                   bra -
  2668  32fa 99007f             +   sta strbuf,y  ; store null terminator in strbuf too
  2669  32fd 60                     rts
  2670                          
  2671                          
  2672                          ; Tokenize a full line.
  2673                          ;
  2674                          ; This populates tokbuf with tokens, null-terminated. Tokens are variable width.
  2675                          ; * String literal: tk_string_literal, line_pos, length
  2676                          ; * Number literal: tk_number_literal, line_pos, expr_result (4 bytes)
  2677                          ; * Relative label: tk_pluses or tk_minuses, line_pos, length
  2678                          ; * Label or register: tk_label_or_reg, line_pos, length
  2679                          ; * Mnemonic, pseudoop, keyword, non-keyword token: token ID, line_pos
  2680                          ;
  2681                          ; Input: line_addr
  2682                          ; Output:
  2683                          ;   On success, err_code=0, tokbuf populated.
  2684                          ;   On failure, err_code=syntax error, line_pos set to error.
  2685                          tokenize:
  2686  32fe 20df32                 jsr load_line_to_strbuf
  2687  3301 a000                   ldy #0
  2688  3303 84f3                   sty err_code
  2689  3305 84f1                   sty tok_pos
  2690  3307 a304                   ldz #4
  2691  3309 64f2                   stz line_pos
  2692                          
  2693                          @tokenize_loop
  2694  330b 205130                 jsr accept_whitespace_and_comment
  2695  330e c900                   cmp #0
  2696  3310 f3e300                 lbeq @success
  2697                          
  2698                              ; String literal
  2699  3313 c922                   cmp #chr_doublequote
  2700  3315 d029                   bne +
  2701  3317 a5f2                   lda line_pos
  2702  3319 4b                     taz
  2703  331a 1b                 -   inz
  2704  331b eab2fc                 lda [bas_ptr],z
  2705  331e c922                   cmp #chr_doublequote
  2706  3320 d0f8                   bne -
  2707                              ; Push tk_string_literal, line_pos, length (z-line_pos)
  2708  3322 a6f1                   ldx tok_pos
  2709  3324 a9b8                   lda #tk_string_literal
  2710  3326 9d007e                 sta tokbuf,x
  2711  3329 e8                     inx
  2712  332a a5f2                   lda line_pos
  2713  332c 9d007e                 sta tokbuf,x
  2714  332f e8                     inx
  2715  3330 6b                     tza
  2716  3331 38                     sec
  2717  3332 e5f2                   sbc line_pos
  2718  3334 3a                     dec
  2719  3335 9d007e                 sta tokbuf,x
  2720  3338 e8                     inx
  2721  3339 86f1                   stx tok_pos
  2722  333b 1b                     inz
  2723  333c 64f2                   stz line_pos
  2724  333e 80cb                   bra @tokenize_loop
  2725                          
  2726                          +   ; Numeric literal
  2727  3340 db                     phz
  2728  3341 20af30                 jsr accept_literal
  2729  3344 fb                     plz
  2730  3345 9032                   bcc +++
  2731                              ; Push tk_number_literal, line_pos, expr_result (4 bytes)
  2732  3347 a5f0                   lda expr_flags
  2733  3349 2904                   and #F_EXPR_FORCE16
  2734  334b f004                   beq +
  2735  334d a9b7                   lda #tk_number_literal_leading_zero
  2736  334f 8002                   bra ++
  2737  3351 a9b6               +   lda #tk_number_literal
  2738  3353 a6f1               ++  ldx tok_pos
  2739  3355 9d007e                 sta tokbuf,x
  2740  3358 e8                     inx
  2741  3359 9e007e                 stz tokbuf,x
  2742  335c e8                     inx
  2743  335d a5ec                   lda expr_result
  2744  335f 9d007e                 sta tokbuf,x
  2745  3362 e8                     inx
  2746  3363 a5ed                   lda expr_result+1
  2747  3365 9d007e                 sta tokbuf,x
  2748  3368 e8                     inx
  2749  3369 a5ee                   lda expr_result+2
  2750  336b 9d007e                 sta tokbuf,x
  2751  336e e8                     inx
  2752  336f a5ef                   lda expr_result+3
  2753  3371 9d007e                 sta tokbuf,x
  2754  3374 e8                     inx
  2755  3375 86f1                   stx tok_pos
  2756  3377 8092                   bra @tokenize_loop
  2757                          
  2758                          +++ ; Mnemonic
  2759  3379 db                     phz
  2760  337a 201532                 jsr tokenize_mnemonic
  2761  337d fb                     plz
  2762  337e 9017                   bcc +++
  2763                              ; Push mnemonic ID (X), line_pos, flags (Y)
  2764  3380 8a                     txa
  2765  3381 a6f1                   ldx tok_pos
  2766  3383 9d007e                 sta tokbuf,x
  2767  3386 e8                     inx
  2768  3387 9e007e                 stz tokbuf,x
  2769  338a e8                     inx
  2770  338b 8b007e                 sty tokbuf,x
  2771  338e a5f2                   lda line_pos
  2772  3390 4b                     taz
  2773  3391 e8                     inx
  2774  3392 86f1                   stx tok_pos
  2775  3394 8375ff                 lbra @tokenize_loop
  2776                          
  2777                              ; Pseudoop
  2778  3397 db                 +++ phz
  2779  3398 205532                 jsr tokenize_pseudoop
  2780  339b fb                     plz
  2781  339c b03d                   bcs @push_tok_pos_then_continue
  2782                          
  2783                              ; Tokenize relative labels, and +/- operators
  2784  339e db                     phz
  2785  339f 207a32                 jsr tokenize_pluses_and_minuses
  2786  33a2 fb                     plz
  2787  33a3 b366ff                 lbcs @tokenize_loop
  2788                          
  2789                              ; Punctuation token
  2790  33a6 db                     phz
  2791  33a7 20c432                 jsr tokenize_other
  2792  33aa fb                     plz
  2793  33ab b02e                   bcs @push_tok_pos_then_continue
  2794                          
  2795                              ; Label
  2796  33ad eab2fc                 lda [bas_ptr],z
  2797  33b0 c940                   cmp #'@'
  2798  33b2 d004                   bne +
  2799  33b4 1b                     inz
  2800  33b5 38                     sec
  2801  33b6 8001                   bra ++
  2802  33b8 18                 +   clc
  2803  33b9 207c30             ++  jsr accept_ident
  2804  33bc 9030                   bcc @syntax_error
  2805                              ; Push tk_label_or_reg, line_pos, length (z-line_pos)
  2806  33be a6f1                   ldx tok_pos
  2807  33c0 a9b9                   lda #tk_label_or_reg
  2808  33c2 9d007e                 sta tokbuf,x
  2809  33c5 e8                     inx
  2810  33c6 a5f2                   lda line_pos
  2811  33c8 9d007e                 sta tokbuf,x
  2812  33cb e8                     inx
  2813  33cc 6b                     tza
  2814  33cd 38                     sec
  2815  33ce e5f2                   sbc line_pos
  2816  33d0 9d007e                 sta tokbuf,x
  2817  33d3 e8                     inx
  2818  33d4 86f1                   stx tok_pos
  2819  33d6 64f2                   stz line_pos
  2820  33d8 8331ff                 lbra @tokenize_loop
  2821                          
  2822                          @push_tok_pos_then_continue
  2823                              ; Push X, line_pos
  2824  33db 8a                     txa
  2825  33dc a6f1                   ldx tok_pos
  2826  33de 9d007e                 sta tokbuf,x
  2827  33e1 e8                     inx
  2828  33e2 9e007e                 stz tokbuf,x
  2829  33e5 a5f2                   lda line_pos
  2830  33e7 4b                     taz
  2831  33e8 e8                     inx
  2832  33e9 86f1                   stx tok_pos
  2833  33eb 831eff                 lbra @tokenize_loop
  2834                          
  2835                          @syntax_error
  2836  33ee a901                   lda #err_syntax
  2837  33f0 85f3                   sta err_code
  2838  33f2 64f2                   stz line_pos
  2839  33f4 60                     rts
  2840                          
  2841                          @success
  2842                              ; Null terminate tokbuf: 0, $ff (line_pos=$ff -> don't print error location)
  2843  33f5 a900                   lda #0
  2844  33f7 a6f1                   ldx tok_pos
  2845  33f9 9d007e                 sta tokbuf,x
  2846  33fc e8                     inx
  2847  33fd a9ff                   lda #$ff
  2848  33ff 9d007e                 sta tokbuf,x
  2849  3402 60                     rts
  2850                          
  2851                          
  2852                          ; ------------------------------------------------------------
  2853                          ; Symbol table
  2854                          ; ------------------------------------------------------------
  2855                          ; Record, 8 bytes: (name_ptr_24, flags_8, value_32)
  2856                          ; - 1023 symbols maximum (8KB of entries + list terminator)
  2857                          ; - Average name length of 23 for all 1023 symbols (24KB of names)
  2858                          ;
  2859                          ; For comparison, the BASIC 65 source file has 3301 symbols with an average
  2860                          ; name length of 15. The source file is 521,778 bytes long, which is >11x the
  2861                          ; maximum size of an EasyAsm source file. So 32KB of symbol data for EasyAsm
  2862                          ; is probably overkill.
  2863                          
  2864                          init_symbol_table:
  2865                              ; Set first symbol table entry to null terminator
  2866  3403 a900                   lda #<attic_symbol_table
  2867  3405 a237                   ldx #>attic_symbol_table
  2868  3407 a071                   ldy #^attic_symbol_table
  2869  3409 a308                   ldz #$08
  2870  340b 424285f8               stq attic_ptr
  2871  340f 3b                     dez
  2872  3410 a900                   lda #0
  2873  3412 ea92f8             -   sta [attic_ptr],z
  2874  3415 3b                     dez
  2875  3416 10fa                   bpl -
  2876                          
  2877                              ; Set name pointer to beginning of names region
  2878  3418 a900                   lda #<attic_symbol_names
  2879  341a 85d0                   sta symtbl_next_name
  2880  341c a957                   lda #>attic_symbol_names
  2881  341e 85d1                   sta symtbl_next_name+1
  2882  3420 a971                   lda #^attic_symbol_names
  2883  3422 85d2                   sta symtbl_next_name+2
  2884                          
  2885  3424 a900                   lda #0
  2886  3426 85d3                   sta last_pc_defined_global_label
  2887  3428 85d4                   sta last_pc_defined_global_label+1
  2888                          
  2889  342a 60                     rts
  2890                          
  2891                          
  2892                          ; Find a symbol table entry for a name
  2893                          ; Input: bas_ptr=name, X=length (< 254)
  2894                          ; Output:
  2895                          ; - C=0 found, attic_ptr=entry address
  2896                          ; - C=1 not found, attic_ptr=next available table entry
  2897                          ; - bas_ptr and X preserved
  2898                          find_symbol:
  2899  342b da                     phx
  2900  342c a900                   lda #<attic_symbol_table
  2901  342e a237                   ldx #>attic_symbol_table
  2902  3430 a071                   ldy #^attic_symbol_table
  2903  3432 a308                   ldz #$08
  2904  3434 424285f8               stq attic_ptr
  2905  3438 fa                     plx
  2906                          
  2907                          @symbol_find_loop
  2908                              ; attic_ptr = current entry
  2909                              ; Byte 2 is always $7x if value, $00 if terminator
  2910  3439 a302                   ldz #2
  2911  343b eab2f8                 lda [attic_ptr],z
  2912  343e f03e                   beq @not_found
  2913                          
  2914                              ; expr_a = current name ptr
  2915  3440 85e6                   sta expr_a+2
  2916  3442 3b                     dez
  2917  3443 eab2f8                 lda [attic_ptr],z
  2918  3446 85e5                   sta expr_a+1
  2919  3448 3b                     dez
  2920  3449 eab2f8                 lda [attic_ptr],z
  2921  344c 85e4                   sta expr_a
  2922  344e a908                   lda #$08
  2923  3450 85e7                   sta expr_a+3
  2924                          
  2925                              ; Compare (expr_a) == (bas_ptr) up to length X
  2926  3452 8a                     txa
  2927  3453 4b                     taz
  2928  3454 3b                     dez
  2929  3455 eab2e4             -   lda [expr_a],z
  2930  3458 ead2fc                 cmp [bas_ptr],z
  2931  345b d00c                   bne @next_symbol
  2932  345d 3b                     dez
  2933  345e 10f5                   bpl -
  2934                              ; (expr_a+length) == 0
  2935  3460 8a                     txa
  2936  3461 4b                     taz
  2937  3462 eab2e4                 lda [expr_a],z
  2938  3465 d002                   bne @next_symbol
  2939                              ; Found.
  2940  3467 18                     clc
  2941  3468 60                     rts
  2942                          
  2943                          @next_symbol
  2944  3469 da                     phx
  2945  346a a908                   lda #8
  2946  346c a200                   ldx #0
  2947  346e a000                   ldy #0
  2948  3470 a300                   ldz #0
  2949  3472 18                     clc
  2950  3473 424265f8               adcq attic_ptr
  2951  3477 424285f8               stq attic_ptr
  2952  347b fa                     plx
  2953  347c 80bb                   bra @symbol_find_loop
  2954                          
  2955                          @not_found
  2956  347e 38                     sec
  2957  347f 60                     rts
  2958                          
  2959                          
  2960                          ; Find or add a symbol table entry for a name
  2961                          ; Input: bas_ptr=name, X=length (< 254)
  2962                          ; Output:
  2963                          ; - C=0 found or added, attic_ptr=entry address
  2964                          ; - C=1 out of memory error
  2965                          ; - Uses expr_a
  2966                          find_or_add_symbol:
  2967  3480 202b34                 jsr find_symbol
  2968  3483 b001                   bcs +
  2969  3485 60                     rts
  2970                          +   ; attic_ptr is the null terminator in the symbol list
  2971                              ; Is there room for another symbol table entry here?
  2972  3486 da                     phx
  2973  3487 a9f8                   lda #<(attic_symbol_names-SYMTBL_ENTRY_SIZE)
  2974  3489 a256                   ldx #>(attic_symbol_names-SYMTBL_ENTRY_SIZE)
  2975  348b a071                   ldy #^(attic_symbol_names-SYMTBL_ENTRY_SIZE)
  2976  348d a308                   ldz #$08
  2977  348f 4242c5f8               cpq attic_ptr
  2978  3493 d003                   bne +
  2979                              ; Out of memory: no more symbol table entries.
  2980  3495 fa                     plx
  2981  3496 38                     sec
  2982  3497 60                     rts
  2983  3498 fa                 +   plx
  2984  3499 da                     phx
  2985                              ; Test for attic_symbol_names_end >= (symtbl_next_name + X + 1)
  2986  349a a5d0                   lda symtbl_next_name
  2987  349c 85e4                   sta expr_a
  2988  349e a5d1                   lda symtbl_next_name+1
  2989  34a0 85e5                   sta expr_a+1
  2990  34a2 a5d2                   lda symtbl_next_name+2
  2991  34a4 85e6                   sta expr_a+2
  2992  34a6 a908                   lda #$08
  2993  34a8 85e7                   sta expr_a+3
  2994  34aa a900                   lda #0
  2995  34ac a8                     tay
  2996  34ad 4b                     taz
  2997  34ae 8a                     txa
  2998  34af a200                   ldx #0
  2999  34b1 1a                     inc
  3000  34b2 424265e4               adcq expr_a
  3001  34b6 424285e4               stq expr_a
  3002  34ba a900                   lda #<attic_symbol_names_end
  3003  34bc a2b7                   ldx #>attic_symbol_names_end
  3004  34be a071                   ldy #^attic_symbol_names_end
  3005  34c0 a308                   ldz #$08
  3006  34c2 4242c5e4               cpq expr_a
  3007  34c6 b003                   bcs +
  3008                              ; Out of memory: not enough room for symbol name.
  3009  34c8 fa                     plx
  3010  34c9 38                     sec
  3011  34ca 60                     rts
  3012                          +
  3013                              ; (Name length is on the stack.)
  3014                          
  3015                              ; Create new table entry, and null terminator.
  3016  34cb a300                   ldz #0
  3017  34cd a5d0                   lda symtbl_next_name
  3018  34cf ea92f8                 sta [attic_ptr],z
  3019  34d2 1b                     inz
  3020  34d3 a5d1                   lda symtbl_next_name+1
  3021  34d5 ea92f8                 sta [attic_ptr],z
  3022  34d8 1b                     inz
  3023  34d9 a5d2                   lda symtbl_next_name+2
  3024  34db ea92f8                 sta [attic_ptr],z
  3025  34de 1b                     inz
  3026  34df a20d                   ldx #13  ; Zero flags, value, and all of next entry (null terminator).
  3027  34e1 a900                   lda #0
  3028  34e3 ea92f8             -   sta [attic_ptr],z
  3029  34e6 1b                     inz
  3030  34e7 ca                     dex
  3031  34e8 d0f9                   bne -
  3032                          
  3033                              ; Copy name from bas_ptr, length X, to symtbl_next_name.
  3034  34ea fa                     plx
  3035  34eb a5d0                   lda symtbl_next_name
  3036  34ed 85e4                   sta expr_a
  3037  34ef a5d1                   lda symtbl_next_name+1
  3038  34f1 85e5                   sta expr_a+1
  3039  34f3 a5d2                   lda symtbl_next_name+2
  3040  34f5 85e6                   sta expr_a+2
  3041  34f7 8a                     txa
  3042  34f8 4b                     taz
  3043  34f9 3b                     dez
  3044  34fa eab2fc             -   lda [bas_ptr],z
  3045  34fd ea92e4                 sta [expr_a],z
  3046  3500 3b                     dez
  3047  3501 10f7                   bpl -
  3048  3503 8a                     txa
  3049  3504 4b                     taz
  3050  3505 a900                   lda #0
  3051  3507 ea92e4                 sta [expr_a],z
  3052                          
  3053                              ; Store new symtbl_next_name.
  3054  350a a8                     tay
  3055  350b 4b                     taz
  3056  350c 8a                     txa
  3057  350d a200                   ldx #0
  3058  350f 1a                     inc    ; Q = name length + 1
  3059  3510 18                     clc
  3060  3511 424265e4               adcq expr_a
  3061  3515 85d0                   sta symtbl_next_name
  3062  3517 86d1                   stx symtbl_next_name+1
  3063  3519 84d2                   sty symtbl_next_name+2
  3064                              ; (symtbl_next_name is 24 bits.)
  3065                          
  3066                              ; Success.
  3067  351b 18                     clc
  3068  351c 60                     rts
  3069                          
  3070                          
  3071                          ; Gets a symbol's 32-bit value
  3072                          ; Input: attic_ptr=symbol table entry
  3073                          ; Output:
  3074                          ;   C=0 defined, Q=value
  3075                          ;   C=1 undefined
  3076                          get_symbol_value:
  3077  351d a303                   ldz #3
  3078  351f eab2f8                 lda [attic_ptr],z
  3079  3522 2901                   and #F_SYMTBL_DEFINED
  3080  3524 d002                   bne +
  3081                              ; Undefined.
  3082  3526 38                     sec
  3083  3527 60                     rts
  3084  3528 a900               +   lda #0
  3085  352a aa                     tax
  3086  352b a8                     tay
  3087  352c 4b                     taz
  3088  352d a904                   lda #4
  3089  352f 18                     clc
  3090  3530 424265f8               adcq attic_ptr
  3091  3534 424285e4               stq expr_a      ; expr_a = attic_ptr + 4
  3092  3538 a300                   ldz #0
  3093  353a 4242eab2e4             ldq [expr_a]
  3094  353f 18                     clc
  3095  3540 60                     rts
  3096                          
  3097                          
  3098                          ; Gets a symbol's 32-bit value
  3099                          ; Input: attic_ptr=symbol table entry, Q=value
  3100                          ; Output: entry value (attic_ptr+4)=Q, entry DEFINED flag set
  3101                          ; This does not validate inputs.
  3102                          set_symbol_value:
  3103  3541 48                     pha
  3104  3542 da                     phx
  3105  3543 5a                     phy
  3106  3544 db                     phz
  3107  3545 a900                   lda #0
  3108  3547 aa                     tax
  3109  3548 a8                     tay
  3110  3549 4b                     taz
  3111  354a a904                   lda #4
  3112  354c 424265f8               adcq attic_ptr
  3113  3550 424285e4               stq expr_a
  3114  3554 fb                     plz
  3115  3555 7a                     ply
  3116  3556 fa                     plx
  3117  3557 68                     pla
  3118  3558 4242ea92e4             stq [expr_a]
  3119  355d a303                   ldz #3
  3120  355f a901                   lda #F_SYMTBL_DEFINED
  3121  3561 ea92f8                 sta [attic_ptr],z
  3122  3564 60                     rts
  3123                          
  3124                          
  3125                          ; ------------------------------------------------------------
  3126                          ; Segment table
  3127                          ; ------------------------------------------------------------
  3128                          ; Segment:         (pc16,  size16, data...)
  3129                          ; File marker:     ($0000, $FFFF,  fnameaddr32, fnamelen8, flags)
  3130                          ; Null terminator: ($0000, $0000)
  3131                          
  3132                          ; Initializes the segment table.
  3133                          init_segment_table:
  3134                              ; (next_segment_byte_addr inits to top of table, for creation of first
  3135                              ; segment in assemble_bytes.)
  3136  3565 a900                   lda #<attic_segments
  3137  3567 85ba                   sta current_segment
  3138  3569 85c0                   sta next_segment_byte_addr
  3139  356b a9b7                   lda #>attic_segments
  3140  356d 85bb                   sta current_segment+1
  3141  356f 85c1                   sta next_segment_byte_addr+1
  3142  3571 a971                   lda #^attic_segments
  3143  3573 85bc                   sta current_segment+2
  3144  3575 85c2                   sta next_segment_byte_addr+2
  3145  3577 a908                   lda #<(attic_segments >>> 24)
  3146  3579 85bd                   sta current_segment+3
  3147  357b 85c3                   sta next_segment_byte_addr+3
  3148                          
  3149  357d a900                   lda #0
  3150  357f 85be                   sta next_segment_pc
  3151  3581 85bf                   sta next_segment_pc+1
  3152  3583 a300                   ldz #0
  3153  3585 ea92ba                 sta [current_segment],z
  3154  3588 1b                     inz
  3155  3589 ea92ba                 sta [current_segment],z
  3156  358c 1b                     inz
  3157  358d ea92ba                 sta [current_segment],z
  3158  3590 1b                     inz
  3159  3591 ea92ba                 sta [current_segment],z
  3160                          
  3161  3594 60                     rts
  3162                          
  3163                          ; Initializes an assembly pass.
  3164                          init_pass:
  3165  3595 a900                   lda #0
  3166  3597 85b7                   sta program_counter
  3167  3599 85b8                   sta program_counter+1
  3168                          
  3169                              ; Reset all asm_flags except src_to_buf
  3170  359b a5b9                   lda asm_flags
  3171  359d 2980                   and #F_ASM_SRC_TO_BUF
  3172  359f 85b9                   sta asm_flags
  3173                          
  3174  35a1 60                     rts
  3175                          
  3176                          
  3177                          ; Gets the program counter, or fails if not defined.
  3178                          ; Input: program_counter, asm_flags
  3179                          ; Output:
  3180                          ;   C=0 ok, X/Y=PC
  3181                          ;   C=1 not defined
  3182                          get_pc:
  3183  35a2 a5b9                   lda asm_flags
  3184  35a4 2901                   and #F_ASM_PC_DEFINED
  3185  35a6 d002                   bne +
  3186  35a8 38                     sec
  3187  35a9 60                     rts
  3188  35aa a6b7               +   ldx program_counter
  3189  35ac a4b8                   ldy program_counter+1
  3190  35ae 18                     clc
  3191  35af 60                     rts
  3192                          
  3193                          
  3194                          ; Sets the program counter.
  3195                          ; Input: X/Y=PC
  3196                          ; Output: program_counter, asm_flags
  3197                          set_pc:
  3198  35b0 86b7                   stx program_counter
  3199  35b2 84b8                   sty program_counter+1
  3200  35b4 a5b9                   lda asm_flags
  3201  35b6 0901                   ora #F_ASM_PC_DEFINED
  3202  35b8 85b9                   sta asm_flags
  3203  35ba 60                     rts
  3204                          
  3205                          
  3206                          ; Inputs:
  3207                          ;   strbuf = assembled bytes
  3208                          ;   expr_a = length
  3209                          ;   line_addr = source line
  3210                          ;   program_counter = PC at beginning of line
  3211                          bufprint_assembly_and_source_line:
  3212                              ; Print $addr as hex
  3213  35bb a924                   lda #'$'
  3214  35bd 200130                 jsr bufprint_chr
  3215  35c0 a5b8                   lda program_counter+1
  3216  35c2 202930                 jsr bufprint_hex8
  3217  35c5 a5b7                   lda program_counter
  3218  35c7 202930                 jsr bufprint_hex8
  3219  35ca a920                   lda #chr_spc
  3220  35cc 200130                 jsr bufprint_chr
  3221                          
  3222                              ; Print up to six assembled bytes as hex
  3223                              ; If six, also print ".."
  3224                              ; If < six, fill with spaces
  3225  35cf a4e4                   ldy expr_a
  3226  35d1 c006                   cpy #6
  3227  35d3 9002                   bcc +
  3228  35d5 a006                   ldy #6
  3229  35d7 a200               +   ldx #0
  3230  35d9 bd007f             -   lda strbuf,x
  3231  35dc 202930                 jsr bufprint_hex8
  3232  35df e8                     inx
  3233  35e0 88                     dey
  3234  35e1 d0f6                   bne -
  3235  35e3 a5e4                   lda expr_a
  3236  35e5 c906                   cmp #6
  3237  35e7 900a                   bcc +
  3238  35e9 a92e                   lda #'.'
  3239  35eb 200130                 jsr bufprint_chr
  3240  35ee 200130                 jsr bufprint_chr
  3241  35f1 8014                   bra ++
  3242  35f3 a906               +   lda #6
  3243  35f5 38                     sec
  3244  35f6 e5e4                   sbc expr_a
  3245  35f8 300d                   bmi ++
  3246  35fa 1a                     inc
  3247  35fb 0a                     asl
  3248  35fc aa                     tax
  3249  35fd a920               -   lda #' '
  3250  35ff da                     phx
  3251  3600 200130                 jsr bufprint_chr
  3252  3603 fa                     plx
  3253  3604 ca                     dex
  3254  3605 10f6                   bpl -
  3255                          ++
  3256                          
  3257                              ; (Print line number?)
  3258                          
  3259                              ; Print the source line
  3260  3607 a5f4                   lda line_addr
  3261  3609 85fc                   sta bas_ptr
  3262  360b a5f5                   lda line_addr+1
  3263  360d 85fd                   sta bas_ptr+1
  3264  360f e3fc                   inw bas_ptr
  3265  3611 e3fc                   inw bas_ptr
  3266  3613 e3fc                   inw bas_ptr
  3267  3615 e3fc                   inw bas_ptr
  3268  3617 203630                 jsr bufprint_line
  3269  361a 60                     rts
  3270                          
  3271                          
  3272                          ; Assembles bytes to a segment.
  3273                          ; Input: Bytes in beginning of strbuf, X=length; init'd segment table
  3274                          ; Output:
  3275                          ;   C=0 ok; table state updated
  3276                          ;   C=1 fail:
  3277                          ;     err_code set; caller can react appropriately (err_pc_undef on pass 0 is ok)
  3278                          ;   Uses expr_a
  3279                          assemble_bytes:
  3280  361b e000                   cpx #0  ; Edge case: X = 0
  3281  361d d002                   bne +
  3282  361f 18                     clc
  3283  3620 60                     rts
  3284                          +
  3285                              ; expr_a = length
  3286  3621 86e4                   stx expr_a
  3287  3623 a900                   lda #0
  3288  3625 85e5                   sta expr_a+1
  3289  3627 85e6                   sta expr_a+2
  3290  3629 85e7                   sta expr_a+3
  3291                          
  3292                              ; If PC not defined, error.
  3293  362b a5b9                   lda asm_flags
  3294  362d 2901                   and #F_ASM_PC_DEFINED
  3295  362f d00a                   bne +
  3296  3631 a902                   lda #err_pc_undef
  3297  3633 85f3                   sta err_code
  3298  3635 a9ff                   lda #$ff
  3299  3637 85f2                   sta line_pos
  3300  3639 38                     sec
  3301  363a 60                     rts
  3302                          +
  3303                          
  3304                              ; If this isn't the final pass, simply increment the PC and don't do
  3305                              ; anything else.
  3306  363b 24b6                   bit pass
  3307  363d 13b900                 lbpl @increment_pc
  3308                          
  3309                              ; Write source line to view buffer, if requested.
  3310  3640 a5b9                   lda asm_flags
  3311  3642 2980                   and #F_ASM_SRC_TO_BUF
  3312  3644 f003                   beq +
  3313  3646 20bb35                 jsr bufprint_assembly_and_source_line
  3314                          +
  3315                          
  3316                              ; If next_segment_byte_addr+len is beyond maximum segment table address, out
  3317                              ; of memory error.
  3318  3649 a900                   lda #<attic_segments_end
  3319  364b a267                   ldx #>attic_segments_end
  3320  364d a072                   ldy #^attic_segments_end
  3321  364f a308                   ldz #<(attic_segments_end >>> 24)
  3322  3651 38                     sec
  3323  3652 4242e5e4               sbcq expr_a
  3324  3656 38                     sec
  3325  3657 4242e5c0               sbcq next_segment_byte_addr
  3326  365b 100c                   bpl +
  3327  365d a906                   lda #err_out_of_memory
  3328  365f 85f3                   sta err_code
  3329  3661 a900                   lda #$00
  3330  3663 85f4                   sta line_addr
  3331  3665 85f5                   sta line_addr+1
  3332  3667 38                     sec
  3333  3668 60                     rts
  3334                          +
  3335                              ; If current segment has empty header or program_counter != next_segment_pc,
  3336                              ; create a new segment header.
  3337                              ; (segment_pc_16, length_16)
  3338  3669 a300                   ldz #0
  3339  366b eab2ba                 lda [current_segment],z
  3340  366e 1b                     inz
  3341  366f ea12ba                 ora [current_segment],z
  3342  3672 f00e                   beq +
  3343  3674 a5b7                   lda program_counter
  3344  3676 c5be                   cmp next_segment_pc
  3345  3678 d008                   bne +
  3346  367a a5b8                   lda program_counter+1
  3347  367c c5bf                   cmp next_segment_pc+1
  3348  367e d002                   bne +
  3349  3680 8033                   bra ++
  3350  3682 a300               +   ldz #0
  3351  3684 a5b7                   lda program_counter
  3352  3686 ea92c0                 sta [next_segment_byte_addr],z
  3353  3689 85be                   sta next_segment_pc
  3354  368b 1b                     inz
  3355  368c a5b8                   lda program_counter+1
  3356  368e ea92c0                 sta [next_segment_byte_addr],z
  3357  3691 85bf                   sta next_segment_pc+1
  3358  3693 1b                     inz
  3359  3694 a900                   lda #0
  3360  3696 ea92c0                 sta [next_segment_byte_addr],z
  3361  3699 1b                     inz
  3362  369a ea92c0                 sta [next_segment_byte_addr],z
  3363  369d 4242a5c0               ldq next_segment_byte_addr
  3364  36a1 424285ba               stq current_segment
  3365                          
  3366  36a5 a900                   lda #0
  3367  36a7 aa                     tax
  3368  36a8 a8                     tay
  3369  36a9 4b                     taz
  3370  36aa a904                   lda #4
  3371  36ac 18                     clc
  3372  36ad 424265c0               adcq next_segment_byte_addr
  3373  36b1 424285c0               stq next_segment_byte_addr
  3374                          
  3375                          ++  ; Write bytes to segment.
  3376  36b5 a5e4                   lda expr_a
  3377  36b7 aa                     tax  ; X counts down from length to 1, inclusive.
  3378  36b8 3a                     dec
  3379  36b9 4b                     taz  ; Z counts down from length-1 to 0, inclusive.
  3380  36ba bdff7e             -   lda strbuf-1,x
  3381  36bd ea92c0                 sta [next_segment_byte_addr],z
  3382  36c0 3b                     dez
  3383  36c1 ca                     dex
  3384                              ; (Can't use bpl here because we need to support unsigned counts up to 255.)
  3385  36c2 d0f6                   bne -
  3386                          
  3387                              ; Add length to segment length.
  3388  36c4 a302                   ldz #2
  3389  36c6 eab2ba                 lda [current_segment],z
  3390  36c9 18                     clc
  3391  36ca 65e4                   adc expr_a
  3392  36cc ea92ba                 sta [current_segment],z
  3393  36cf 1b                     inz
  3394  36d0 eab2ba                 lda [current_segment],z
  3395  36d3 65e5                   adc expr_a+1
  3396  36d5 ea92ba                 sta [current_segment],z
  3397                          
  3398                              ; Add length to next_segment_byte_addr.
  3399  36d8 4242a5e4               ldq expr_a
  3400  36dc 18                     clc
  3401  36dd 424265c0               adcq next_segment_byte_addr
  3402  36e1 424285c0               stq next_segment_byte_addr
  3403                          
  3404                              ; Null terminate the segment list
  3405  36e5 a300                   ldz #0
  3406  36e7 a900                   lda #0
  3407  36e9 ea92c0                 sta [next_segment_byte_addr],z
  3408  36ec 1b                     inz
  3409  36ed ea92c0                 sta [next_segment_byte_addr],z
  3410  36f0 1b                     inz
  3411  36f1 ea92c0                 sta [next_segment_byte_addr],z
  3412  36f4 1b                     inz
  3413  36f5 ea92c0                 sta [next_segment_byte_addr],z
  3414                          
  3415                          @increment_pc:
  3416                              ; Add length program_counter and next_segment_pc.
  3417  36f8 a5e4                   lda expr_a
  3418  36fa 18                     clc
  3419  36fb 65b7                   adc program_counter
  3420  36fd 85b7                   sta program_counter
  3421  36ff 85be                   sta next_segment_pc
  3422  3701 a5e5                   lda expr_a+1
  3423  3703 65b8                   adc program_counter+1
  3424  3705 85b8                   sta program_counter+1
  3425  3707 85bf                   sta next_segment_pc+1
  3426  3709 9008                   bcc +
  3427  370b a908                   lda #err_pc_overflow
  3428  370d 85f3                   sta err_code
  3429  370f a9ff                   lda #$ff
  3430  3711 85f2                   sta line_pos
  3431  3713 60                 +   rts
  3432                          
  3433                          
  3434                          ; Input: completed assembly
  3435                          ;   C=1: skip file markers
  3436                          ; Output: current_segment = ptr to first segment, or to null segment if table emtpy
  3437                          start_segment_traversal:
  3438  3714 a900                   lda #<attic_segments
  3439  3716 85ba                   sta current_segment
  3440  3718 a9b7                   lda #>attic_segments
  3441  371a 85bb                   sta current_segment+1
  3442  371c a971                   lda #^attic_segments
  3443  371e 85bc                   sta current_segment+2
  3444  3720 a908                   lda #<(attic_segments >>> 24)
  3445  3722 85bd                   sta current_segment+3
  3446                          
  3447  3724 9008                   bcc +
  3448  3726 209837                 jsr is_file_marker_segment_traversal
  3449  3729 9003                   bcc +
  3450  372b 207a37                 jsr next_segment_traversal_skip_file_markers
  3451                          
  3452  372e 60                 +   rts
  3453                          
  3454                          
  3455                          ; Input: completed assembly; current_segment points to an entry or to null terminator
  3456                          ; Output: If current_segment not null, advanced.
  3457                          next_segment_traversal:
  3458  372f 208137                 jsr is_end_segment_traversal
  3459  3732 9001                   bcc +
  3460                              ; Do nothing if current segment is already the end.
  3461  3734 60                     rts
  3462                          
  3463  3735 209837             +   jsr is_file_marker_segment_traversal
  3464  3738 9009                   bcc +
  3465                              ; Advance across one file marker.
  3466  373a a900                   lda #0
  3467  373c aa                     tax
  3468  373d a8                     tay
  3469  373e 4b                     taz
  3470  373f a90a                   lda #$0a
  3471  3741 8015                   bra ++
  3472                          
  3473                          +   ; Advance across a data segment.
  3474  3743 a302                   ldz #2
  3475  3745 18                     clc
  3476  3746 eab2ba                 lda [current_segment],z
  3477  3749 6904                   adc #4
  3478  374b a8                     tay
  3479  374c 1b                     inz
  3480  374d eab2ba                 lda [current_segment],z
  3481  3750 6900                   adc #0
  3482  3752 aa                     tax
  3483  3753 98                     tya
  3484  3754 a000                   ldy #0
  3485  3756 a300                   ldz #0  ; Q = length + 4
  3486                          
  3487  3758 18                 ++  clc
  3488  3759 424265ba               adcq current_segment
  3489  375d 424285ba               stq current_segment  ; current_segment += length + 4
  3490  3761 60                     rts
  3491                          
  3492                          skip_file_markers:
  3493                              ; Skip zero or more file markers.
  3494  3762 209837             -   jsr is_file_marker_segment_traversal
  3495  3765 9012                   bcc +
  3496                              ; Skip file marker
  3497  3767 a900                   lda #0
  3498  3769 aa                     tax
  3499  376a a8                     tay
  3500  376b 4b                     taz
  3501  376c a90a                   lda #$0a
  3502  376e 18                     clc
  3503  376f 424265ba               adcq current_segment
  3504  3773 424285ba               stq current_segment
  3505  3777 80e9                   bra -
  3506  3779 60                 +   rts
  3507                          
  3508                          next_segment_traversal_skip_file_markers:
  3509  377a 202f37                 jsr next_segment_traversal
  3510  377d 206237                 jsr skip_file_markers
  3511  3780 60                     rts
  3512                          
  3513                          
  3514                          ; Input: completed assembly; current_segment points to an entry or to null terminator
  3515                          ; Output:
  3516                          ;   C=1: current_segment points to end of list.
  3517                          is_end_segment_traversal:
  3518  3781 a300                   ldz #0
  3519  3783 eab2ba                 lda [current_segment],z
  3520  3786 1b                     inz
  3521  3787 ea12ba                 ora [current_segment],z
  3522  378a 1b                     inz
  3523  378b ea12ba                 ora [current_segment],z
  3524  378e 1b                     inz
  3525  378f ea12ba                 ora [current_segment],z
  3526  3792 d002                   bne +
  3527  3794 38                     sec
  3528  3795 60                     rts
  3529  3796 18                 +   clc
  3530  3797 60                     rts
  3531                          
  3532                          ; Input: completed assembly; current_segment points to an entry or to null terminator
  3533                          ; Output:
  3534                          ;   C=1: current_segment points to end of list.
  3535                          is_file_marker_segment_traversal:
  3536  3798 a300                   ldz #0
  3537  379a eab2ba                 lda [current_segment],z
  3538  379d c900                   cmp #$00
  3539  379f d01a                   bne +
  3540  37a1 1b                     inz
  3541  37a2 eab2ba                 lda [current_segment],z
  3542  37a5 c900                   cmp #$00
  3543  37a7 d012                   bne +
  3544  37a9 1b                     inz
  3545  37aa eab2ba                 lda [current_segment],z
  3546  37ad c9ff                   cmp #$ff
  3547  37af d00a                   bne +
  3548  37b1 1b                     inz
  3549  37b2 eab2ba                 lda [current_segment],z
  3550  37b5 c9ff                   cmp #$ff
  3551  37b7 d002                   bne +
  3552  37b9 38                     sec
  3553  37ba 60                     rts
  3554  37bb 18                 +   clc
  3555  37bc 60                     rts
  3556                          
  3557                          
  3558                          ; Tests whether a segment overlaps a region
  3559                          ; Input: A/X=start addr, Y/Z=length; completed assembly
  3560                          ;   C=1 skip an entry if expr_result = current_segment (entry addresses)
  3561                          ; Output:
  3562                          ;   C=0 no overlap
  3563                          ;   C=1 yes overlap; current_segment=ptr to first overlapping segment entry
  3564                          ; Uses expr_a, expr_b, and asm_flags.
  3565                          does_a_segment_overlap:
  3566  37bd 424285e4               stq expr_a
  3567  37c1 a5b9                   lda asm_flags  ; Borrow flag for "skip entry enable"
  3568  37c3 9004                   bcc +
  3569  37c5 0980                   ora #F_ASM_SRC_TO_BUF
  3570  37c7 8002                   bra ++
  3571  37c9 2980               +   and #F_ASM_SRC_TO_BUF
  3572  37cb 85b9               ++  sta asm_flags
  3573                          
  3574  37cd 4242a5e4               ldq expr_a
  3575  37d1 18                     clc
  3576  37d2 65e6                   adc expr_a+2
  3577  37d4 85e6                   sta expr_a+2
  3578  37d6 a5e5                   lda expr_a+1
  3579  37d8 65e7                   adc expr_a+3
  3580  37da 85e7                   sta expr_a+3  ; expr_a.0-1: start, expr_a.2-3: end+1
  3581                          
  3582  37dc 38                     sec
  3583  37dd 201437                 jsr start_segment_traversal
  3584                          
  3585                          @search_loop:
  3586  37e0 208137                 jsr is_end_segment_traversal
  3587  37e3 9002                   bcc +
  3588  37e5 18                     clc
  3589  37e6 60                     rts
  3590                          +
  3591                          
  3592                              ; If requested, skip the segment if address in expr_result.
  3593                              ; (For do_any_segments_overlap.)
  3594  37e7 24b9                   bit asm_flags
  3595  37e9 100b                   bpl +
  3596  37eb 4242a5ec               ldq expr_result
  3597  37ef 4242c5ba               cpq current_segment
  3598  37f3 f36500                 lbeq @next
  3599                          +
  3600                          
  3601  37f6 a300                   ldz #0
  3602  37f8 4242eab2ba             ldq [current_segment]
  3603  37fd 424285e8               stq expr_b
  3604  3801 18                     clc
  3605  3802 65ea                   adc expr_b+2
  3606  3804 85ea                   sta expr_b+2
  3607  3806 a5e9                   lda expr_b+1
  3608  3808 65eb                   adc expr_b+3
  3609  380a 85eb                   sta expr_b+3  ; expr_b.0-1: cur start, expr_b.2-3: cur end+1
  3610                          
  3611                              ; A start <= B start < A end+1
  3612                              ;   AAAA      AAAAA
  3613                              ;     BBBB     BBB
  3614  380c a5e9c5e5d004a5e8...    +cmp16 expr_b, expr_a
  3615  3816 900e                   bcc ++  ; C=0: B start < A start
  3616  3818 a5e9c5e7d004a5e8...    +cmp16 expr_b, expr_a+2
  3617  3822 b002                   bcs ++  ; C=1: B start >= A end
  3618  3824 38                     sec
  3619  3825 60                     rts
  3620                          
  3621                          ++  ; A start <= B end < A end+1
  3622                              ;     AAAA    AAAAA
  3623                              ;   BBBB       BBB
  3624  3826 a5ebc5e5d004a5ea...    +cmp16 expr_b+2, expr_a
  3625  3830 900e                   bcc ++  ; C=0: B end < A start
  3626  3832 a5ebc5e7d004a5ea...    +cmp16 expr_b+2, expr_a+2
  3627  383c b002                   bcs ++  ; C=1: B end >= A end
  3628  383e 38                     sec
  3629  383f 60                     rts
  3630                          
  3631                          ++  ; B start < A start && A end+1 <= B end+1
  3632                              ;    AAA
  3633                              ;   BBBBB
  3634  3840 a5e9c5e5d004a5e8...    +cmp16 expr_b, expr_a
  3635  384a b00e                   bcs ++  ; C=1: B start >= A start
  3636  384c a5ebc5e7d004a5ea...    +cmp16 expr_b+2, expr_a+2
  3637  3856 9002                   bcc ++  ; C=0: B end < A end
  3638  3858 38                     sec
  3639  3859 60                     rts
  3640                          ++
  3641                          
  3642                          @next
  3643                              ; No overlap. Next segment...
  3644  385a 207a37                 jsr next_segment_traversal_skip_file_markers
  3645  385d 8381ff                 lbra @search_loop
  3646                          
  3647                          
  3648                          ; Output:
  3649                          ;   C=0 no overlap between any two segments
  3650                          ;   C=1 yes overlap;
  3651                          ;      current_segment and expr_result are pointers to overlapping entries
  3652                          ; Uses expr_result.
  3653                          do_any_segments_overlap:
  3654  3860 38                     sec
  3655  3861 201437                 jsr start_segment_traversal
  3656                          @outer_loop
  3657  3864 208137                 jsr is_end_segment_traversal
  3658  3867 9002                   bcc +
  3659  3869 18                     clc
  3660  386a 60                     rts
  3661  386b 4242a5ba           +   ldq current_segment
  3662  386f 424285ec               stq expr_result
  3663                          
  3664  3873 a300                   ldz #0
  3665  3875 4242eab2ba             ldq [current_segment]
  3666  387a 38                     sec
  3667  387b 20bd37                 jsr does_a_segment_overlap
  3668  387e 9001                   bcc +
  3669  3880 60                     rts
  3670  3881 4242a5ec           +   ldq expr_result
  3671  3885 424285ba               stq current_segment
  3672  3889 207a37                 jsr next_segment_traversal_skip_file_markers
  3673  388c 83d6ff                 lbra @outer_loop
  3674                          
  3675                          
  3676                          ; ------------------------------------------------------------
  3677                          ; Forced 16's list
  3678                          ; ------------------------------------------------------------
  3679                          ; Record, 2 bytes: (pc16)
  3680                          ; This is a null-terminated list of 16-bit program counter values
  3681                          ; whose addresses are forced to 16-bit widths by the first pass.
  3682                          ; Specifically, an undefined operand expression forces 16 bits
  3683                          ; in the first pass, even when defined to a value < 256 in a later
  3684                          ; pass.
  3685                          
  3686                          set_attic_ptr_to_forced16:
  3687  388f a900                   lda #<attic_forced16s
  3688  3891 85f8                   sta attic_ptr
  3689  3893 a967                   lda #>attic_forced16s
  3690  3895 85f9                   sta attic_ptr+1
  3691  3897 a972                   lda #^attic_forced16s
  3692  3899 85fa                   sta attic_ptr+2
  3693  389b a908                   lda #<(attic_forced16s >>> 24)
  3694  389d 85fb                   sta attic_ptr+3
  3695  389f 60                     rts
  3696                          
  3697                          init_forced16:
  3698  38a0 208f38                 jsr set_attic_ptr_to_forced16
  3699  38a3 a900                   lda #0
  3700  38a5 a300                   ldz #0
  3701  38a7 ea92f8                 sta [attic_ptr],z
  3702  38aa 1b                     inz
  3703  38ab ea92f8                 sta [attic_ptr],z
  3704  38ae 60                     rts
  3705                          
  3706                          ; Input: program_counter
  3707                          ; Output: C=1 if PC is in the list
  3708                          ;   attic_ptr at PC entry or end of list
  3709                          find_forced16:
  3710  38af 208f38                 jsr set_attic_ptr_to_forced16
  3711                          
  3712                              ; Report an undefined PC as "not found"
  3713  38b2 a5b9                   lda asm_flags
  3714  38b4 2901                   and #F_ASM_PC_DEFINED
  3715  38b6 f03c                   beq @not_found
  3716                          
  3717  38b8 a6b7                   ldx program_counter
  3718  38ba a4b8                   ldy program_counter+1
  3719  38bc a300               -   ldz #0
  3720  38be 8a                     txa
  3721  38bf ead2f8                 cmp [attic_ptr],z
  3722  38c2 d008                   bne +
  3723  38c4 98                     tya
  3724  38c5 1b                     inz
  3725  38c6 ead2f8                 cmp [attic_ptr],z
  3726  38c9 f027                   beq @found
  3727  38cb 3b                     dez
  3728  38cc eab2f8             +   lda [attic_ptr],z
  3729  38cf 1b                     inz
  3730  38d0 ea12f8                 ora [attic_ptr],z
  3731  38d3 d002                   bne +
  3732  38d5 801d                   bra @not_found
  3733                          
  3734                          +   ; next
  3735  38d7 a902                   lda #2
  3736  38d9 18                     clc
  3737  38da 65f8                   adc attic_ptr
  3738  38dc 85f8                   sta attic_ptr
  3739  38de a900                   lda #0
  3740  38e0 65f9                   adc attic_ptr+1
  3741  38e2 85f9                   sta attic_ptr+1
  3742  38e4 a900                   lda #0
  3743  38e6 65fa                   adc attic_ptr+2
  3744  38e8 85fa                   sta attic_ptr+2
  3745  38ea a900                   lda #0
  3746  38ec 65fb                   adc attic_ptr+3
  3747  38ee 85fb                   sta attic_ptr+3
  3748  38f0 80ca                   bra -
  3749                          
  3750                          @found
  3751  38f2 38                     sec
  3752  38f3 60                     rts
  3753                          @not_found
  3754  38f4 18                     clc
  3755  38f5 60                     rts
  3756                          
  3757                          
  3758                          ; Add the program counter to the forced-16's list
  3759                          ; Input: program_counter
  3760                          add_forced16:
  3761  38f6 20af38                 jsr find_forced16
  3762  38f9 9001                   bcc +
  3763  38fb 60                     rts   ; already in the list
  3764                          +
  3765                              ; Don't add an undefined PC
  3766  38fc a5b9                   lda asm_flags
  3767  38fe 2901                   and #F_ASM_PC_DEFINED
  3768  3900 f017                   beq +
  3769                          
  3770  3902 a300                   ldz #0
  3771  3904 a5b7                   lda program_counter
  3772  3906 ea92f8                 sta [attic_ptr],z
  3773  3909 1b                     inz
  3774  390a a5b8                   lda program_counter+1
  3775  390c ea92f8                 sta [attic_ptr],z
  3776  390f 1b                     inz
  3777  3910 a900                   lda #0
  3778  3912 ea92f8                 sta [attic_ptr],z
  3779  3915 1b                     inz
  3780  3916 ea92f8                 sta [attic_ptr],z
  3781  3919 60                 +   rts
  3782                          
  3783                          
  3784                          ; ------------------------------------------------------------
  3785                          ; Relative label table
  3786                          ; ------------------------------------------------------------
  3787                          ; Terminator (on both ends): (00, 00, 00)
  3788                          ; Record: (tok_type[7] : len[0:6], pc16)
  3789                          ;   tok_type: 0=plus 1=minus
  3790                          
  3791                          start_rellabel_table:
  3792  391a a900                   lda #<attic_rellabels
  3793  391c 85f8                   sta attic_ptr
  3794  391e a97d                   lda #>attic_rellabels
  3795  3920 85f9                   sta attic_ptr+1
  3796  3922 a972                   lda #^attic_rellabels
  3797  3924 85fa                   sta attic_ptr+2
  3798  3926 a908                   lda #$08
  3799  3928 85fb                   sta attic_ptr+3
  3800  392a 60                     rts
  3801                          
  3802                          ; Z flag=1 yes, Z flag=0 no
  3803                          rellabel_on_terminator:
  3804  392b a300                   ldz #0
  3805  392d eab2f8                 lda [attic_ptr],z
  3806  3930 1b                     inz
  3807  3931 ea12f8                 ora [attic_ptr],z
  3808  3934 1b                     inz
  3809  3935 ea12f8                 ora [attic_ptr],z
  3810  3938 c900                   cmp #0
  3811  393a 60                     rts
  3812                          
  3813                          next_rellabel:
  3814  393b 4242e6f8               inq attic_ptr
  3815  393f 4242e6f8               inq attic_ptr
  3816  3943 4242e6f8               inq attic_ptr
  3817  3947 60                     rts
  3818                          
  3819                          prev_rellabel:
  3820  3948 4242c6f8               deq attic_ptr
  3821  394c 4242c6f8               deq attic_ptr
  3822  3950 4242c6f8               deq attic_ptr
  3823  3954 60                     rts
  3824                          
  3825                          init_rellabel_table:
  3826  3955 201a39                 jsr start_rellabel_table
  3827  3958 a305                   ldz #5
  3828  395a a900                   lda #0
  3829  395c ea92f8             -   sta [attic_ptr],z
  3830  395f 3b                     dez
  3831  3960 10fa                   bpl -
  3832                          
  3833  3962 a903                   lda #<(attic_rellabels+3)
  3834  3964 85d5                   sta rellabels_next
  3835  3966 a97d                   lda #>(attic_rellabels+3)
  3836  3968 85d6                   sta rellabels_next+1
  3837  396a a972                   lda #^(attic_rellabels+3)
  3838  396c 85d7                   sta rellabels_next+2
  3839  396e 60                     rts
  3840                          
  3841                          ; Inputs:
  3842                          ;    C=0 plus, C=1 minus
  3843                          ;    A=len; X/Y=PC
  3844                          ;    rellabels_next=address of ending terminator
  3845                          ; Outputs:
  3846                          ;    C=1 out of memory
  3847                          ; Uses attic_ptr
  3848                          add_rellabel:
  3849  396f 9002                   bcc +
  3850  3971 0980                   ora #$80
  3851  3973 48                 +   pha
  3852                          
  3853                              ; attic_ptr = rellabels_next
  3854  3974 a5d5                   lda rellabels_next
  3855  3976 85f8                   sta attic_ptr
  3856  3978 a5d6                   lda rellabels_next+1
  3857  397a 85f9                   sta attic_ptr+1
  3858  397c a5d7                   lda rellabels_next+2
  3859  397e 85fa                   sta attic_ptr+2
  3860  3980 a908                   lda #$08
  3861  3982 85fb                   sta attic_ptr+3
  3862                          
  3863                              ; Write the new entry
  3864  3984 a300                   ldz #0
  3865  3986 68                     pla
  3866  3987 ea92f8                 sta [attic_ptr],z
  3867  398a 1b                     inz
  3868  398b 8a                     txa
  3869  398c ea92f8                 sta [attic_ptr],z
  3870  398f 1b                     inz
  3871  3990 98                     tya
  3872  3991 ea92f8                 sta [attic_ptr],z
  3873                          
  3874                              ; Write new list terminator
  3875  3994 1b                     inz
  3876  3995 a900                   lda #0
  3877  3997 ea92f8                 sta [attic_ptr],z
  3878  399a 1b                     inz
  3879  399b a900                   lda #0
  3880  399d ea92f8                 sta [attic_ptr],z
  3881  39a0 1b                     inz
  3882  39a1 a900                   lda #0
  3883  39a3 ea92f8                 sta [attic_ptr],z
  3884                          
  3885                              ; Increment rellabels_next and attic_ptr
  3886  39a6 a5d5                   lda rellabels_next
  3887  39a8 18                     clc
  3888  39a9 6903                   adc #3
  3889  39ab 85d5                   sta rellabels_next
  3890  39ad 85f8                   sta attic_ptr
  3891  39af a5d6                   lda rellabels_next+1
  3892  39b1 6900                   adc #0
  3893  39b3 85d6                   sta rellabels_next+1
  3894  39b5 85f9                   sta attic_ptr+1
  3895  39b7 a5d7                   lda rellabels_next+2
  3896  39b9 6900                   adc #0
  3897  39bb 85d7                   sta rellabels_next+2
  3898  39bd 85fa                   sta attic_ptr+2
  3899                          
  3900                              ; Test for out of memory
  3901  39bf a900                   lda #<attic_rellabels_end
  3902  39c1 a28d                   ldx #>attic_rellabels_end
  3903  39c3 a072                   ldy #^attic_rellabels_end
  3904  39c5 a308                   ldz #$08
  3905  39c7 4242c5f8               cpq attic_ptr
  3906  39cb b002                   bcs +
  3907  39cd 38                     sec  ; out of memory
  3908  39ce 60                     rts
  3909  39cf 18                 +   clc
  3910  39d0 60                     rts
  3911                          
  3912                          ; Inputs:
  3913                          ;    C=0 plus, C=1 minus
  3914                          ;    A=len; X/Y=current PC
  3915                          ; Outputs:
  3916                          ;    C=0 not found
  3917                          ;    C=1 found; X/Y=label definition
  3918                          ; Uses expr_a, attic_ptr
  3919                          eval_rellabel:
  3920  39d1 9002                   bcc +
  3921  39d3 0980                   ora #$80
  3922  39d5 85e4               +   sta expr_a
  3923  39d7 86e5                   stx expr_a+1
  3924  39d9 84e6                   sty expr_a+2
  3925  39db 201a39                 jsr start_rellabel_table
  3926  39de 203b39                 jsr next_rellabel
  3927                          
  3928                              ; Entry table ordered by PC ascending.
  3929                              ; Scan forward to target_PC <= entry_pc, or to end of table
  3930                          @pc_scan_loop
  3931  39e1 202b39                 jsr rellabel_on_terminator
  3932  39e4 f01c                   beq +++
  3933  39e6 a302                   ldz #2
  3934  39e8 a5e6                   lda expr_a+2
  3935  39ea ead2f8                 cmp [attic_ptr],z
  3936  39ed f004                   beq +   ; target_PC_high = entry_pc_high
  3937  39ef 9011                   bcc +++ ; target_PC_high < entry_pc_high
  3938  39f1 800a                   bra ++  ; target_PC_high > entry_pc_high
  3939  39f3 3b                 +   dez
  3940  39f4 a5e5                   lda expr_a+1
  3941  39f6 ead2f8                 cmp [attic_ptr],z
  3942  39f9 f007                   beq +++  ; target_PC = entry_pc
  3943  39fb 9005                   bcc +++  ; target_PC < entry_pc
  3944                          ++  ; Continue scan
  3945  39fd 203b39                 jsr next_rellabel
  3946  3a00 80df                   bra @pc_scan_loop
  3947                          +++
  3948                          
  3949                              ; If current PC = this entry's PC and direction is positive,
  3950                              ; go ahead one. (Accept: - bra -; Reject: + bra +)
  3951  3a02 a301                   ldz #1
  3952  3a04 eab2f8                 lda [attic_ptr],z
  3953  3a07 c5e5                   cmp expr_a+1
  3954  3a09 d00f                   bne +
  3955  3a0b 1b                     inz
  3956  3a0c eab2f8                 lda [attic_ptr],z
  3957  3a0f c5e6                   cmp expr_a+2
  3958  3a11 d007                   bne +
  3959  3a13 24e4                   bit expr_a
  3960  3a15 3003                   bmi +
  3961  3a17 203b39                 jsr next_rellabel
  3962                          +
  3963                          
  3964                              ; If current PC < this entry's PC or on end terminator and direction is
  3965                              ; minus, go back one.
  3966  3a1a 24e4                   bit expr_a
  3967  3a1c 101a                   bpl ++
  3968  3a1e 202b39                 jsr rellabel_on_terminator
  3969  3a21 f012                   beq +
  3970  3a23 a5e6                   lda expr_a+2
  3971  3a25 a302                   ldz #2
  3972  3a27 ead2f8                 cmp [attic_ptr],z
  3973  3a2a 9009                   bcc +
  3974  3a2c a5e5                   lda expr_a+1
  3975  3a2e a301                   ldz #1
  3976  3a30 ead2f8                 cmp [attic_ptr],z
  3977  3a33 b003                   bcs ++
  3978  3a35 204839             +   jsr prev_rellabel
  3979                          ++
  3980                          
  3981                              ; Scan in label direction to dir+len, or to end/beginning of table
  3982                          @label_scan_loop
  3983  3a38 202b39                 jsr rellabel_on_terminator
  3984  3a3b d002                   bne +
  3985                              ; Not found
  3986  3a3d 18                     clc
  3987  3a3e 60                     rts
  3988                          
  3989  3a3f a300               +   ldz #0
  3990  3a41 eab2f8                 lda [attic_ptr],z
  3991  3a44 c5e4                   cmp expr_a
  3992  3a46 d00d                   bne +
  3993                              ; Found
  3994  3a48 a301                   ldz #1
  3995  3a4a eab2f8                 lda [attic_ptr],z
  3996  3a4d aa                     tax
  3997  3a4e 1b                     inz
  3998  3a4f eab2f8                 lda [attic_ptr],z
  3999  3a52 a8                     tay
  4000  3a53 38                     sec
  4001  3a54 60                     rts
  4002                          
  4003                              ; Next
  4004  3a55 24e4               +   bit expr_a
  4005  3a57 3005                   bmi +
  4006  3a59 203b39                 jsr next_rellabel
  4007  3a5c 80da                   bra @label_scan_loop
  4008  3a5e 204839             +   jsr prev_rellabel
  4009  3a61 80d5                   bra @label_scan_loop
  4010                          
  4011                          
  4012                          ; ------------------------------------------------------------
  4013                          ; Parser primitives
  4014                          ; ------------------------------------------------------------
  4015                          
  4016                          ; Input: A=token; tokbuf, tok_pos
  4017                          ; Output:
  4018                          ;   C=0 ok, tok_pos advanced
  4019                          ;   C=1 not found, tok_pos preserved
  4020                          expect_token:
  4021  3a63 a6f1                   ldx tok_pos
  4022  3a65 dd007e                 cmp tokbuf,x
  4023  3a68 d007                   bne @fail
  4024  3a6a e8                     inx
  4025  3a6b e8                     inx
  4026  3a6c 86f1                   stx tok_pos
  4027  3a6e 18                     clc
  4028  3a6f 8001                   bra @end
  4029                          @fail
  4030  3a71 38                     sec
  4031                          @end
  4032  3a72 60                     rts
  4033                          
  4034                          
  4035                          ; Input: tokbuf, tok_pos
  4036                          ; Output:
  4037                          ;   C=0 ok, tok_pos advanced; A=tk_pluses or tk_minuses, Y=length
  4038                          ;   C=1 not found, tok_pos preserved
  4039                          expect_pluses_or_minuses:
  4040  3a73 a6f1                   ldx tok_pos
  4041  3a75 bd007e                 lda tokbuf,x
  4042  3a78 c9ba                   cmp #tk_pluses
  4043  3a7a f006                   beq @succeed
  4044  3a7c c9bb                   cmp #tk_minuses
  4045  3a7e f002                   beq @succeed
  4046  3a80 38                     sec
  4047  3a81 60                     rts
  4048                          @succeed
  4049  3a82 4b                     taz
  4050  3a83 e8                     inx
  4051  3a84 e8                     inx
  4052  3a85 bd007e                 lda tokbuf,x
  4053  3a88 e8                     inx
  4054  3a89 a8                     tay
  4055  3a8a 6b                     tza
  4056  3a8b 86f1                   stx tok_pos
  4057  3a8d 18                     clc
  4058  3a8e 60                     rts
  4059                          
  4060                          ; Input: tokbuf, tok_pos
  4061                          ; Output:
  4062                          ;   C=0 ok, tok_pos advanced; A=tk_pluses or tk_minuses
  4063                          ;   C=1 not found, tok_pos preserved
  4064                          expect_single_plus_or_minus:
  4065  3a8f a6f1                   ldx tok_pos
  4066  3a91 da                     phx
  4067  3a92 20733a                 jsr expect_pluses_or_minuses
  4068  3a95 c001                   cpy #1
  4069  3a97 f005                   beq @succeed
  4070  3a99 fa                     plx
  4071  3a9a 86f1                   stx tok_pos
  4072  3a9c 38                     sec
  4073  3a9d 60                     rts
  4074                          @succeed
  4075  3a9e fa                     plx
  4076  3a9f 18                     clc
  4077  3aa0 60                     rts
  4078                          
  4079                          ; Input: tokbuf, tok_pos
  4080                          ; Output:
  4081                          ;   C=0 ok, tok_pos advanced
  4082                          ;   C=1 not found, tok_pos preserved
  4083                          expect_single_minus:
  4084  3aa1 a6f1                   ldx tok_pos
  4085  3aa3 da                     phx
  4086  3aa4 208f3a                 jsr expect_single_plus_or_minus
  4087  3aa7 b004                   bcs @fail
  4088  3aa9 c9bb                   cmp #tk_minuses
  4089  3aab f005                   beq @succeed
  4090                          @fail
  4091  3aad fa                     plx
  4092  3aae 86f1                   stx tok_pos
  4093  3ab0 38                     sec
  4094  3ab1 60                     rts
  4095                          @succeed
  4096  3ab2 fa                     plx
  4097  3ab3 18                     clc
  4098  3ab4 60                     rts
  4099                          
  4100                          
  4101                          ; Input: tokbuf, tok_pos
  4102                          ; Output:
  4103                          ;   C=0 ok, tok_pos advanced; X=line_pos, Y=length
  4104                          ;   C=1 not found, tok_pos preserved
  4105                          expect_label:
  4106  3ab5 a6f1                   ldx tok_pos
  4107  3ab7 bd007e                 lda tokbuf,x
  4108  3aba c9b9                   cmp #tk_label_or_reg
  4109  3abc d00f                   bne @fail
  4110  3abe e8                     inx
  4111  3abf bd007e                 lda tokbuf,x
  4112  3ac2 e8                     inx
  4113  3ac3 bc007e                 ldy tokbuf,x  ; Y = label token length
  4114  3ac6 e8                     inx
  4115  3ac7 86f1                   stx tok_pos
  4116  3ac9 aa                     tax   ; X = label token line pos
  4117  3aca 18                     clc
  4118  3acb 8001                   bra @end
  4119                          @fail
  4120  3acd 38                     sec
  4121                          @end
  4122  3ace 60                     rts
  4123                          
  4124                          ; Input: X/Y=code address of expected keyword; line_addr, tokbuf, tok_pos
  4125                          ; Output:
  4126                          ;   C=0 matched, tok_pos advanced
  4127                          ;   C=1 not found, tok_pos preserved
  4128                          expect_keyword:
  4129  3acf 86f6                   stx code_ptr
  4130  3ad1 84f7                   sty code_ptr+1
  4131  3ad3 a6f1                   ldx tok_pos
  4132  3ad5 da                     phx
  4133  3ad6 20b53a                 jsr expect_label
  4134  3ad9 b026                   bcs @fail
  4135  3adb 8a                     txa
  4136  3adc 4b                     taz
  4137  3add a200                   ldx #0
  4138  3adf a5f4                   lda line_addr
  4139  3ae1 85fc                   sta bas_ptr
  4140  3ae3 a5f5                   lda line_addr+1
  4141  3ae5 85fd                   sta bas_ptr+1
  4142  3ae7 eab2fc             -   lda [bas_ptr],z
  4143  3aea 9d007f                 sta strbuf,x
  4144  3aed 1b                     inz
  4145  3aee e8                     inx
  4146  3aef 88                     dey
  4147  3af0 d0f5                   bne -
  4148  3af2 a900                   lda #0
  4149  3af4 9d007f                 sta strbuf,x
  4150  3af7 20a02f                 jsr strbuf_to_lowercase
  4151  3afa a200                   ldx #0
  4152  3afc 20b12f                 jsr strbuf_cmp_code_ptr
  4153  3aff f006                   beq @succeed
  4154                          @fail
  4155  3b01 fa                     plx
  4156  3b02 86f1                   stx tok_pos
  4157  3b04 38                     sec
  4158  3b05 8002                   bra @end
  4159                          @succeed
  4160  3b07 fa                     plx
  4161  3b08 18                     clc
  4162                          @end
  4163  3b09 60                     rts
  4164                          
  4165                          
  4166                          ; Input: tokbuf, tok_pos
  4167                          ; Output:
  4168                          ;   C=0 ok, A=token ID, Y=flags, tok_pos advanced
  4169                          ;   C=1 not found, tok_pos preserved
  4170                          expect_opcode:
  4171  3b0a a6f1                   ldx tok_pos
  4172  3b0c bd007e                 lda tokbuf,x
  4173  3b0f f00f                   beq @fail
  4174  3b11 c993                   cmp #tokid_after_mnemonics
  4175  3b13 b00b                   bcs @fail
  4176  3b15 e8                     inx
  4177  3b16 e8                     inx
  4178  3b17 bc007e                 ldy tokbuf,x
  4179  3b1a e8                     inx
  4180  3b1b 86f1                   stx tok_pos
  4181  3b1d 18                     clc
  4182  3b1e 8001                   bra @end
  4183                          @fail
  4184  3b20 38                     sec
  4185                          @end
  4186  3b21 60                     rts
  4187                          
  4188                          
  4189                          ; Input: tokbuf, tok_pos
  4190                          ; Output:
  4191                          ;   C=0 ok, A=token ID, tok_pos advanced
  4192                          ;   C=1 not found, tok_pos preserved
  4193                          expect_pseudoop:
  4194  3b22 a6f1                   ldx tok_pos
  4195  3b24 bd007e                 lda tokbuf,x
  4196  3b27 c993                   cmp #po_to
  4197  3b29 900b                   bcc @fail
  4198  3b2b c9a1                   cmp #last_po+1
  4199  3b2d b007                   bcs @fail
  4200  3b2f e8                     inx
  4201  3b30 e8                     inx
  4202  3b31 86f1                   stx tok_pos
  4203  3b33 18                     clc
  4204  3b34 8001                   bra @end
  4205                          @fail
  4206  3b36 38                     sec
  4207                          @end
  4208  3b37 60                     rts
  4209                          
  4210                          
  4211                          ; Input: tokbuf, tok_pos
  4212                          ; Output:
  4213                          ;   C=0 ok, tok_pos advanced; expr_result, expr_flags
  4214                          ;   C=1 not found, tok_pos preserved
  4215                          expect_literal:
  4216  3b38 a6f1                   ldx tok_pos
  4217  3b3a bd017e                 lda tokbuf+1,x
  4218  3b3d 4b                     taz
  4219  3b3e a5f4                   lda line_addr
  4220  3b40 85fc                   sta bas_ptr
  4221  3b42 a5f5                   lda line_addr+1
  4222  3b44 85fd                   sta bas_ptr+1
  4223  3b46 eab2fc                 lda [bas_ptr],z
  4224  3b49 c927                   cmp #chr_singlequote
  4225  3b4b d006                   bne +
  4226  3b4d a5f0                   lda expr_flags
  4227  3b4f 0903                   ora #F_EXPR_BRACKET_CHARLIT
  4228  3b51 85f0                   sta expr_flags
  4229                          +
  4230                          
  4231  3b53 a6f1                   ldx tok_pos
  4232  3b55 bd007e                 lda tokbuf,x
  4233  3b58 c9b7                   cmp #tk_number_literal_leading_zero
  4234  3b5a d008                   bne +
  4235  3b5c a5f0                   lda expr_flags
  4236  3b5e 0904                   ora #F_EXPR_FORCE16
  4237  3b60 85f0                   sta expr_flags
  4238  3b62 8004                   bra ++
  4239  3b64 c9b6               +   cmp #tk_number_literal
  4240  3b66 d024                   bne @fail
  4241  3b68 bd027e             ++  lda tokbuf+2,x
  4242  3b6b 85ec                   sta expr_result
  4243  3b6d bd037e                 lda tokbuf+3,x
  4244  3b70 85ed                   sta expr_result+1
  4245  3b72 bd047e                 lda tokbuf+4,x
  4246  3b75 85ee                   sta expr_result+2
  4247  3b77 bd057e                 lda tokbuf+5,x
  4248  3b7a 85ef                   sta expr_result+3
  4249  3b7c a906                   lda #6
  4250  3b7e 18                     clc
  4251  3b7f 65f1                   adc tok_pos
  4252  3b81 85f1                   sta tok_pos
  4253  3b83 a900                   lda #0
  4254  3b85 65f2                   adc tok_pos+1
  4255  3b87 85f2                   sta tok_pos+1
  4256  3b89 18                     clc
  4257  3b8a 8001                   bra @end
  4258                          @fail
  4259  3b8c 38                     sec
  4260                          @end
  4261  3b8d 60                     rts
  4262                          
  4263                          
  4264                          ; ------------------------------------------------------------
  4265                          ; Expressions
  4266                          ; ------------------------------------------------------------
  4267                          
  4268                          ; Input: expr_result
  4269                          ; Output:
  4270                          ;   C=1 if:
  4271                          ;     high word = ffff and low word >= 8000, or
  4272                          ;     high word = 0000 and low word < 8000
  4273                          ;   Else, C=0
  4274                          is_expr_word:
  4275  3b8e a5ef                   lda expr_result+3
  4276  3b90 25ee                   and expr_result+2
  4277  3b92 c9ff                   cmp #$ff
  4278  3b94 d008                   bne +
  4279  3b96 a5ed                   lda expr_result+1
  4280  3b98 2980                   and #$80
  4281  3b9a d00a                   bne @yes
  4282  3b9c 8006                   bra @no
  4283  3b9e a5ef               +   lda expr_result+3
  4284  3ba0 05ee                   ora expr_result+2
  4285  3ba2 f002                   beq @yes
  4286                          @no
  4287  3ba4 18                     clc
  4288  3ba5 60                     rts
  4289                          @yes
  4290  3ba6 38                     sec
  4291  3ba7 60                     rts
  4292                          
  4293                          ; Input: expr_result
  4294                          ; Output:
  4295                          ;   C=1 if:
  4296                          ;     high word+byte = ffffff and LSB >= 80, or
  4297                          ;     high word+byte = 000000
  4298                          ;   Else, C=0
  4299                          is_expr_byte:
  4300  3ba8 a5ef                   lda expr_result+3
  4301  3baa 25ee                   and expr_result+2
  4302  3bac 25ed                   and expr_result+1
  4303  3bae c9ff                   cmp #$ff
  4304  3bb0 d008                   bne +
  4305  3bb2 a5ec                   lda expr_result
  4306  3bb4 2980                   and #$80
  4307  3bb6 d00c                   bne @yes
  4308  3bb8 8008                   bra @no
  4309  3bba a5ef               +   lda expr_result+3
  4310  3bbc 05ee                   ora expr_result+2
  4311  3bbe 05ed                   ora expr_result+1
  4312  3bc0 f002                   beq @yes
  4313                          @no
  4314  3bc2 18                     clc
  4315  3bc3 60                     rts
  4316                          @yes
  4317  3bc4 38                     sec
  4318  3bc5 60                     rts
  4319                          
  4320                          
  4321                          ; Expression grammar:
  4322                          ;   primary   ::= * | <label> | <literal> | "(" expr ")" | "[" expr "]"
  4323                          ;   inversion ::= (!)? primary
  4324                          ;   power     ::= inversion (^ inversion)*
  4325                          ;   negate    ::= (-)? power
  4326                          ;   factor    ::= negate ((* DIV / %) negate)*
  4327                          ;   term      ::= factor ((+ -) factor)*
  4328                          ;   shift     ::= term ((<< >> >>>) term)*
  4329                          ;   bytesel   ::= (< > ^ ^^)? shift
  4330                          ;   expr      ::= bytesel ((& XOR |) bytesel)*
  4331                          ;
  4332                          ; All "expect_" routines rely on global tokbuf and line_addr, and manipulate
  4333                          ; global tok_pos. Each returns a result as follows:
  4334                          ;   C=0 ok, tok_pos advanced; result in expr_result, expr_flags
  4335                          ;   C=1 not found, tok_pos preserved
  4336                          ;     err_code>0, line_pos: report error in expression
  4337                          ;
  4338                          ; Any C=0 return with expr_flags & F_EXPR_UNDEFINED should propagate
  4339                          ; F_EXPR_UNDEFINED and not bother to set expr_result.
  4340                          ;
  4341                          ; Bracket flags propagate if the rule matches the higher precedence rule
  4342                          ; without applying an operation.
  4343                          ;
  4344                          ; Intermediate results are kept on the stack, and unwound within each
  4345                          ; subroutine.
  4346                          
  4347                          ; primary   ::= * | <label> | <literal> | "(" expr ")" | "[" expr "]"
  4348                          expect_primary:
  4349  3bc6 a5f0                   lda expr_flags
  4350  3bc8 29fc                   and #!F_EXPR_BRACKET_MASK
  4351  3bca 85f0                   sta expr_flags
  4352                          
  4353  3bcc a6f1                   ldx tok_pos
  4354  3bce da                     phx
  4355                          
  4356  3bcf bd007e                 lda tokbuf,x
  4357  3bd2 f3d200                 lbeq @fail
  4358                          
  4359                              ; "(" expr ")"
  4360  3bd5 a9b0                   lda #tk_lparen
  4361  3bd7 20633a                 jsr expect_token
  4362  3bda b019                   bcs +++
  4363  3bdc 20b63f                 jsr expect_expr
  4364  3bdf b3c500                 lbcs @fail
  4365  3be2 a9b1                   lda #tk_rparen
  4366  3be4 20633a                 jsr expect_token
  4367  3be7 b3bd00                 lbcs @fail
  4368  3bea a5f0                   lda expr_flags
  4369  3bec 29fc                   and #!F_EXPR_BRACKET_MASK
  4370  3bee 0901                   ora #F_EXPR_BRACKET_PAREN
  4371  3bf0 85f0                   sta expr_flags
  4372  3bf2 83b700                 lbra @succeed
  4373                          
  4374                              ; "[" <expr> "]"
  4375  3bf5 a9b2               +++ lda #tk_lbracket
  4376  3bf7 20633a                 jsr expect_token
  4377  3bfa b019                   bcs +++
  4378  3bfc 20b63f                 jsr expect_expr
  4379  3bff b3a500                 lbcs @fail
  4380  3c02 a9b3                   lda #tk_rbracket
  4381  3c04 20633a                 jsr expect_token
  4382  3c07 b39d00                 lbcs @fail
  4383  3c0a a5f0                   lda expr_flags
  4384  3c0c 29fc                   and #!F_EXPR_BRACKET_MASK
  4385  3c0e 0902                   ora #F_EXPR_BRACKET_SQUARE
  4386  3c10 85f0                   sta expr_flags
  4387  3c12 839700                 lbra @succeed
  4388                          
  4389                              ; Program counter (*)
  4390  3c15 a9a3               +++ lda #tk_multiply
  4391  3c17 20633a                 jsr expect_token
  4392  3c1a b01d                   bcs +++
  4393  3c1c a5b7                   lda program_counter
  4394  3c1e 85ec                   sta expr_result
  4395  3c20 a5b8                   lda program_counter+1
  4396  3c22 85ed                   sta expr_result+1
  4397  3c24 a900                   lda #0
  4398  3c26 85ee                   sta expr_result+2
  4399  3c28 85ef                   sta expr_result+3
  4400  3c2a a5b9                   lda asm_flags
  4401  3c2c 2901                   and #F_ASM_PC_DEFINED
  4402  3c2e d006                   bne +
  4403  3c30 a5f0                   lda expr_flags
  4404  3c32 0908                   ora #F_EXPR_UNDEFINED
  4405  3c34 85f0                   sta expr_flags
  4406  3c36 837300             +   lbra @succeed
  4407                          
  4408                              ; Relative label
  4409  3c39 20733a             +++ jsr expect_pluses_or_minuses
  4410  3c3c b32100                 lbcs +++
  4411                              ; C=0 plus, C=1 minus
  4412                              ; A=len; X/Y=current PC
  4413  3c3f c9ba                   cmp #tk_pluses
  4414  3c41 f003                   beq +
  4415  3c43 38                     sec
  4416  3c44 8001                   bra ++
  4417  3c46 18                 +   clc
  4418                          ++
  4419  3c47 98                     tya
  4420  3c48 a6b7                   ldx program_counter
  4421  3c4a a4b8                   ldy program_counter+1
  4422  3c4c 20d139                 jsr eval_rellabel
  4423  3c4f 933700                 lbcc @undefined_label
  4424  3c52 86ec               +   stx expr_result
  4425  3c54 84ed                   sty expr_result+1
  4426  3c56 a900                   lda #0
  4427  3c58 85ee                   sta expr_result+2
  4428  3c5a 85ef                   sta expr_result+3
  4429  3c5c 834d00                 lbra @succeed
  4430                          
  4431                              ; <label>
  4432  3c5f 20b53a             +++ jsr expect_label
  4433  3c62 b33b00                 lbcs +++
  4434  3c65 20ca40                 jsr find_or_add_label
  4435  3c68 201d35                 jsr get_symbol_value
  4436  3c6b b01b                   bcs @undefined_label
  4437  3c6d 424285ec               stq expr_result
  4438  3c71 a303                   ldz #3
  4439  3c73 a5f0                   lda expr_flags
  4440  3c75 29fb                   and #!F_EXPR_FORCE16
  4441  3c77 85f0                   sta expr_flags
  4442  3c79 eab2f8                 lda [attic_ptr],z  ; flags
  4443  3c7c 2902                   and #F_SYMTBL_LEADZERO
  4444  3c7e f006                   beq +
  4445  3c80 a5f0                   lda expr_flags
  4446  3c82 0904                   ora #F_EXPR_FORCE16
  4447  3c84 85f0                   sta expr_flags
  4448  3c86 8023               +   bra @succeed
  4449                          
  4450                          @undefined_label
  4451  3c88 a5f0               ++  lda expr_flags
  4452  3c8a 0908                   ora #F_EXPR_UNDEFINED
  4453  3c8c 85f0                   sta expr_flags
  4454  3c8e 24b6                   bit pass           ; undefined label is an error in final pass
  4455  3c90 1019                   bpl @succeed
  4456  3c92 a907                   lda #err_undefined
  4457  3c94 85f3                   sta err_code
  4458  3c96 a6f1                   ldx tok_pos
  4459  3c98 bdfe7d                 lda tokbuf-2,x     ; back up to the label's line_pos
  4460  3c9b 85f2                   sta line_pos
  4461  3c9d 8007                   bra @fail
  4462                          
  4463                              ; <literal>
  4464                          +++ ; Test whether this is a char literal, to flag it for !scr.
  4465  3c9f 20383b                 jsr expect_literal
  4466  3ca2 b002                   bcs @fail
  4467  3ca4 8005                   bra @succeed
  4468                          
  4469                          @fail
  4470  3ca6 fa                     plx
  4471  3ca7 86f1                   stx tok_pos
  4472  3ca9 38                     sec
  4473  3caa 60                     rts
  4474                          @succeed
  4475  3cab fa                     plx
  4476  3cac 18                     clc
  4477  3cad 60                     rts
  4478                          
  4479                          
  4480                          ; inversion ::= (!)* primary
  4481                          expect_inversion:
  4482  3cae a300                   ldz #0
  4483  3cb0 a9a0               -   lda #tk_complement
  4484  3cb2 20633a                 jsr expect_token
  4485  3cb5 b003                   bcs +
  4486  3cb7 1b                     inz
  4487  3cb8 80f6                   bra -
  4488  3cba db                 +   phz
  4489  3cbb 20c63b                 jsr expect_primary
  4490  3cbe fb                     plz
  4491  3cbf b028                   bcs @end
  4492  3cc1 c200                   cpz #0
  4493  3cc3 f023                   beq @ok  ; 0 inversions, preserve flags
  4494  3cc5 a5f0                   lda expr_flags  ; at least one inversion, reset flags
  4495  3cc7 29fc                   and #!F_EXPR_BRACKET_MASK
  4496  3cc9 85f0                   sta expr_flags
  4497  3ccb 6b                     tza
  4498  3ccc 2901                   and #1
  4499  3cce f018                   beq @ok  ; even number of inversions, no value change
  4500  3cd0 a5ec                   lda expr_result
  4501  3cd2 49ff                   eor #$ff
  4502  3cd4 85ec                   sta expr_result
  4503  3cd6 a5ed                   lda expr_result+1
  4504  3cd8 49ff                   eor #$ff
  4505  3cda 85ed                   sta expr_result+1
  4506  3cdc a5ee                   lda expr_result+2
  4507  3cde 49ff                   eor #$ff
  4508  3ce0 85ee                   sta expr_result+2
  4509  3ce2 a5ef                   lda expr_result+3
  4510  3ce4 49ff                   eor #$ff
  4511  3ce6 85ef                   sta expr_result+3
  4512                          @ok
  4513  3ce8 18                     clc
  4514                          @end
  4515  3ce9 60                     rts
  4516                          
  4517                          ; power     ::= inversion (^ inversion)*
  4518                          expect_power:
  4519  3cea 20ae3c                 jsr expect_inversion
  4520  3ced b3bd00                 lbcs @end  ; Missing first operand.
  4521  3cf0 a9a2                   lda #tk_power
  4522  3cf2 20633a                 jsr expect_token
  4523  3cf5 b3b400                 lbcs @ok   ; Passthru
  4524                          
  4525                              ; For right associative, push all expressions parsed, then evaluate while
  4526                              ; unwinding.
  4527  3cf8 a5ec48a5ed48a5ee...    +push32 expr_result
  4528  3d04 a301                   ldz #1
  4529  3d06 db                 -   phz
  4530  3d07 20ae3c                 jsr expect_inversion
  4531  3d0a fb                     plz
  4532  3d0b b39100                 lbcs @drop_stack_and_err  ; Power operator missing operand after operator.
  4533  3d0e a5ec48a5ed48a5ee...    +push32 expr_result
  4534  3d1a 1b                     inz
  4535  3d1b a9a2                   lda #tk_power
  4536  3d1d db                     phz
  4537  3d1e 20633a                 jsr expect_token
  4538  3d21 fb                     plz
  4539  3d22 90e2                   bcc -
  4540                          
  4541                              ; Clear bracket flags.
  4542  3d24 a5f0                   lda expr_flags
  4543  3d26 29fc                   and #!F_EXPR_BRACKET_MASK
  4544  3d28 85f0                   sta expr_flags
  4545                          
  4546                              ; expr_b = 1, used twice later
  4547  3d2a a901                   lda #1
  4548  3d2c 85e8                   sta expr_b
  4549  3d2e a900                   lda #0
  4550  3d30 85e9                   sta expr_b+1
  4551  3d32 85ea                   sta expr_b+2
  4552  3d34 85eb                   sta expr_b+3
  4553                          
  4554                              ; There are Z > 1 values on the stack. Last operand is first exponent.
  4555  3d36 6885ef6885ee6885...    +pull32 expr_result
  4556  3d42 3b                     dez  ; Z = Z - 1
  4557                          
  4558                              ; Z times, pull an operand, and take it to the previous result's power.
  4559                          @power_loop
  4560                              ; If a power is negative (bit 31 is set), abort with error.
  4561  3d43 24ef                   bit expr_result+3
  4562  3d45 1007                   bpl +
  4563  3d47 a90b                   lda #err_exponent_negative
  4564  3d49 85f3                   sta err_code
  4565  3d4b 835100                 lbra @drop_stack_and_err
  4566                          +
  4567                              ; Pull the base.
  4568  3d4e 6885e76885e66885...    +pull32 expr_a
  4569                          
  4570                              ; Stash operand count during the exp_loop.
  4571  3d5a db                     phz
  4572                          
  4573                              ; Take expr_a to the expr_result power. Put final answer in expr_result.
  4574                              ; Edge case: power = 0
  4575  3d5b 4242a5ec               ldq expr_result
  4576  3d5f d006                   bne +
  4577  3d61 a901                   lda #1
  4578  3d63 85ec                   sta expr_result
  4579  3d65 8031                   bra @continue_power_loop
  4580                          +
  4581                          
  4582  3d67 4242a5e4               ldq expr_a
  4583  3d6b 42428d70d7             stq multina
  4584  3d70 4242a5e8               ldq expr_b  ; Start with A * 1
  4585                          @exp_loop
  4586  3d74 42428d74d7             stq multinb
  4587  3d79 4242a5ec               ldq expr_result
  4588  3d7d 38                     sec
  4589  3d7e 4242e5e8               sbcq expr_b
  4590  3d82 424285ec               stq expr_result  ; expr_result = expr_result - 1
  4591  3d86 f007                   beq +
  4592  3d88 4242ad78d7             ldq product
  4593  3d8d 80e5                   bra @exp_loop
  4594                          
  4595  3d8f 4242ad78d7         +   ldq product
  4596  3d94 424285ec               stq expr_result
  4597                          
  4598                          @continue_power_loop
  4599                              ; Restore Z = operand count. Proceed to next operand.
  4600  3d98 fb                     plz
  4601  3d99 3b                     dez
  4602  3d9a d0a7                   bne @power_loop
  4603  3d9c 800d                   bra @ok
  4604                          
  4605                          @drop_stack_and_err
  4606  3d9e c200               -   cpz #0
  4607  3da0 f007                   beq +
  4608  3da2 68                     pla
  4609  3da3 68                     pla
  4610  3da4 68                     pla
  4611  3da5 68                     pla
  4612  3da6 3b                     dez
  4613  3da7 80f5                   bra -
  4614  3da9 38                 +   sec
  4615  3daa 60                     rts
  4616                          @ok
  4617  3dab 18                     clc
  4618                          @end
  4619  3dac 60                     rts
  4620                          
  4621                          
  4622                          ; negate    ::= (-)? power
  4623                          expect_negate:
  4624  3dad 20a13a                 jsr expect_single_minus
  4625  3db0 9006                   bcc +
  4626  3db2 20ea3c                 jsr expect_power  ; Passthru
  4627  3db5 833b00                 lbra @end
  4628                          
  4629  3db8 20ea3c             +   jsr expect_power
  4630  3dbb 900d                   bcc +
  4631                              ; Not a negate expression. Interpret single-minus as relative label.
  4632  3dbd a5f1                   lda tok_pos
  4633  3dbf 38                     sec
  4634  3dc0 e903                   sbc #3
  4635  3dc2 85f1                   sta tok_pos
  4636  3dc4 20ea3c                 jsr expect_power
  4637  3dc7 832900                 lbra @end
  4638                          
  4639                          +
  4640                              ; Negate expr_result (XOR $FFFFFFFF + 1)
  4641  3dca 18                     clc
  4642  3dcb a5ec                   lda expr_result
  4643  3dcd 49ff                   eor #$ff
  4644  3dcf 6901                   adc #1
  4645  3dd1 85ec                   sta expr_result
  4646  3dd3 a5ed                   lda expr_result+1
  4647  3dd5 49ff                   eor #$ff
  4648  3dd7 6900                   adc #0
  4649  3dd9 85ed                   sta expr_result+1
  4650  3ddb a5ee                   lda expr_result+2
  4651  3ddd 49ff                   eor #$ff
  4652  3ddf 6900                   adc #0
  4653  3de1 85ee                   sta expr_result+2
  4654  3de3 a5ef                   lda expr_result+3
  4655  3de5 49ff                   eor #$ff
  4656  3de7 6900                   adc #0
  4657  3de9 85ef                   sta expr_result+3
  4658                          
  4659  3deb a5f0                   lda expr_flags
  4660  3ded 29fc                   and #!F_EXPR_BRACKET_MASK
  4661  3def 85f0                   sta expr_flags
  4662                          
  4663                          @ok
  4664  3df1 18                     clc
  4665                          @end
  4666  3df2 60                     rts
  4667                          
  4668                          
  4669                          ; factor    ::= negate ((* DIV / %) negate)*
  4670                          expect_factor:
  4671  3df3 20ad3d                 jsr expect_negate
  4672  3df6 b39700                 lbcs @end
  4673                          
  4674                              ; Special error message for unsupported fraction operator
  4675  3df9 a9b4                   lda #tk_fraction
  4676  3dfb 20633a                 jsr expect_token
  4677  3dfe b008                   bcs +
  4678  3e00 a90c                   lda #err_fraction_not_supported
  4679  3e02 85f3                   sta err_code
  4680  3e04 38                     sec
  4681  3e05 838800                 lbra @end
  4682                          +
  4683                          
  4684                          @factor_loop
  4685  3e08 a9a3                   lda #tk_multiply
  4686  3e0a 20633a                 jsr expect_token
  4687  3e0d 9013                   bcc +
  4688  3e0f a9a4                   lda #tk_remainder
  4689  3e11 20633a                 jsr expect_token
  4690  3e14 900c                   bcc +
  4691  3e16 a900                   lda #0
  4692  3e18 a235                   ldx #<kw_div
  4693  3e1a a052                   ldy #>kw_div
  4694  3e1c 20cf3a                 jsr expect_keyword
  4695  3e1f b36d00                 lbcs @ok
  4696                          
  4697                              ; A = tk_multiply, tk_remainder, or 0 = DIV
  4698  3e22 48                 +   pha
  4699  3e23 4242a5ec               ldq expr_result
  4700  3e27 42428d70d7             stq multina
  4701  3e2c 20ad3d                 jsr expect_negate
  4702  3e2f 68                     pla
  4703  3e30 85e4                   sta expr_a
  4704  3e32 b35b00                 lbcs @end  ; Operator but no term, fail
  4705  3e35 4242a5ec               ldq expr_result
  4706  3e39 42428d74d7             stq multinb
  4707  3e3e a5e4                   lda expr_a
  4708                          
  4709  3e40 c9a3                   cmp #tk_multiply
  4710  3e42 d007                   bne +
  4711  3e44 4242ad78d7             ldq product
  4712  3e49 803c                   bra ++
  4713                          +   ; DIV and remainder need to wait for DIVBUSY bit
  4714  3e4b ae0fd7             -   ldx mathbusy
  4715  3e4e 30fb                   bmi -
  4716  3e50 c9a4                   cmp #tk_remainder
  4717  3e52 d01f                   bne +
  4718                          
  4719                              ; x % y = x - (x DIV y) * y
  4720                              ; We don't use divrema fractional part of the division because frac * y
  4721                              ; will have rounding issues.
  4722  3e54 4242ad70d7             ldq multina   ; Rip x right out of the math register!
  4723  3e59 424285ec               stq expr_result
  4724  3e5d 4242ad6cd7             ldq divquot   ; x DIV y
  4725  3e62 42428d70d7             stq multina   ; product = (x DIV y) * y
  4726  3e67 4242a5ec               ldq expr_result
  4727  3e6b 38                     sec
  4728  3e6c 4242ed78d7             sbcq product  ; Q = x - (x DIV y) * y
  4729  3e71 8014                   bra ++
  4730                          
  4731  3e73 4242ad74d7         +   ldq multinb
  4732  3e78 d008                   bne +
  4733  3e7a a90f                   lda #err_division_by_zero
  4734  3e7c 85f3                   sta err_code
  4735  3e7e 38                     sec
  4736  3e7f 830e00                 lbra @end
  4737  3e82 4242ad6cd7         +   ldq divquot
  4738  3e87 424285ec           ++  stq expr_result
  4739  3e8b 837bff                 lbra @factor_loop
  4740                          
  4741                          @ok
  4742  3e8e 18                     clc
  4743                          @end
  4744  3e8f 60                     rts
  4745                          
  4746                          
  4747                          ; term      ::= factor ((+ -) factor)*
  4748                          expect_term:
  4749  3e90 20f33d                 jsr expect_factor
  4750  3e93 b34700                 lbcs @end
  4751                          
  4752                          @term_loop
  4753  3e96 208f3a                 jsr expect_single_plus_or_minus
  4754  3e99 b34000                 lbcs @ok
  4755  3e9c 48                 +   pha
  4756  3e9d a5ec48a5ed48a5ee...    +push32 expr_result
  4757  3ea9 20f33d                 jsr expect_factor
  4758  3eac 6885eb6885ea6885...    +pull32 expr_b
  4759  3eb8 68                     pla
  4760  3eb9 b32100                 lbcs @end  ; Operator but no term, fail
  4761                              ; A=tk_pluses or tk_minuses
  4762  3ebc c9ba                   cmp #tk_pluses
  4763  3ebe d00b                   bne +
  4764                              ; expr_result = expr_b + expr_result
  4765  3ec0 4242a5e8               ldq expr_b
  4766  3ec4 18                     clc
  4767  3ec5 424265ec               adcq expr_result
  4768  3ec9 8009                   bra ++
  4769                          +   ; expr_result = expr_b - expr_result
  4770  3ecb 4242a5e8               ldq expr_b
  4771  3ecf 38                     sec
  4772  3ed0 4242e5ec               sbcq expr_result
  4773  3ed4 424285ec           ++  stq expr_result
  4774  3ed8 83bcff                 lbra @term_loop
  4775                          
  4776                          @ok
  4777  3edb 18                     clc
  4778                          @end
  4779  3edc 60                     rts
  4780                          
  4781                          
  4782                          ; shift     ::= term ((<< >> >>>) term)*
  4783                          expect_shift:
  4784  3edd 20903e                 jsr expect_term
  4785  3ee0 b38a00                 lbcs @end
  4786                          
  4787                          @shift_loop
  4788  3ee3 a9a7                   lda #tk_asl
  4789  3ee5 20633a                 jsr expect_token
  4790  3ee8 900f                   bcc +
  4791  3eea a9a6                   lda #tk_asr
  4792  3eec 20633a                 jsr expect_token
  4793  3eef 9008                   bcc +
  4794  3ef1 a9a5                   lda #tk_lsr
  4795  3ef3 20633a                 jsr expect_token
  4796  3ef6 b37300                 lbcs @ok
  4797                          
  4798  3ef9 48                 +   pha
  4799  3efa a5ec48a5ed48a5ee...    +push32 expr_result
  4800  3f06 20903e                 jsr expect_term
  4801  3f09 6885eb6885ea6885...    +pull32 expr_b
  4802  3f15 68                     pla
  4803  3f16 b35400                 lbcs @end  ; Operator but no term, fail
  4804                          
  4805  3f19 4b                     taz
  4806                              ; Z = tk_asl, tk_asr, or tk_lsr
  4807                              ; Perform operation on expr_b, expr_result times. Store result in expr_result.
  4808                          @count_loop
  4809  3f1a a5ef                   lda expr_result+3
  4810  3f1c 05ee                   ora expr_result+2
  4811  3f1e 05ed                   ora expr_result+1
  4812  3f20 05ec                   ora expr_result
  4813  3f22 f33c00                 lbeq @finish_count_loop
  4814                          
  4815  3f25 18                     clc
  4816  3f26 c2a7                   cpz #tk_asl
  4817  3f28 d00a                   bne +
  4818                              ; asl
  4819  3f2a 06e8                   asl expr_b
  4820  3f2c 26e9                   rol expr_b+1
  4821  3f2e 26ea                   rol expr_b+2
  4822  3f30 26eb                   rol expr_b+3
  4823  3f32 8010                   bra +++
  4824  3f34 c2a6               +   cpz #tk_asr
  4825  3f36 d004                   bne +
  4826                              ; asr
  4827  3f38 44eb                   asr expr_b+3
  4828  3f3a 8002                   bra ++
  4829                          +   ; lsr
  4830  3f3c 46eb                   lsr expr_b+3
  4831  3f3e 66ea               ++  ror expr_b+2
  4832  3f40 66e9                   ror expr_b+1
  4833  3f42 66e8                   ror expr_b
  4834                          +++
  4835                          
  4836  3f44 38                     sec
  4837  3f45 a5ec                   lda expr_result
  4838  3f47 e901                   sbc #1
  4839  3f49 85ec                   sta expr_result
  4840  3f4b a5ed                   lda expr_result+1
  4841  3f4d e900                   sbc #0
  4842  3f4f 85ed                   sta expr_result+1
  4843  3f51 a5ee                   lda expr_result+2
  4844  3f53 e900                   sbc #0
  4845  3f55 85ee                   sta expr_result+2
  4846  3f57 a5ef                   lda expr_result+3
  4847  3f59 e900                   sbc #0
  4848  3f5b 85ef                   sta expr_result+3
  4849  3f5d 83bbff                 lbra @count_loop
  4850                          
  4851                          @finish_count_loop
  4852  3f60 4242a5e8               ldq expr_b
  4853  3f64 424285ec               stq expr_result
  4854  3f68 8379ff                 lbra @shift_loop
  4855                          
  4856                          @ok
  4857  3f6b 18                     clc
  4858                          @end
  4859  3f6c 60                     rts
  4860                          
  4861                          
  4862                          ; bytesel   ::= (< > ^ ^^)? shift
  4863                          expect_bytesel:
  4864  3f6d a9a8                   lda #tk_lt
  4865  3f6f 20633a                 jsr expect_token
  4866  3f72 901b                   bcc +
  4867  3f74 a9a9                   lda #tk_gt
  4868  3f76 20633a                 jsr expect_token
  4869  3f79 9014                   bcc +
  4870  3f7b a9a2                   lda #tk_power
  4871  3f7d 20633a                 jsr expect_token
  4872  3f80 900d                   bcc +
  4873  3f82 a9a1                   lda #tk_megabyte
  4874  3f84 20633a                 jsr expect_token
  4875  3f87 9006                   bcc +
  4876  3f89 20dd3e                 jsr expect_shift  ; Passthru
  4877  3f8c 832700                 lbra @end
  4878                          
  4879  3f8f 48                 +   pha
  4880  3f90 20dd3e                 jsr expect_shift
  4881  3f93 68                     pla
  4882  3f94 b31f00                 lbcs @end  ; Operator but no term, fail
  4883  3f97 a200                   ldx #0
  4884  3f99 c9a8                   cmp #tk_lt
  4885  3f9b f00b                   beq +++
  4886  3f9d c9a9                   cmp #tk_gt
  4887  3f9f f006                   beq ++
  4888  3fa1 c9a2                   cmp #tk_power
  4889  3fa3 f001                   beq +
  4890  3fa5 e8                     inx  ; tk_megabyte
  4891  3fa6 e8                 +   inx
  4892  3fa7 e8                 ++  inx
  4893  3fa8 b5ec               +++ lda expr_result,x
  4894  3faa 85ec                   sta expr_result
  4895  3fac a900                   lda #0
  4896  3fae 85ed                   sta expr_result+1
  4897  3fb0 85ee                   sta expr_result+2
  4898  3fb2 85ef                   sta expr_result+3
  4899                          
  4900                          @ok
  4901  3fb4 18                     clc
  4902                          @end
  4903  3fb5 60                     rts
  4904                          
  4905                          
  4906                          ; expr      ::= bytesel ((& XOR |) bytesel)*
  4907                          expect_expr:
  4908  3fb6 206d3f                 jsr expect_bytesel
  4909  3fb9 b3a000                 lbcs @end
  4910                          
  4911                          @bitop_loop
  4912  3fbc a9aa                   lda #tk_ampersand
  4913  3fbe 20633a                 jsr expect_token
  4914  3fc1 9019                   bcc +
  4915  3fc3 a9ab                   lda #tk_pipe
  4916  3fc5 20633a                 jsr expect_token
  4917  3fc8 9012                   bcc +
  4918  3fca a9b5                   lda #tk_pipe2
  4919  3fcc 20633a                 jsr expect_token
  4920  3fcf 900b                   bcc +
  4921  3fd1 a900                   lda #0
  4922  3fd3 a239                   ldx #<kw_xor
  4923  3fd5 a052                   ldy #>kw_xor
  4924  3fd7 20cf3a                 jsr expect_keyword
  4925  3fda b07e                   bcs @ok
  4926                          
  4927  3fdc 48                 +   pha
  4928  3fdd a5ec48a5ed48a5ee...    +push32 expr_result
  4929  3fe9 206d3f                 jsr expect_bytesel
  4930  3fec 6885eb6885ea6885...    +pull32 expr_b
  4931  3ff8 68                     pla
  4932  3ff9 b36000                 lbcs @end  ; Operator but no term, fail
  4933                          
  4934  3ffc 4b                     taz
  4935                              ; Z = tk_ampersand, tk_pipe, or 0 for XOR
  4936                              ; expr_result = expr_b <op> expr_result
  4937  3ffd c2aa                   cpz #tk_ampersand
  4938  3fff d01b                   bne +
  4939                              ; expr_b & expr_result
  4940  4001 a5e8                   lda expr_b
  4941  4003 25ec                   and expr_result
  4942  4005 85ec                   sta expr_result
  4943  4007 a5e9                   lda expr_b+1
  4944  4009 25ed                   and expr_result+1
  4945  400b 85ed                   sta expr_result+1
  4946  400d a5ea                   lda expr_b+2
  4947  400f 25ee                   and expr_result+2
  4948  4011 85ee                   sta expr_result+2
  4949  4013 a5eb                   lda expr_b+3
  4950  4015 25ef                   and expr_result+3
  4951  4017 85ef                   sta expr_result+3
  4952  4019 83a1ff                 lbra @bitop_loop
  4953                          
  4954  401c c2ab               +   cpz #tk_pipe
  4955  401e f004                   beq +
  4956  4020 c2b5                   cpz #tk_pipe2
  4957  4022 d01b                   bne ++
  4958                              ; expr_b | expr_result
  4959  4024 a5e8               +   lda expr_b
  4960  4026 05ec                   ora expr_result
  4961  4028 85ec                   sta expr_result
  4962  402a a5e9                   lda expr_b+1
  4963  402c 05ed                   ora expr_result+1
  4964  402e 85ed                   sta expr_result+1
  4965  4030 a5ea                   lda expr_b+2
  4966  4032 05ee                   ora expr_result+2
  4967  4034 85ee                   sta expr_result+2
  4968  4036 a5eb                   lda expr_b+3
  4969  4038 05ef                   ora expr_result+3
  4970  403a 85ef                   sta expr_result+3
  4971  403c 837eff                 lbra @bitop_loop
  4972                          
  4973                          ++  ; expr_b XOR expr_result
  4974  403f a5e8                   lda expr_b
  4975  4041 45ec                   eor expr_result
  4976  4043 85ec                   sta expr_result
  4977  4045 a5e9                   lda expr_b+1
  4978  4047 45ed                   eor expr_result+1
  4979  4049 85ed                   sta expr_result+1
  4980  404b a5ea                   lda expr_b+2
  4981  404d 45ee                   eor expr_result+2
  4982  404f 85ee                   sta expr_result+2
  4983  4051 a5eb                   lda expr_b+3
  4984  4053 45ef                   eor expr_result+3
  4985  4055 85ef                   sta expr_result+3
  4986  4057 8363ff                 lbra @bitop_loop
  4987                          
  4988                          @ok
  4989  405a 18                     clc
  4990                          @end
  4991  405b 60                     rts
  4992                          
  4993                          
  4994                          ; ------------------------------------------------------------
  4995                          ; PC assignment
  4996                          ; ------------------------------------------------------------
  4997                          
  4998                          ; Input: tokbuf, tok_pos
  4999                          ; Output:
  5000                          ;   C=0 success, PC updated, tok_pos advanced
  5001                          ;   C=1 fail
  5002                          ;     err_code=0 not a PC assign statement, tok_pos not advanced
  5003                          ;     err_code>0 fatal error with line_pos set
  5004                          assemble_pc_assign:
  5005                              ; "*" "=" expr
  5006  405c a9a3                   lda #tk_multiply
  5007  405e 20633a                 jsr expect_token
  5008  4061 b3af0a                 lbcs statement_err_exit
  5009  4064 a9af                   lda #tk_equal
  5010  4066 20633a                 jsr expect_token
  5011  4069 b3a70a                 lbcs statement_err_exit
  5012  406c a6f1                   ldx tok_pos
  5013  406e bd017e                 lda tokbuf+1,x  ; expr line_pos
  5014  4071 48                     pha
  5015  4072 a900                   lda #0
  5016  4074 85f0                   sta expr_flags
  5017  4076 20b63f                 jsr expect_expr
  5018  4079 fb                     plz             ; Z = expr line_pos
  5019  407a b3960a                 lbcs statement_err_exit
  5020                          
  5021  407d a5f0                   lda expr_flags
  5022  407f 2908                   and #F_EXPR_UNDEFINED
  5023  4081 f009                   beq +
  5024                              ; PC expression must be defined in first pass
  5025  4083 64f2                   stz line_pos
  5026  4085 a902                   lda #err_pc_undef
  5027  4087 85f3                   sta err_code
  5028  4089 83870a                 lbra statement_err_exit
  5029                          
  5030                          +   ; Value must be in address range
  5031  408c a5ee                   lda expr_result+2
  5032  408e 05ef                   ora expr_result+3
  5033  4090 f009                   beq +
  5034  4092 64f2                   stz line_pos
  5035  4094 a903                   lda #err_value_out_of_range
  5036  4096 85f3                   sta err_code
  5037  4098 83780a                 lbra statement_err_exit
  5038                          
  5039                          +   ; Set PC
  5040  409b a6ec                   ldx expr_result
  5041  409d a4ed                   ldy expr_result+1
  5042  409f 20b035                 jsr set_pc
  5043  40a2 83740a                 lbra statement_ok_exit
  5044                          
  5045                          
  5046                          ; ------------------------------------------------------------
  5047                          ; Label assignment
  5048                          ; ------------------------------------------------------------
  5049                          
  5050                          ; Input: line_addr, X=label_pos
  5051                          ; Output:
  5052                          ;   X=0 global
  5053                          ;   X=1 cheap local
  5054                          ;   X=2 relative +
  5055                          ;   X=3 relative -
  5056                          lbl_global = 0
  5057                          lbl_cheaplocal = 1
  5058                          lbl_relplus = 2
  5059                          lbl_relminus = 3
  5060                          determine_label_type:
  5061  40a5 a5f4                   lda line_addr
  5062  40a7 85fc                   sta bas_ptr
  5063  40a9 a5f5                   lda line_addr+1
  5064  40ab 85fd                   sta bas_ptr+1
  5065  40ad 8a                     txa  ; label pos
  5066  40ae 4b                     taz
  5067  40af eab2fc                 lda [bas_ptr],z
  5068  40b2 c940                   cmp #'@'
  5069  40b4 d003                   bne +
  5070  40b6 a201                   ldx #lbl_cheaplocal
  5071  40b8 60                     rts
  5072  40b9 c92b               +   cmp #'+'
  5073  40bb d003                   bne +
  5074  40bd a202                   ldx #lbl_relplus
  5075  40bf 60                     rts
  5076  40c0 c92d               +   cmp #'-'
  5077  40c2 d003                   bne +
  5078  40c4 a203                   ldx #lbl_relminus
  5079  40c6 60                     rts
  5080  40c7 a200               +   ldx #lbl_global
  5081  40c9 60                     rts
  5082                          
  5083                          
  5084                          ; Input: line_addr, X=label line pos, Y=label length
  5085                          ; Output:
  5086                          ; - C=0 found or added, attic_ptr=entry address
  5087                          ; - C=1 out of memory error
  5088                          ; Uses strbuf, expr_a.
  5089                          find_or_add_label:
  5090  40ca da                     phx
  5091  40cb 5a                     phy
  5092                          
  5093                              ; Detect cheap local, rewrite name
  5094                              ; (X=label pos)
  5095  40cc 20a540                 jsr determine_label_type
  5096  40cf e001                   cpx #lbl_cheaplocal
  5097  40d1 d03d                   bne ++
  5098  40d3 a200                   ldx #0  ; strbuf position
  5099                              ; Copy last-seen global name to strbuf
  5100  40d5 a5d3                   lda last_pc_defined_global_label
  5101  40d7 05d4                   ora last_pc_defined_global_label+1
  5102  40d9 f037                   beq +++  ; Never seen a global, no cheap local prefix
  5103  40db a5d3                   lda last_pc_defined_global_label
  5104  40dd 85f8                   sta attic_ptr
  5105  40df a5d4                   lda last_pc_defined_global_label+1
  5106  40e1 85f9                   sta attic_ptr+1
  5107  40e3 a971                   lda #^attic_symbol_table
  5108  40e5 85fa                   sta attic_ptr+2
  5109  40e7 a908                   lda #$08
  5110  40e9 85fb                   sta attic_ptr+3
  5111  40eb 85e7                   sta expr_a+3
  5112  40ed a300                   ldz #0
  5113  40ef eab2f8                 lda [attic_ptr],z
  5114  40f2 85e4                   sta expr_a
  5115  40f4 1b                     inz
  5116  40f5 eab2f8                 lda [attic_ptr],z
  5117  40f8 85e5                   sta expr_a+1
  5118  40fa 1b                     inz
  5119  40fb eab2f8                 lda [attic_ptr],z
  5120  40fe 85e6                   sta expr_a+2       ; expr_a = name of last seen global
  5121  4100 a200                   ldx #0
  5122  4102 a300                   ldz #0             ; Copy global name to strbuf
  5123  4104 eab2e4             -   lda [expr_a],z
  5124  4107 f009                   beq +++
  5125  4109 9d007f                 sta strbuf,x
  5126  410c e8                     inx
  5127  410d 1b                     inz
  5128  410e 80f4                   bra -
  5129                          
  5130  4110 a200               ++  ldx #0  ; strbuf position
  5131                          +++
  5132                          
  5133                              ; Copy label text to strbuf.
  5134  4112 7a                     ply  ; Y = length
  5135  4113 fb                     plz  ; Z = line pos
  5136  4114 a5f4                   lda line_addr
  5137  4116 85fc                   sta bas_ptr
  5138  4118 a5f5                   lda line_addr+1
  5139  411a 85fd                   sta bas_ptr+1
  5140                              ; X is current strbuf position, from above
  5141  411c eab2fc             -   lda [bas_ptr],z
  5142  411f 9d007f                 sta strbuf,x
  5143  4122 e8                     inx
  5144  4123 1b                     inz
  5145  4124 88                     dey
  5146  4125 d0f5                   bne -
  5147                          
  5148  4127 a900                   lda #<strbuf
  5149  4129 85fc                   sta bas_ptr
  5150  412b a97f                   lda #>strbuf
  5151  412d 85fd                   sta bas_ptr+1
  5152  412f a5fe                   lda bas_ptr+2
  5153  4131 48                     pha
  5154  4132 a905                   lda #5
  5155  4134 85fe                   sta bas_ptr+2
  5156                              ; X = new length (text added to strbuf)
  5157  4136 208034                 jsr find_or_add_symbol
  5158  4139 68                     pla
  5159  413a 85fe                   sta bas_ptr+2  ; Important! reset bas_ptr bank to 0
  5160  413c 60                     rts
  5161                          
  5162                          
  5163                          ; Input: tokbuf, tok_pos
  5164                          ; Output:
  5165                          ;   C=0 success; label assigned, tok_pos advanced
  5166                          ;     Z = 0: was equal-assign, end statement
  5167                          ;     Z = 1: was PC assign, accept instruction or directive
  5168                          ;   C=1 fail
  5169                          ;     err_code=0 not a pc assign statement, tok_pos not advanced
  5170                          ;     err_code>0 fatal error with line_pos set
  5171                          assemble_label:
  5172                          
  5173  413d 20733a                 jsr expect_pluses_or_minuses
  5174  4140 93ce00                 lbcc @relative_label
  5175                          
  5176                              ; <label> ["=" expr]
  5177  4143 20b53a                 jsr expect_label
  5178  4146 b3ca09                 lbcs statement_err_exit
  5179  4149 86c5                   stx label_pos      ; line_pos
  5180  414b 84c6                   sty label_length   ; length
  5181  414d a9af                   lda #tk_equal
  5182  414f 20633a                 jsr expect_token
  5183  4152 b38200                 lbcs @label_without_equal
  5184  4155 a900                   lda #0
  5185  4157 85f0                   sta expr_flags
  5186  4159 20b63f                 jsr expect_expr
  5187  415c 933e00                 lbcc @label_with_equal
  5188  415f a5f3                   lda err_code
  5189  4161 d3af09                 lbne statement_err_exit
  5190  4164 a5c5                   lda label_pos
  5191  4166 85f2                   sta line_pos
  5192  4168 a901                   lda #err_syntax  ; expr required after "="
  5193  416a 85f3                   sta err_code
  5194  416c 83a409                 lbra statement_err_exit
  5195                          
  5196                          ; (This is jsr'd.)
  5197                          @find_or_add_symbol_to_define:
  5198  416f a6c5                   ldx label_pos
  5199  4171 a4c6                   ldy label_length
  5200  4173 20ca40                 jsr find_or_add_label
  5201  4176 9009                   bcc +
  5202  4178 a906                   lda #err_out_of_memory
  5203  417a 85f3                   sta err_code
  5204  417c 68                     pla  ; pop caller address, go straight to exit
  5205  417d 68                     pla
  5206  417e 839209                 lbra statement_err_exit
  5207                          +
  5208  4181 a303                   ldz #3           ; Error if symbol is already defined in first pass
  5209  4183 eab2f8                 lda [attic_ptr],z
  5210  4186 2901                   and #F_SYMTBL_DEFINED
  5211  4188 f011                   beq +
  5212  418a 24b6                   bit pass
  5213  418c 300d                   bmi +
  5214  418e a5c5                   lda label_pos
  5215  4190 85f2                   sta line_pos
  5216  4192 a905                   lda #err_already_defined
  5217  4194 85f3                   sta err_code
  5218  4196 68                     pla  ; pop caller address, go straight to exit
  5219  4197 68                     pla
  5220  4198 837809                 lbra statement_err_exit
  5221  419b 60                 +   rts
  5222                          
  5223                          @label_with_equal:
  5224                              ; Only global-type labels can be assigned with =
  5225  419c a6c5                   ldx label_pos
  5226  419e 20a540                 jsr determine_label_type
  5227  41a1 e000                   cpx #lbl_global
  5228  41a3 f007                   beq +
  5229  41a5 a909                   lda #err_label_assign_global_only
  5230  41a7 85f3                   sta err_code
  5231  41a9 836709                 lbra statement_err_exit
  5232                          +
  5233                          
  5234                              ; Set label to expr, possibly undefined
  5235  41ac 206f41                 jsr @find_or_add_symbol_to_define
  5236  41af a5f0                   lda expr_flags
  5237  41b1 2908                   and #F_EXPR_UNDEFINED
  5238  41b3 f005                   beq +
  5239  41b5 a300                   ldz #0  ; Return value
  5240  41b7 835f09                 lbra statement_ok_exit  ; label expr is undefined; leave symbol undefined
  5241                          +
  5242                              ; label expr is defined, use value; propagate zero flag
  5243  41ba 4242a5ec               ldq expr_result
  5244  41be 204135                 jsr set_symbol_value
  5245  41c1 a5f0                   lda expr_flags
  5246  41c3 2904                   and #F_EXPR_FORCE16
  5247  41c5 f00a                   beq +
  5248  41c7 a303                   ldz #3
  5249  41c9 eab2f8                 lda [attic_ptr],z
  5250  41cc 0902                   ora #F_SYMTBL_LEADZERO
  5251  41ce ea92f8                 sta [attic_ptr],z
  5252  41d1 a300               +   ldz #0  ; Return value
  5253  41d3 834309                 lbra statement_ok_exit
  5254                          
  5255                          @label_without_equal
  5256                              ; Label without "=", set label to PC
  5257  41d6 206f41                 jsr @find_or_add_symbol_to_define
  5258                              ; PC undefined is an error
  5259  41d9 20a235                 jsr get_pc
  5260  41dc 900b                   bcc +
  5261  41de a5c5                   lda label_pos
  5262  41e0 85f2                   sta line_pos
  5263  41e2 a902                   lda #err_pc_undef
  5264  41e4 85f3                   sta err_code
  5265  41e6 832a09                 lbra statement_err_exit
  5266                          +   ; Move X/Y (from get_pc) to Q
  5267  41e9 86ec                   stx expr_result
  5268  41eb 84ed                   sty expr_result+1
  5269  41ed a900                   lda #0
  5270  41ef 85ee                   sta expr_result+2
  5271  41f1 85ef                   sta expr_result+3
  5272  41f3 4242a5ec               ldq expr_result
  5273  41f7 204135                 jsr set_symbol_value
  5274                          
  5275                              ; Remember last seen PC-assigned global label
  5276  41fa a6c5                   ldx label_pos
  5277  41fc 20a540                 jsr determine_label_type
  5278  41ff e000                   cpx #lbl_global
  5279  4201 d008                   bne +
  5280  4203 a5f8                   lda attic_ptr
  5281  4205 85d3                   sta last_pc_defined_global_label
  5282  4207 a5f9                   lda attic_ptr+1
  5283  4209 85d4                   sta last_pc_defined_global_label+1
  5284                          +
  5285                          
  5286  420b a301                   ldz #1  ; Return value
  5287  420d 830909                 lbra statement_ok_exit
  5288                          
  5289                          @relative_label
  5290                              ; Only add to rellabel table during first pass.
  5291                              ; (If we go multi-pass, this needs to be reconsidered.)
  5292  4210 24b6                   bit pass
  5293  4212 3026                   bmi +++
  5294                          
  5295                              ; A=tk_pluses or tk_minuses, Y=length
  5296  4214 85e4                   sta expr_a
  5297  4216 84e5                   sty expr_a+1
  5298                          
  5299                              ; PC undefined is an error
  5300  4218 20a235                 jsr get_pc
  5301  421b 900e                   bcc +
  5302  421d a6f1                   ldx tok_pos
  5303  421f bdfe7d                 lda tokbuf-2,x
  5304  4222 85f2                   sta line_pos
  5305  4224 a902                   lda #err_pc_undef
  5306  4226 85f3                   sta err_code
  5307  4228 83e808                 lbra statement_err_exit
  5308                          +
  5309  422b a5e4                   lda expr_a
  5310  422d c9ba                   cmp #tk_pluses
  5311  422f d003                   bne +
  5312  4231 18                     clc      ; C=0: plus
  5313  4232 8001                   bra ++
  5314  4234 38                 +   sec      ; C=1: minus
  5315  4235 a5e5               ++  lda expr_a+1  ; A = len
  5316                              ; X/Y = PC (from get_pc)
  5317  4237 206f39                 jsr add_rellabel
  5318                          
  5319                          +++
  5320  423a a301                   ldz #1  ; Return value
  5321  423c 83da08                 lbra statement_ok_exit
  5322                          
  5323                          
  5324                          ; ------------------------------------------------------------
  5325                          ; Instructions
  5326                          ; ------------------------------------------------------------
  5327                          
  5328                          ; Input: expr_result, expr_flags
  5329                          ; Output: C=1 if expr is > 256 or is forced to 16-bit with leading zero
  5330                          ;   Also honors F_ASM_FORCE8/16 assembly flags.
  5331                          is_expr_16bit:
  5332  423f a5b9                   lda asm_flags
  5333  4241 2906                   and #F_ASM_FORCE_MASK
  5334  4243 c904                   cmp #F_ASM_FORCE16
  5335  4245 f014                   beq @yes_16
  5336  4247 c902                   cmp #F_ASM_FORCE8
  5337  4249 f00e                   beq @no_16
  5338  424b a5f0                   lda expr_flags
  5339  424d 2904                   and #F_EXPR_FORCE16
  5340  424f d00a                   bne @yes_16
  5341  4251 a5ed                   lda expr_result+1
  5342  4253 05ee                   ora expr_result+2
  5343  4255 05ef                   ora expr_result+3
  5344  4257 d002                   bne @yes_16
  5345                          @no_16
  5346  4259 18                     clc
  5347  425a 60                     rts
  5348                          @yes_16
  5349  425b 38                     sec
  5350  425c 60                     rts
  5351                          
  5352                          
  5353                          !macro expect_addresing_expr_rts .mode {
  5354                              ldx #<.mode
  5355                              ldy #>.mode
  5356                              clc
  5357                              rts
  5358                          }
  5359                          
  5360                          
  5361                          force16_if_expr_undefined:
  5362  425d a5b9                   lda asm_flags
  5363  425f 2906                   and #F_ASM_FORCE_MASK
  5364  4261 d011                   bne +  ; Undefined doesn't override other forces
  5365  4263 a5f0                   lda expr_flags
  5366  4265 2908                   and #F_EXPR_UNDEFINED
  5367  4267 f00b                   beq +
  5368  4269 20f638                 jsr add_forced16
  5369  426c a5b9                   lda asm_flags
  5370  426e 29f9                   and #!F_ASM_FORCE_MASK
  5371  4270 0904                   ora #F_ASM_FORCE16
  5372  4272 85b9                   sta asm_flags
  5373  4274 60                 +   rts
  5374                          
  5375                          
  5376                          ; Input: expr_result, program_counter
  5377                          ; Output:
  5378                          ;   expr_result = expr_result - (program_counter + 2)
  5379                          make_operand_rel:
  5380  4275 a5f0                   lda expr_flags
  5381  4277 2908                   and #F_EXPR_UNDEFINED
  5382  4279 f001                   beq +
  5383  427b 60                     rts
  5384                          +
  5385  427c a5b7                   lda program_counter
  5386  427e 18                     clc
  5387  427f 6902                   adc #2
  5388  4281 a8                     tay
  5389  4282 a5b8                   lda program_counter+1
  5390  4284 6900                   adc #0
  5391  4286 aa                     tax
  5392  4287 98                     tya
  5393  4288 a000                   ldy #0
  5394  428a a300                   ldz #0
  5395  428c 424285e4               stq expr_a  ; expr_a = program_counter + 2
  5396  4290 4242a5ec               ldq expr_result
  5397  4294 38                     sec
  5398  4295 4242e5e4               sbcq expr_a
  5399  4299 424285ec               stq expr_result  ; expr_result = expr_result - expr_a
  5400  429d 60                     rts
  5401                          
  5402                          
  5403                          ; Input: tokbuf, tok_pos, asm_flags
  5404                          ; Output:
  5405                          ;   C=0 ok, X/Y=addr mode flags (LSB/MSB), expr_result, expr_flags, tok_pos advanced
  5406                          ;   C=1 fail
  5407                          ;     err_code>0 fatal error with line_pos set
  5408                          expect_addressing_expr:
  5409  429e a900                   lda #0
  5410  42a0 85ec                   sta expr_result
  5411  42a2 85ed                   sta expr_result+1
  5412  42a4 85ee                   sta expr_result+2
  5413  42a6 85ef                   sta expr_result+3
  5414  42a8 85f0                   sta expr_flags
  5415  42aa 85f3                   sta err_code
  5416                          
  5417                              ; ":" or end of line: Implicit
  5418  42ac a6f1                   ldx tok_pos
  5419  42ae bd007e                 lda tokbuf,x
  5420  42b1 f006                   beq +
  5421  42b3 c9ae                   cmp #tk_colon
  5422  42b5 f002                   beq +
  5423  42b7 8006                   bra @try_immediate
  5424  42b9 a200a0801860       +   +expect_addresing_expr_rts MODE_IMPLIED
  5425                          
  5426                          @try_immediate
  5427                              ; "#" <expr>: Immediate
  5428  42bf a9ad                   lda #tk_hash
  5429  42c1 20633a                 jsr expect_token
  5430  42c4 b00c                   bcs @try_modes_with_leading_expr
  5431  42c6 20b63f                 jsr expect_expr
  5432  42c9 b3ca01                 lbcs @addr_error
  5433                              ; Caller will coerce type to MODE_IMMEDIATE_WORD as needed.
  5434  42cc a200a0401860           +expect_addresing_expr_rts MODE_IMMEDIATE
  5435                          
  5436                          @try_modes_with_leading_expr
  5437                              ; Check if the current PC is on the "forced16" list.
  5438  42d2 a5b9                   lda asm_flags
  5439  42d4 2904                   and #F_ASM_FORCE16
  5440  42d6 d00d                   bne +  ; skip if already forced
  5441  42d8 20af38                 jsr find_forced16
  5442  42db 9008                   bcc +
  5443  42dd a5b9                   lda asm_flags
  5444  42df 29f9                   and #!F_ASM_FORCE_MASK
  5445  42e1 0904                   ora #F_ASM_FORCE16
  5446  42e3 85b9                   sta asm_flags
  5447                          +
  5448                          
  5449                              ; Make the operand a relative address for branch instructions.
  5450                              ; (Leave it to assemble_instruction to range check.)
  5451  42e5 20b63f                 jsr expect_expr
  5452  42e8 b33601                 lbcs @try_modes_without_leading_expr
  5453  42eb a5b9                   lda asm_flags
  5454  42ed 2908                   and #F_ASM_AREL8
  5455  42ef f00d                   beq +
  5456  42f1 a5b9                   lda asm_flags   ; force16 for long branches
  5457  42f3 29e7                   and #!F_ASM_AREL_MASK
  5458  42f5 0902                   ora #F_ASM_FORCE8
  5459  42f7 85b9                   sta asm_flags
  5460  42f9 207542                 jsr make_operand_rel
  5461  42fc 8011                   bra ++
  5462  42fe a5b9               +   lda asm_flags
  5463  4300 2910                   and #F_ASM_AREL16
  5464  4302 f00b                   beq ++
  5465  4304 a5b9                   lda asm_flags   ; force16 for long branches
  5466  4306 29f9                   and #!F_ASM_FORCE_MASK
  5467  4308 0904                   ora #F_ASM_FORCE16
  5468  430a 85b9                   sta asm_flags
  5469  430c 207542                 jsr make_operand_rel
  5470                          ++
  5471                          
  5472  430f 205d42                 jsr force16_if_expr_undefined
  5473                              ; Addressing modes that start with expressions:
  5474  4312 a5f0                   lda expr_flags
  5475  4314 2903                   and #F_EXPR_BRACKET_MASK
  5476  4316 c900                   cmp #F_EXPR_BRACKET_NONE
  5477  4318 d39700                 lbne +++
  5478                              ; - Non-brackets:
  5479  431b 203f42                 jsr is_expr_16bit
  5480  431e b063                   bcs ++
  5481                              ;    <expr-8> ["," ("x" | "y")]
  5482  4320 a9ac                   lda #tk_comma
  5483  4322 20633a                 jsr expect_token
  5484  4325 9006                   bcc +
  5485  4327 a200a0101860           +expect_addresing_expr_rts MODE_BASE_PAGE
  5486  432d a22c               +   ldx #<kw_x
  5487  432f a052                   ldy #>kw_x
  5488  4331 20cf3a                 jsr expect_keyword
  5489  4334 b006                   bcs +
  5490  4336 a200a0081860           +expect_addresing_expr_rts MODE_BASE_PAGE_X
  5491  433c a22e               +   ldx #<kw_y
  5492  433e a052                   ldy #>kw_y
  5493  4340 20cf3a                 jsr expect_keyword
  5494  4343 b006                   bcs +
  5495  4345 a200a0041860           +expect_addresing_expr_rts MODE_BASE_PAGE_Y
  5496  434b a5b9               +   lda asm_flags
  5497  434d 2920                   and #F_ASM_BITBRANCH
  5498  434f f02f                   beq +
  5499  4351 4242a5ec               ldq expr_result
  5500  4355 424285e8               stq expr_b
  5501  4359 20b63f                 jsr expect_expr
  5502  435c b022                   bcs +
  5503                              ; <expr-8> "," <expr> (for bit branches)
  5504                              ; expr_b = ZP, expr_result = Rel
  5505  435e 207542                 jsr make_operand_rel
  5506                              ; Account for bit-branch instructions having a two-wide operand:
  5507                              ;   expr_result = expr_result - 1
  5508  4361 a5ec                   lda expr_result
  5509  4363 38                     sec
  5510  4364 e901                   sbc #1
  5511  4366 85ec                   sta expr_result
  5512  4368 a5ed                   lda expr_result+1
  5513  436a e900                   sbc #0
  5514  436c 85ed                   sta expr_result+1
  5515  436e a5ee                   lda expr_result+2
  5516  4370 e900                   sbc #0
  5517  4372 85ee                   sta expr_result+2
  5518  4374 a5ef                   lda expr_result+3
  5519  4376 e900                   sbc #0
  5520  4378 85ef                   sta expr_result+3
  5521  437a a200a0101860           +expect_addresing_expr_rts MODE_BASE_PAGE
  5522                          +   ; Syntax error: <expr-8> "," non-x/y
  5523  4380 831301                 lbra @addr_error
  5524                          
  5525                          ++  ; <expr-16> ["," ("x" | "y")]
  5526  4383 a9ac                   lda #tk_comma
  5527  4385 20633a                 jsr expect_token
  5528  4388 9006                   bcc +
  5529  438a a200a0021860           +expect_addresing_expr_rts MODE_ABSOLUTE
  5530  4390 a22c               +   ldx #<kw_x
  5531  4392 a052                   ldy #>kw_x
  5532  4394 20cf3a                 jsr expect_keyword
  5533  4397 b006                   bcs +
  5534  4399 a200a0011860           +expect_addresing_expr_rts MODE_ABSOLUTE_X
  5535  439f a22e               +   ldx #<kw_y
  5536  43a1 a052                   ldy #>kw_y
  5537  43a3 20cf3a                 jsr expect_keyword
  5538  43a6 b006                   bcs +
  5539  43a8 a280a0001860           +expect_addresing_expr_rts MODE_ABSOLUTE_Y
  5540                          +   ; Syntax error: <expr-16> "," non-x/y
  5541  43ae 83e500                 lbra @addr_error
  5542                          
  5543  43b1 c901               +++ cmp #F_EXPR_BRACKET_PAREN
  5544  43b3 d039                   bne +++
  5545                              ; - Parens:
  5546  43b5 203f42                 jsr is_expr_16bit
  5547  43b8 b02e                   bcs ++
  5548                              ; "(" <expr-8> ")" ["," ("y" | "z")]
  5549  43ba a9ac                   lda #tk_comma
  5550  43bc 20633a                 jsr expect_token
  5551  43bf 9006                   bcc +
  5552                              ; (Base page indirect no register implies "Z".)
  5553  43c1 a204a0001860           +expect_addresing_expr_rts MODE_BASE_PAGE_IND_Z
  5554  43c7 a22e               +   ldx #<kw_y
  5555  43c9 a052                   ldy #>kw_y
  5556  43cb 20cf3a                 jsr expect_keyword
  5557  43ce b006                   bcs +
  5558  43d0 a208a0001860           +expect_addresing_expr_rts MODE_BASE_PAGE_IND_Y
  5559  43d6 a230               +   ldx #<kw_z
  5560  43d8 a052                   ldy #>kw_z
  5561  43da 20cf3a                 jsr expect_keyword
  5562  43dd b006                   bcs +
  5563  43df a204a0001860           +expect_addresing_expr_rts MODE_BASE_PAGE_IND_Z
  5564                          +   ; Syntax error: "(" <expr-8> ")" "," non-y/z
  5565  43e5 83ae00                 lbra @addr_error
  5566                          
  5567                          ++  ; "(" <expr-16> ")"
  5568  43e8 a240a0001860           +expect_addresing_expr_rts MODE_ABSOLUTE_IND
  5569                          
  5570                          +++ ; - Brackets:
  5571                              ;    "[" <expr-8> "]" ["," "z"]
  5572  43ee 203f42                 jsr is_expr_16bit
  5573  43f1 9014                   bcc +
  5574                              ; Error: Argument out of range
  5575  43f3 a5f1                   lda tok_pos  ; position error at beginning of expression
  5576  43f5 38                     sec
  5577  43f6 e908                   sbc #8
  5578  43f8 85f1                   sta tok_pos
  5579  43fa aa                     tax
  5580  43fb bd017e                 lda tokbuf+1,x
  5581  43fe 85f2                   sta line_pos
  5582  4400 a903                   lda #err_value_out_of_range
  5583  4402 85f3                   sta err_code
  5584  4404 838f00                 lbra @addr_error
  5585                          
  5586  4407 a9ac               +   lda #tk_comma
  5587  4409 20633a                 jsr expect_token
  5588  440c b00c                   bcs +  ; ,z is optional
  5589  440e a230                   ldx #<kw_z
  5590  4410 a052                   ldy #>kw_z
  5591  4412 20cf3a                 jsr expect_keyword
  5592  4415 9003                   bcc +  ; z is required if , is provided
  5593                              ; Syntax error: "[" <expr-8> "]" "," non-z
  5594  4417 837c00                 lbra @addr_error
  5595  441a a202a0001860       +   +expect_addresing_expr_rts MODE_32BIT_IND
  5596                          
  5597                          @try_modes_without_leading_expr
  5598                              ; Addressing modes that don't start with expressions:
  5599  4420 a9b0                   lda #tk_lparen
  5600  4422 20633a                 jsr expect_token
  5601  4425 9003                   bcc +
  5602  4427 836c00                 lbra @addr_error
  5603  442a 20b63f             +   jsr expect_expr
  5604  442d 9003                   bcc +
  5605  442f 836400                 lbra @addr_error
  5606  4432 205d42             +   jsr force16_if_expr_undefined
  5607  4435 a9ac                   lda #tk_comma
  5608  4437 20633a                 jsr expect_token
  5609  443a 9003                   bcc +
  5610  443c 835700                 lbra @addr_error
  5611  443f a232               +   ldx #<kw_sp
  5612  4441 a052                   ldy #>kw_sp
  5613  4443 20cf3a                 jsr expect_keyword
  5614  4446 9027                   bcc +++
  5615                              ; (<expr-8>,x)
  5616                              ; (<expr-16>,x)
  5617  4448 a22c                   ldx #<kw_x
  5618  444a a052                   ldy #>kw_x
  5619  444c 20cf3a                 jsr expect_keyword
  5620  444f 9003                   bcc +
  5621  4451 834200                 lbra @addr_error
  5622  4454 a9b1               +   lda #tk_rparen
  5623  4456 20633a                 jsr expect_token
  5624  4459 9003                   bcc +
  5625  445b 833800                 lbra @addr_error
  5626  445e 203f42             +   jsr is_expr_16bit
  5627  4461 b006                   bcs +
  5628  4463 a210a0001860           +expect_addresing_expr_rts MODE_BASE_PAGE_IND_X
  5629  4469 a220a0001860       +   +expect_addresing_expr_rts MODE_ABSOLUTE_IND_X
  5630                          
  5631                          +++ ; (<expr>,sp),y
  5632  446f a9b1                   lda #tk_rparen
  5633  4471 20633a                 jsr expect_token
  5634  4474 9003                   bcc +
  5635  4476 831d00                 lbra @addr_error
  5636  4479 a9ac               +   lda #tk_comma
  5637  447b 20633a                 jsr expect_token
  5638  447e 9003                   bcc +
  5639  4480 831300                 lbra @addr_error
  5640  4483 a22e               +   ldx #<kw_y
  5641  4485 a052                   ldy #>kw_y
  5642  4487 20cf3a                 jsr expect_keyword
  5643  448a 9003                   bcc +
  5644  448c 830700                 lbra @addr_error
  5645  448f a201a0001860       +   +expect_addresing_expr_rts MODE_STACK_REL
  5646                          
  5647                          @addr_error
  5648  4495 a5f3                   lda err_code
  5649  4497 d00b                   bne +
  5650  4499 a901                   lda #err_syntax
  5651  449b 85f3                   sta err_code
  5652  449d a6f1                   ldx tok_pos
  5653  449f bd017e                 lda tokbuf+1,x
  5654  44a2 85f2                   sta line_pos
  5655  44a4 38                 +   sec
  5656  44a5 60                     rts
  5657                          
  5658                          
  5659                          ; Input: A=mnemonic ID
  5660                          ; Output: C=1 yes is branch
  5661                          is_bitbranch_mnemonic:
  5662                              ; Relies on bbr0 to bbs7 being alphabetically consecutive
  5663  44a6 c90a                   cmp #mnemonic_bbr0
  5664  44a8 9008                   bcc ++
  5665  44aa c91a                   cmp #mnemonic_bbs7+1
  5666  44ac b003                   bcs +
  5667  44ae 38                     sec
  5668  44af 8001                   bra ++
  5669  44b1 18                 +   clc
  5670  44b2 60                 ++  rts
  5671                          
  5672                          
  5673                          ; Input: A=mnemonic ID
  5674                          ; Output: C=1 yes is branch
  5675                          is_branch_mnemonic:
  5676                              ; Relies on bbr7 to bvs being alphabetically consecutive
  5677                              ; Omits "b" instructions that aren't branches
  5678  44b3 c91a                   cmp #mnemonic_bbs7+1
  5679  44b5 9014                   bcc ++
  5680  44b7 c927                   cmp #mnemonic_bvs+1
  5681  44b9 b00f                   bcs +
  5682  44bb c91d                   cmp #mnemonic_bit
  5683  44bd f00b                   beq +
  5684  44bf c91e                   cmp #mnemonic_bitq
  5685  44c1 f007                   beq +
  5686  44c3 c923                   cmp #mnemonic_brk
  5687  44c5 f003                   beq +
  5688  44c7 38                     sec
  5689  44c8 8001                   bra ++
  5690  44ca 18                 +   clc
  5691  44cb 60                 ++  rts
  5692                          
  5693                          
  5694                          ; Input: A=mnemonic ID
  5695                          ; Output: C=1 yes is branch
  5696                          is_long_branch_mnemonic:
  5697                              ; Relies on lbcc to lbvs being alphabetically consecutive
  5698  44cc c943                   cmp #mnemonic_lbcc
  5699  44ce 9008                   bcc ++
  5700  44d0 c94c                   cmp #mnemonic_lbvs+1
  5701  44d2 b003                   bcs +
  5702  44d4 38                     sec
  5703  44d5 8001                   bra ++
  5704  44d7 18                 +   clc
  5705  44d8 60                 ++  rts
  5706                          
  5707                          
  5708                          ; Inputs: instr_addr_mode, instr_mode_rec_addr
  5709                          ; Outputs: Upgrades an 8-bit mode to a 16-bit mode if the instruction supports
  5710                          ;   the latter but not the former; updates instr_addr_mode
  5711                          coerce_8_to_16:
  5712  44d9 a200                   ldx #0
  5713                          @mode_loop
  5714                              ; Terminate loop if not found
  5715  44db bd5452                 lda mode16_coercion,x
  5716  44de 1d5552                 ora mode16_coercion+1,x
  5717  44e1 f34100                 lbeq @end
  5718                          
  5719                              ; Identified mode is current before-coerce type?
  5720  44e4 bd5452                 lda mode16_coercion,x
  5721  44e7 c5ca                   cmp instr_addr_mode
  5722  44e9 d029                   bne @next
  5723  44eb bd5552                 lda mode16_coercion+1,x
  5724  44ee c5cb                   cmp instr_addr_mode+1
  5725  44f0 d022                   bne @next
  5726                          
  5727                              ; Identified instruction does not support before-coerce type?
  5728  44f2 a000                   ldy #0
  5729  44f4 b1cc                   lda (instr_mode_rec_addr),y
  5730  44f6 3d5452                 and mode16_coercion,x
  5731  44f9 d019                   bne @next
  5732  44fb c8                     iny
  5733  44fc b1cc                   lda (instr_mode_rec_addr),y
  5734  44fe 3d5552                 and mode16_coercion+1,x
  5735  4501 d011                   bne @next
  5736                          
  5737                              ; Identified instruction supports after-coerce type?
  5738  4503 a000                   ldy #0
  5739  4505 b1cc                   lda (instr_mode_rec_addr),y
  5740  4507 3d5652                 and mode16_coercion+2,x
  5741  450a d00e                   bne @coerce
  5742  450c c8                     iny
  5743  450d b1cc                   lda (instr_mode_rec_addr),y
  5744  450f 3d5752                 and mode16_coercion+3,x
  5745  4512 d006                   bne @coerce
  5746                          
  5747                          @next
  5748  4514 e8                     inx
  5749  4515 e8                     inx
  5750  4516 e8                     inx
  5751  4517 e8                     inx
  5752  4518 80c1                   bra @mode_loop
  5753                          
  5754                          @coerce
  5755  451a bd5652                 lda mode16_coercion+2,x
  5756  451d 85ca                   sta instr_addr_mode
  5757  451f bd5752                 lda mode16_coercion+3,x
  5758  4522 85cb                   sta instr_addr_mode+1
  5759                          
  5760                          @end
  5761  4524 60                     rts
  5762                          
  5763                          ; Input: tokbuf, tok_pos
  5764                          ; Output:
  5765                          ;   C=0 ok, tok_pos advanced, instruction bytes assembled to segment
  5766                          ;   C=1 fail
  5767                          ;     err_code>0 fatal error with line_pos set
  5768                          assemble_instruction:
  5769                          
  5770                              ; <opcode> <addr-expr>
  5771  4525 bd017e                 lda tokbuf+1,x
  5772  4528 85c7                   sta instr_line_pos  ; stash line_pos for errors
  5773  452a 200a3b                 jsr expect_opcode
  5774  452d b3e305                 lbcs statement_err_exit
  5775  4530 85c8                   sta instr_mnemonic_id
  5776                              ; Reset instruction flags
  5777  4532 a5b9                   lda asm_flags
  5778  4534 29c1                   and #!(F_ASM_FORCE_MASK | F_ASM_AREL_MASK | F_ASM_BITBRANCH)
  5779  4536 85b9                   sta asm_flags
  5780                              ; Propagate flags from tokenizer: 8-bit if +1, 16-bit if +2
  5781  4538 98                     tya
  5782  4539 05b9                   ora asm_flags
  5783  453b 85b9                   sta asm_flags
  5784                          
  5785                              ; Locate addressing mode record for mnemonic
  5786  453d a5c8                   lda instr_mnemonic_id
  5787  453f 85cc                   sta instr_mode_rec_addr
  5788  4541 a900                   lda #0
  5789  4543 85cd                   sta instr_mode_rec_addr+1
  5790  4545 18                     clc
  5791  4546 ebcc1e                 row (easyasm_base_page << 8) + instr_mode_rec_addr
  5792  4549 ebcc1e                 row (easyasm_base_page << 8) + instr_mode_rec_addr  ; instr_mode_rec_addr = ID*4
  5793  454c a968                   lda #<addressing_modes
  5794  454e 18                     clc
  5795  454f 65cc                   adc instr_mode_rec_addr
  5796  4551 85cc                   sta instr_mode_rec_addr
  5797  4553 a952                   lda #>addressing_modes
  5798  4555 65cd                   adc instr_mode_rec_addr+1
  5799  4557 85cd                   sta instr_mode_rec_addr+1  ; instr_mode_rec_addr = address of mode record for mnemonic
  5800                          
  5801                              ; Set AREL8/AREL16 for branch/long branch instructions
  5802  4559 a5c8                   lda instr_mnemonic_id
  5803  455b 20b344                 jsr is_branch_mnemonic
  5804  455e 900a                   bcc +
  5805  4560 a5b9                   lda asm_flags
  5806  4562 29e7                   and #!F_ASM_AREL_MASK
  5807  4564 0908                   ora #F_ASM_AREL8
  5808  4566 85b9                   sta asm_flags
  5809  4568 800d                   bra ++
  5810  456a 20cc44             +   jsr is_long_branch_mnemonic
  5811  456d 9008                   bcc ++
  5812  456f a5b9                   lda asm_flags
  5813  4571 29e7                   and #!F_ASM_AREL_MASK
  5814  4573 0910                   ora #F_ASM_AREL16
  5815  4575 85b9                   sta asm_flags
  5816                          ++
  5817                          
  5818                              ; Set BITBRANCH for bit branch instructions
  5819                              ; Allows two-operand syntax
  5820  4577 a5c8                   lda instr_mnemonic_id
  5821  4579 20a644                 jsr is_bitbranch_mnemonic
  5822  457c 9006                   bcc +
  5823  457e a5b9                   lda asm_flags
  5824  4580 0920                   ora #F_ASM_BITBRANCH
  5825  4582 85b9                   sta asm_flags
  5826                          +
  5827                          
  5828                              ; Process the addressing mode expression
  5829  4584 209e42                 jsr expect_addressing_expr
  5830  4587 b38905                 lbcs statement_err_exit
  5831  458a 86ca                   stx instr_addr_mode
  5832  458c 84cb                   sty instr_addr_mode+1
  5833                          
  5834  458e 20d944                 jsr coerce_8_to_16
  5835                          
  5836                              ; Match addressing mode to opcode; error if not supported
  5837  4591 a000                   ldy #0
  5838  4593 a5ca                   lda instr_addr_mode
  5839  4595 31cc                   and (instr_mode_rec_addr),y
  5840  4597 85ca                   sta instr_addr_mode
  5841  4599 c8                     iny
  5842  459a a5cb                   lda instr_addr_mode+1
  5843  459c 31cc                   and (instr_mode_rec_addr),y
  5844  459e 05ca                   ora instr_addr_mode
  5845  45a0 d00b                   bne +
  5846                              ; Mode not supported.
  5847                              ; (detected mode = A/X)
  5848  45a2 a5c7                   lda instr_line_pos
  5849  45a4 85f2                   sta line_pos
  5850  45a6 a904                   lda #err_unsupported_addr_mode
  5851  45a8 85f3                   sta err_code
  5852  45aa 836605                 lbra statement_err_exit
  5853                          
  5854                          +   ; Start at beginning of strbuf.
  5855  45ad a900                   lda #0
  5856  45af 85c9                   sta instr_buf_pos
  5857                          
  5858                              ; Assemble Q prefix
  5859                              ;   q_mnemonics : 0-term'd list of mnemonic IDs
  5860                              ;   Emit $42 $42
  5861  45b1 a200                   ldx #0
  5862  45b3 bdae51             -   lda q_mnemonics,x
  5863  45b6 f015                   beq ++
  5864  45b8 c5c8                   cmp instr_mnemonic_id  ; mnemonic ID
  5865  45ba f003                   beq +
  5866  45bc e8                     inx
  5867  45bd 80f4                   bra -
  5868                          +   ; Is a Q instruction, emit $42 $42
  5869  45bf a6c9                   ldx instr_buf_pos
  5870  45c1 a942                   lda #$42
  5871  45c3 9d007f                 sta strbuf,x
  5872  45c6 e8                     inx
  5873  45c7 9d007f                 sta strbuf,x
  5874  45ca e8                     inx
  5875  45cb 86c9                   stx instr_buf_pos
  5876                          
  5877                          ++  ; Assemble 32-bit indirect prefix
  5878                              ;   MODE_32BIT_IND
  5879                              ;   Emit $EA
  5880  45cd a5ca                   lda instr_addr_mode
  5881  45cf 2902                   and #<MODE_32BIT_IND
  5882  45d1 f00a                   beq ++
  5883                              ; Is 32-bit indirect, emit $EA
  5884  45d3 a6c9                   ldx instr_buf_pos
  5885  45d5 a9ea                   lda #$ea
  5886  45d7 9d007f                 sta strbuf,x
  5887  45da e8                     inx
  5888  45db 86c9                   stx instr_buf_pos
  5889                          
  5890                          ++  ; Assemble instruction (mnemonic + mode) encoding
  5891                              ;   addressing_modes: (mode_bits_16, enc_addr_16)
  5892                              ;   Rotate mode_bits left, count Carry; index into enc_addr
  5893                              ;   Emit encoding byte
  5894  45dd a5ca                   lda instr_addr_mode
  5895  45df 48                     pha
  5896  45e0 a5cb                   lda instr_addr_mode+1
  5897  45e2 48                     pha
  5898  45e3 a000                   ldy #0
  5899  45e5 b1cc                   lda (instr_mode_rec_addr),y
  5900  45e7 85ce                   sta instr_supported_modes
  5901  45e9 c8                     iny
  5902  45ea b1cc                   lda (instr_mode_rec_addr),y
  5903  45ec 85cf                   sta instr_supported_modes+1
  5904  45ee a200                   ldx #0
  5905  45f0 ebce1e             -   row (easyasm_base_page << 8) + instr_supported_modes
  5906  45f3 9001                   bcc +
  5907  45f5 e8                     inx
  5908  45f6 ebca1e             +   row (easyasm_base_page << 8) + instr_addr_mode
  5909  45f9 90f5                   bcc -
  5910  45fb 68                     pla
  5911  45fc 85cb                   sta instr_addr_mode+1
  5912  45fe 68                     pla
  5913  45ff 85ca                   sta instr_addr_mode
  5914                              ; X = index into enc_addr + 1
  5915  4601 ca                     dex  ; X = X - 1
  5916  4602 a002                   ldy #2
  5917  4604 b1cc                   lda (instr_mode_rec_addr),y
  5918  4606 85f6                   sta code_ptr
  5919  4608 c8                     iny
  5920  4609 b1cc                   lda (instr_mode_rec_addr),y
  5921  460b 85f7                   sta code_ptr+1
  5922  460d 8a                     txa
  5923  460e a8                     tay
  5924  460f b1f6                   lda (code_ptr),y  ; A = the instruction encoding byte
  5925  4611 a6c9                   ldx instr_buf_pos
  5926  4613 9d007f                 sta strbuf,x
  5927  4616 e8                     inx
  5928  4617 86c9                   stx instr_buf_pos
  5929                          
  5930                              ; Assemble operand
  5931                              ;   MODES_NO_OPERAND
  5932                              ;   MODES_BYTE_OPERAND
  5933                              ;   MODES_WORD_OPERAND
  5934  4619 a5ca                   lda instr_addr_mode
  5935  461b 29e0                   and #<MODES_WORD_OPERAND
  5936  461d 85ce                   sta instr_supported_modes ; (clobbers instr_supported_modes)
  5937  461f a5cb                   lda instr_addr_mode+1
  5938  4621 2923                   and #>MODES_WORD_OPERAND
  5939  4623 05ce                   ora instr_supported_modes
  5940  4625 f023                   beq @maybe_byte_operand
  5941                              ; Word operand: emit two expr_result bytes
  5942                              ; Range check
  5943  4627 a5c8                   lda instr_mnemonic_id
  5944  4629 20cc44                 jsr is_long_branch_mnemonic  ; C=1: signed operand
  5945  462c 208e3b                 jsr is_expr_word
  5946  462f b007                   bcs +
  5947  4631 a903                   lda #err_value_out_of_range
  5948  4633 85f3                   sta err_code
  5949  4635 83db04                 lbra statement_err_exit
  5950  4638 a6c9               +   ldx instr_buf_pos
  5951  463a a5ec                   lda expr_result
  5952  463c 9d007f                 sta strbuf,x
  5953  463f e8                     inx
  5954  4640 a5ed                   lda expr_result+1
  5955  4642 9d007f                 sta strbuf,x
  5956  4645 e8                     inx
  5957  4646 86c9                   stx instr_buf_pos
  5958  4648 805e                   bra @add_bytes
  5959                          
  5960                          @maybe_byte_operand
  5961  464a a5ca                   lda instr_addr_mode
  5962  464c 291f                   and #<MODES_BYTE_OPERAND
  5963  464e 85ce                   sta instr_supported_modes
  5964  4650 a5cb                   lda instr_addr_mode+1
  5965  4652 295c                   and #>MODES_BYTE_OPERAND
  5966  4654 05ce                   ora instr_supported_modes
  5967  4656 f050                   beq @add_bytes  ; No operand, emit no more bytes
  5968                              ; For bit branch instructions, range-check and emit ZP (expr_b).
  5969                              ; Rest will emit the Rel8 (expr_result).
  5970  4658 a5b9                   lda asm_flags
  5971  465a 2920                   and #F_ASM_BITBRANCH
  5972  465c f031                   beq +++
  5973  465e 4242a5ec               ldq expr_result
  5974  4662 424285e4               stq expr_a
  5975  4666 4242a5e8               ldq expr_b
  5976  466a 424285ec               stq expr_result
  5977  466e 20a83b                 jsr is_expr_byte
  5978  4671 b007                   bcs +
  5979  4673 a903                   lda #err_value_out_of_range
  5980  4675 85f3                   sta err_code
  5981  4677 839904                 lbra statement_err_exit
  5982  467a a6c9               +   ldx instr_buf_pos
  5983  467c a5ec                   lda expr_result
  5984  467e 9d007f                 sta strbuf,x
  5985  4681 e8                     inx
  5986  4682 86c9                   stx instr_buf_pos
  5987  4684 4242a5e4               ldq expr_a
  5988  4688 424285ec               stq expr_result
  5989  468c 18                     clc
  5990  468d 8003                   bra +
  5991                          +++
  5992                              ; Byte operand: emit one expr_result byte
  5993  468f 20b344                 jsr is_branch_mnemonic  ; C=1: signed operand
  5994  4692 20a83b             +   jsr is_expr_byte
  5995  4695 b007                   bcs +
  5996  4697 a903                   lda #err_value_out_of_range
  5997  4699 85f3                   sta err_code
  5998  469b 837504                 lbra statement_err_exit
  5999  469e a6c9               +   ldx instr_buf_pos
  6000  46a0 a5ec                   lda expr_result
  6001  46a2 9d007f                 sta strbuf,x
  6002  46a5 e8                     inx
  6003  46a6 86c9                   stx instr_buf_pos
  6004                          
  6005                          @add_bytes
  6006                              ; Add bytes to segment
  6007  46a8 a6c9                   ldx instr_buf_pos
  6008  46aa 201b36                 jsr assemble_bytes
  6009  46ad 9013                   bcc ++
  6010  46af 24b6                   bit pass
  6011  46b1 300c                   bmi +
  6012  46b3 a5f3                   lda err_code
  6013  46b5 c902                   cmp #err_pc_undef
  6014  46b7 d006                   bne +
  6015                              ; PC undef on pass 0 is ok
  6016  46b9 a900                   lda #0
  6017  46bb 85f3                   sta err_code
  6018  46bd 8003                   bra ++
  6019  46bf 835104             +   lbra statement_err_exit
  6020  46c2 835404             ++  lbra statement_ok_exit
  6021                          
  6022                          
  6023                          ; ------------------------------------------------------------
  6024                          ; Directives
  6025                          ; ------------------------------------------------------------
  6026                          
  6027                          ; Input: tokbuf, tok_pos, line_addr
  6028                          ; Output:
  6029                          ;  C=0 ok, tok_pos advanced; X=line pos, Y=length
  6030                          ;  C=1 not found, tok_pos preserved
  6031                          ;    err_code>0, line_pos: report error in expression
  6032                          expect_string_arg:
  6033  46c5 a6f1                   ldx tok_pos
  6034  46c7 bd007e                 lda tokbuf,x
  6035  46ca c9b8                   cmp #tk_string_literal
  6036  46cc f002                   beq +
  6037  46ce 38                     sec
  6038  46cf 60                     rts
  6039  46d0 e8                 +   inx
  6040  46d1 bd007e                 lda tokbuf,x
  6041  46d4 4b                     taz
  6042  46d5 e8                     inx
  6043  46d6 bc007e                 ldy tokbuf,x
  6044  46d9 e8                     inx
  6045  46da 86f1                   stx tok_pos
  6046  46dc 6b                     tza
  6047  46dd aa                     tax
  6048  46de e8                     inx  ; Starting quote not included
  6049  46df 18                     clc
  6050  46e0 60                     rts
  6051                          
  6052                          ; Directives that process arg lists of arbitrary length use the
  6053                          ; process_arg_list macro and a handler routine with the following API:
  6054                          ;
  6055                          ; Input:
  6056                          ;   A==arg_type_string: string arg, X=line pos, Y=length
  6057                          ;   A==arg_type_expr: expression arg, expr_result
  6058                          ; Output:
  6059                          ;   err_code>0 : abort with error
  6060                          arg_type_string = 1
  6061                          arg_type_expr = 2
  6062                          !macro process_arg_list .handler {
  6063                          .loop
  6064                              jsr expect_string_arg
  6065                              bcs +
  6066                              lda #arg_type_string
  6067                              jsr .handler
  6068                              bra ++
  6069                          +   lda #0
  6070                              sta expr_flags
  6071                              jsr expect_expr
  6072                              bcs +
  6073                              lda #arg_type_expr
  6074                              jsr .handler
  6075                              bra ++
  6076                          +   lda err_code
  6077                              bne +
  6078                              lda #err_syntax
  6079                              sta err_code
  6080                          +   lbra statement_err_exit
  6081                          ++  lda err_code
  6082                              lbne statement_err_exit
  6083                              lda #tk_comma
  6084                              jsr expect_token
  6085                              lbcc .loop
  6086                          }
  6087                          
  6088                          
  6089                          ; General handler for byte/word/lword
  6090                          ; Input: A=arg type, etc.; Z=width (1, 2, 4)
  6091                          do_assemble_bytes:
  6092  46e1 c901                   cmp #arg_type_string
  6093  46e3 d005                   bne +
  6094  46e5 a90d                   lda #err_invalid_arg
  6095  46e7 85f3                   sta err_code
  6096  46e9 60                     rts
  6097  46ea a200               +   ldx #0
  6098  46ec a5ec                   lda expr_result
  6099  46ee 9d007f                 sta strbuf,x
  6100  46f1 e8                     inx
  6101  46f2 c202                   cpz #2
  6102  46f4 9016                   bcc @end
  6103  46f6 a5ed                   lda expr_result+1
  6104  46f8 9d007f                 sta strbuf,x
  6105  46fb e8                     inx
  6106  46fc c204                   cpz #4
  6107  46fe 900c                   bcc @end
  6108  4700 a5ee                   lda expr_result+2
  6109  4702 9d007f                 sta strbuf,x
  6110  4705 e8                     inx
  6111  4706 a5ef                   lda expr_result+3
  6112  4708 9d007f                 sta strbuf,x
  6113  470b e8                     inx
  6114                          @end
  6115  470c 201b36                 jsr assemble_bytes
  6116  470f 60                     rts
  6117                          
  6118                          ; !byte ...
  6119                          ; !8 ...
  6120                          ; Assembles byte values.
  6121                          do_byte:
  6122  4710 a301                   ldz #1
  6123  4712 83cdff                 lbra do_assemble_bytes
  6124                          assemble_dir_byte:
  6125  4715 20c546b007a90120...    +process_arg_list do_byte
  6126  4749 83cd03                 lbra statement_ok_exit
  6127                          
  6128                          ; !byte ...
  6129                          ; !8 ...
  6130                          ; Assembles word values, little-endian.
  6131                          do_word:
  6132  474c a302                   ldz #2
  6133  474e 8391ff                 lbra do_assemble_bytes
  6134                          assemble_dir_word:
  6135  4751 20c546b007a90120...    +process_arg_list do_word
  6136  4785 839103                 lbra statement_ok_exit
  6137                          
  6138                          ; !32 ...
  6139                          ; Assembles long word values, little-endian.
  6140                          do_lword:
  6141  4788 a304                   ldz #4
  6142  478a 8355ff                 lbra do_assemble_bytes
  6143                          assemble_dir_lword:
  6144  478d 20c546b007a90120...    +process_arg_list do_lword
  6145  47c1 835503                 lbra statement_ok_exit
  6146                          
  6147                          
  6148                          ; !warn ...
  6149                          ; Prints "Line #: " followed by one or more arguments.
  6150                          ; Value arguments print: "<dec> ($<hex>) "
  6151                          ; String arguments print their contents.
  6152                          do_warn:
  6153  47c4 4b                     taz
  6154                          
  6155  47c5 24b6                   bit pass
  6156  47c7 3001                   bmi +
  6157  47c9 60                     rts
  6158                          +
  6159                          
  6160  47ca c201                   cpz #arg_type_string
  6161  47cc d004                   bne +
  6162  47ce 20ab2c                 jsr print_bas_str
  6163  47d1 60                     rts
  6164                          
  6165  47d2 4242a5ec           +   ldq expr_result
  6166  47d6 20d22c                 jsr print_dec32
  6167  47d9 48a9005b68207dff       +kprimm_start
  6168  47e1 20282400               !pet " ($",0
  6169  47e5 48a91e5b68             +kprimm_end
  6170                          
  6171                              ; Print expr_result as hex, adjusting for leading zeroes (32, 16, or 8 bit)
  6172  47ea a5ef                   lda expr_result+3
  6173  47ec 05ee                   ora expr_result+2
  6174  47ee 05ed                   ora expr_result+1
  6175  47f0 f015                   beq ++
  6176  47f2 a5ef                   lda expr_result+3
  6177  47f4 05ee                   ora expr_result+2
  6178  47f6 f00a                   beq +
  6179  47f8 a5ef                   lda expr_result+3
  6180  47fa 208a2d                 jsr print_hex8
  6181  47fd a5ee                   lda expr_result+2
  6182  47ff 208a2d                 jsr print_hex8
  6183  4802 a5ed               +   lda expr_result+1
  6184  4804 208a2d                 jsr print_hex8
  6185  4807 a5ec               ++  lda expr_result
  6186  4809 208a2d                 jsr print_hex8
  6187                          
  6188  480c 48a9005b68207dff       +kprimm_start
  6189  4814 292000                 !pet ") ",0
  6190  4817 48a91e5b68             +kprimm_end
  6191  481c 60                     rts
  6192                          
  6193                          assemble_dir_warn:
  6194                              ; Only print warnings on final pass.
  6195                              ; (Acme prints on every pass. Will I regret this?)
  6196  481d 24b6                   bit pass
  6197  481f 1003                   bpl +
  6198  4821 20df2e                 jsr print_warning_line_number
  6199                          +
  6200  4824 20c546b007a90120...    +process_arg_list do_warn
  6201                          
  6202  4858 24b6                   bit pass
  6203  485a 100f                   bpl +
  6204  485c a90d                   lda #chr_cr
  6205  485e 48a9005b6820d2ff...    +kcall bsout
  6206                          +
  6207  486b a5b9                   lda asm_flags
  6208  486d 0940                   ora #F_ASM_WARN
  6209  486f 85b9                   sta asm_flags
  6210  4871 83a502                 lbra statement_ok_exit
  6211                          
  6212                          
  6213                          ; !fill <count> [, <val>]
  6214                          assemble_dir_fill:
  6215  4874 a900                   lda #0
  6216  4876 85f0                   sta expr_flags
  6217  4878 20b63f                 jsr expect_expr
  6218  487b 900b                   bcc ++
  6219  487d a5f3                   lda err_code
  6220  487f d004                   bne +
  6221  4881 a90e                   lda #err_missing_arg
  6222  4883 85f3                   sta err_code
  6223  4885 838b02             +   lbra statement_err_exit
  6224  4888 4242a5ec           ++  ldq expr_result
  6225  488c 424285e8               stq expr_b  ; expr_b = count
  6226  4890 a900                   lda #0      ; default fill value is 0
  6227  4892 85ec                   sta expr_result
  6228  4894 85ed                   sta expr_result+1
  6229  4896 85ee                   sta expr_result+2
  6230  4898 85ef                   sta expr_result+3
  6231  489a a9ac                   lda #tk_comma
  6232  489c 20633a                 jsr expect_token
  6233  489f b023                   bcs @start_fill
  6234  48a1 a900                   lda #0
  6235  48a3 85f0                   sta expr_flags
  6236  48a5 20b63f                 jsr expect_expr
  6237  48a8 900b                   bcc ++
  6238  48aa a5f3                   lda err_code
  6239  48ac d004                   bne +
  6240  48ae a90e                   lda #err_missing_arg
  6241  48b0 85f3                   sta err_code
  6242  48b2 835e02             +   lbra statement_err_exit
  6243  48b5 a5ef               ++  lda expr_result+3  ; custom fill byte must be <256
  6244  48b7 05ee                   ora expr_result+2
  6245  48b9 05ed                   ora expr_result+1
  6246  48bb f007                   beq @start_fill
  6247  48bd a903                   lda #err_value_out_of_range
  6248  48bf 85f3                   sta err_code
  6249  48c1 834f02                 lbra statement_err_exit
  6250                          
  6251                              ; expr_result = fill byte
  6252                              ; expr_a = fill count
  6253                          @start_fill
  6254                              ; Completely fill strbuf with the fill byte.
  6255  48c4 a5ec                   lda expr_result  ; fill byte
  6256  48c6 a200                   ldx #$00
  6257  48c8 9d007f             -   sta strbuf,x
  6258  48cb e8                     inx
  6259  48cc d0fa                   bne -
  6260                          
  6261  48ce a900                   lda #0
  6262  48d0 aa                     tax
  6263  48d1 a8                     tay
  6264  48d2 4b                     taz
  6265  48d3 a9ff                   lda #$ff
  6266  48d5 85ec                   sta expr_result  ; expr_result = 255
  6267                          
  6268                          @fill_loop
  6269  48d7 4242a5ec               ldq expr_result
  6270  48db 4242c5e8               cpq expr_b
  6271  48df b014                   bcs ++  ; count < 255, less than a block remaining
  6272  48e1 a2ff                   ldx #$ff
  6273  48e3 201b36                 jsr assemble_bytes  ; assemble 255 fill bytes (uses expr_a)
  6274  48e6 4242a5e8               ldq expr_b
  6275  48ea 38                     sec
  6276  48eb 4242e5ec               sbcq expr_result
  6277  48ef 424285e8               stq expr_b  ; expr_b = expr_b - 255
  6278  48f3 80e2                   bra @fill_loop
  6279  48f5 a6e8               ++  ldx expr_b  ; remaining (< 255)
  6280  48f7 201b36                 jsr assemble_bytes  ; (does nothing if X=0)
  6281  48fa 831c02                 lbra statement_ok_exit
  6282                          
  6283                          
  6284                          do_petscr:
  6285                              ; expr_a=0 for pet, expr_a=$ff for scr
  6286  48fd 64e4                   stz expr_a
  6287                          
  6288  48ff c901                   cmp #arg_type_string
  6289  4901 f033                   beq @do_petscr_string
  6290                          
  6291                              ; Emit expression.
  6292  4903 a5ef                   lda expr_result+3
  6293  4905 05ee                   ora expr_result+2
  6294  4907 05ed                   ora expr_result+1
  6295  4909 f005                   beq +
  6296  490b a903                   lda #err_value_out_of_range
  6297  490d 85f3                   sta err_code
  6298  490f 60                     rts
  6299                          +   ; Convert char literal expressions.
  6300  4910 24e4                   bit expr_a
  6301  4912 100f                   bpl +
  6302  4914 a5f0                   lda expr_flags
  6303  4916 2903                   and #F_EXPR_BRACKET_CHARLIT
  6304  4918 c903                   cmp #F_EXPR_BRACKET_CHARLIT
  6305  491a d007                   bne +
  6306  491c a6ec                   ldx expr_result
  6307  491e bd0056                 lda scr_table,x
  6308  4921 8002                   bra ++
  6309  4923 a5ec               +   lda expr_result
  6310  4925 a200               ++  ldx #0
  6311  4927 9d007f                 sta strbuf,x
  6312  492a e8                     inx
  6313  492b a900                   lda #0
  6314  492d 9d007f                 sta strbuf,x
  6315  4930 a201                   ldx #1
  6316  4932 201b36                 jsr assemble_bytes
  6317  4935 60                     rts
  6318                          
  6319                          @do_petscr_string
  6320                              ; X=line pos Y=len Z=scr
  6321  4936 c000                   cpy #0
  6322  4938 d001                   bne +
  6323  493a 60                     rts
  6324                          +
  6325  493b 8a                     txa
  6326  493c 18                     clc
  6327  493d 65f4                   adc line_addr
  6328  493f 85fc                   sta bas_ptr
  6329  4941 a900                   lda #0
  6330  4943 65f5                   adc line_addr+1
  6331  4945 85fd                   sta bas_ptr+1
  6332                              ; bas_ptr = beginning of string
  6333  4947 a200                   ldx #0
  6334                          
  6335                              ; Y = length > 0
  6336                              ; X = strbuf pos
  6337                              ; Z = string pos
  6338                              ; expr_a = $ff if scr
  6339  4949 a200                   ldx #0
  6340  494b a300                   ldz #0
  6341  494d eab2fc             -   lda [bas_ptr],z
  6342  4950 24e4                   bit expr_a
  6343  4952 1006                   bpl +
  6344  4954 da                     phx
  6345  4955 aa                     tax
  6346  4956 bd0056                 lda scr_table,x
  6347  4959 fa                     plx
  6348  495a 9d007f             +   sta strbuf,x
  6349  495d e8                     inx
  6350  495e 1b                     inz
  6351  495f 88                     dey
  6352  4960 d0eb                   bne -
  6353                              ; X = length
  6354  4962 201b36                 jsr assemble_bytes
  6355  4965 60                     rts
  6356                          
  6357                          
  6358                          do_pet:
  6359  4966 a300                   ldz #0
  6360  4968 8393ff                 lbra do_petscr
  6361                          assemble_dir_pet:
  6362  496b 20c546b007a90120...    +process_arg_list do_pet
  6363  499f 837701                 lbra statement_ok_exit
  6364                          do_scr:
  6365  49a2 a3ff                   ldz #$ff
  6366  49a4 8357ff                 lbra do_petscr
  6367                          assemble_dir_scr:
  6368  49a7 20c546b007a90120...    +process_arg_list do_scr
  6369  49db 833b01                 lbra statement_ok_exit
  6370                          
  6371                          
  6372                          ; !to "<fname>", <mode>
  6373                          assemble_dir_to:
  6374  49de 20c546                 jsr expect_string_arg
  6375  49e1 9007                   bcc +
  6376  49e3 a90e                   lda #err_missing_arg
  6377  49e5 85f3                   sta err_code
  6378  49e7 832901                 lbra statement_err_exit
  6379  49ea 86e4               +   stx expr_a    ; expr_a = string pos
  6380  49ec 84e5                   sty expr_a+1  ; expr_a+1 = length
  6381  49ee a9ac                   lda #tk_comma
  6382  49f0 20633a                 jsr expect_token
  6383  49f3 9007                   bcc +
  6384  49f5 a901                   lda #err_syntax
  6385  49f7 85f3                   sta err_code
  6386  49f9 831701                 lbra statement_err_exit
  6387  49fc a23d               +   ldx #<kw_cbm
  6388  49fe a052                   ldy #>kw_cbm
  6389  4a00 20cf3a                 jsr expect_keyword
  6390  4a03 b004                   bcs +
  6391  4a05 a900                   lda #F_FILE_CBM
  6392  4a07 8024                   bra @to_parsed
  6393  4a09 a241               +   ldx #<kw_plain
  6394  4a0b a052                   ldy #>kw_plain
  6395  4a0d 20cf3a                 jsr expect_keyword
  6396  4a10 b007                   bcs +
  6397                              ; "plain" file type is not supported yet because I'm using KERNAL SAVE for
  6398                              ; now, which doesn't support it. Keeping the parsing just in case I change
  6399  4a12 a90a                   lda #err_unimplemented
  6400  4a14 85f3                   sta err_code
  6401  4a16 83fa00                 lbra statement_err_exit
  6402                              ;lda #F_FILE_PLAIN
  6403                              ;bra @to_parsed
  6404  4a19 a247               +   ldx #<kw_runnable
  6405  4a1b a052                   ldy #>kw_runnable
  6406  4a1d 20cf3a                 jsr expect_keyword
  6407  4a20 b004                   bcs +
  6408  4a22 a902                   lda #F_FILE_RUNNABLE
  6409  4a24 8007                   bra @to_parsed
  6410                          +   ; Wrong or missing keyword
  6411  4a26 a901                   lda #err_syntax
  6412  4a28 85f3                   sta err_code
  6413  4a2a 83e600                 lbra statement_err_exit
  6414                          
  6415                          @to_parsed
  6416  4a2d 48                     pha  ; mode flag
  6417                          
  6418                              ; Runnable sets PC; other modes un-set PC
  6419  4a2e c902                   cmp #F_FILE_RUNNABLE
  6420  4a30 d009                   bne +
  6421  4a32 a214                   ldx #<bootstrap_ml_start
  6422  4a34 a020                   ldy #>bootstrap_ml_start
  6423  4a36 20b035                 jsr set_pc
  6424  4a39 8006                   bra ++
  6425  4a3b a5b9               +   lda asm_flags
  6426  4a3d 29fe                   and #!F_ASM_PC_DEFINED
  6427  4a3f 85b9                   sta asm_flags
  6428                          ++
  6429                          
  6430  4a41 24b6                   bit pass
  6431  4a43 3004                   bmi +
  6432  4a45 68                     pla
  6433  4a46 83d000                 lbra statement_ok_exit
  6434                          +
  6435                          
  6436  4a49 a5e5                   lda expr_a+1
  6437  4a4b 48                     pha  ; filename length
  6438                          
  6439                              ; Add a file marker to the segment table.
  6440                              ; ($0000, $FFFF, fnameaddr32, fnamelen8, flags8)
  6441  4a4c a300                   ldz #0
  6442  4a4e a900                   lda #0
  6443  4a50 ea92c0                 sta [next_segment_byte_addr],z
  6444  4a53 1b                     inz
  6445  4a54 ea92c0                 sta [next_segment_byte_addr],z
  6446  4a57 1b                     inz
  6447  4a58 a9ff                   lda #$ff
  6448  4a5a ea92c0                 sta [next_segment_byte_addr],z
  6449  4a5d 1b                     inz
  6450  4a5e ea92c0                 sta [next_segment_byte_addr],z
  6451  4a61 1b                     inz
  6452                          
  6453                              ; expr_a = filename pos
  6454                              ; expr_a = filename address = line_addr + filename pos
  6455  4a62 a900                   lda #0
  6456  4a64 85e5                   sta expr_a+1
  6457  4a66 85e6                   sta expr_a+2
  6458  4a68 85e7                   sta expr_a+3
  6459  4a6a a5f4                   lda line_addr
  6460  4a6c 85fc                   sta bas_ptr
  6461  4a6e a5f5                   lda line_addr+1
  6462  4a70 85fd                   sta bas_ptr+1
  6463  4a72 db                     phz
  6464  4a73 4242a5fc               ldq bas_ptr    ; Adopt whatever bas_ptr's high bytes are
  6465  4a77 18                     clc
  6466  4a78 424265e4               adcq expr_a  ; Q = filename address
  6467  4a7c 424285e4               stq expr_a
  6468  4a80 fb                     plz
  6469  4a81 a5e4                   lda expr_a
  6470  4a83 ea92c0                 sta [next_segment_byte_addr],z
  6471  4a86 1b                     inz
  6472  4a87 a5e5                   lda expr_a+1
  6473  4a89 ea92c0                 sta [next_segment_byte_addr],z
  6474  4a8c 1b                     inz
  6475  4a8d a5e6                   lda expr_a+2
  6476  4a8f ea92c0                 sta [next_segment_byte_addr],z
  6477  4a92 1b                     inz
  6478  4a93 a5e7                   lda expr_a+3
  6479  4a95 ea92c0                 sta [next_segment_byte_addr],z
  6480  4a98 1b                     inz
  6481                          
  6482  4a99 68                     pla  ; length
  6483  4a9a ea92c0                 sta [next_segment_byte_addr],z
  6484  4a9d 1b                     inz
  6485  4a9e 68                     pla  ; flags
  6486  4a9f ea92c0                 sta [next_segment_byte_addr],z
  6487  4aa2 1b                     inz
  6488                          
  6489                              ; Advance next_segment_byte_addr and current_segment to this location.
  6490  4aa3 6b                     tza
  6491  4aa4 18                     clc
  6492  4aa5 65c0                   adc next_segment_byte_addr
  6493  4aa7 85c0                   sta next_segment_byte_addr
  6494  4aa9 a900                   lda #0
  6495  4aab 65c1                   adc next_segment_byte_addr+1
  6496  4aad 85c1                   sta next_segment_byte_addr+1
  6497  4aaf a900                   lda #0
  6498  4ab1 65c2                   adc next_segment_byte_addr+2
  6499  4ab3 85c2                   sta next_segment_byte_addr+2
  6500  4ab5 a900                   lda #0
  6501  4ab7 65c3                   adc next_segment_byte_addr+3
  6502  4ab9 85c3                   sta next_segment_byte_addr+3
  6503  4abb 4242a5c0               ldq next_segment_byte_addr
  6504  4abf 424285ba               stq current_segment
  6505                          
  6506                              ; Write new null terminator
  6507  4ac3 a307                   ldz #7
  6508  4ac5 a900                   lda #0
  6509  4ac7 ea92c0             -   sta [next_segment_byte_addr],z
  6510  4aca 3b                     dez
  6511  4acb 10fa                   bpl -
  6512                          
  6513  4acd 834900                 lbra statement_ok_exit
  6514                          
  6515                          
  6516                          ; !cpu m65
  6517                          ; EasyAsm only supports the "m65" CPU. This directive exists to ignore "!cpu
  6518                          ; m65" and report an error for any other !cpu value, to make it easier to port
  6519                          ; Acme programs to EasyAsm.
  6520                          assemble_dir_cpu:
  6521  4ad0 a250                   ldx #<kw_m65
  6522  4ad2 a052                   ldy #>kw_m65
  6523  4ad4 20cf3a                 jsr expect_keyword
  6524  4ad7 b003                   bcs +
  6525  4ad9 833d00                 lbra statement_ok_exit
  6526  4adc a910               +   lda #err_unsupported_cpu_mode
  6527  4ade 85f3                   sta err_code
  6528  4ae0 833000                 lbra statement_err_exit
  6529                          
  6530                          
  6531                          assemble_dir_source:
  6532                          assemble_dir_binary:
  6533  4ae3 a90a                   lda #err_unimplemented
  6534  4ae5 85f3                   sta err_code
  6535  4ae7 832900                 lbra statement_err_exit
  6536                          
  6537                          
  6538                          directive_jump_table:
  6539                          ; Sorted by token ID
  6540  4aea de49               !word assemble_dir_to
  6541  4aec 15471547           !word assemble_dir_byte, assemble_dir_byte
  6542  4af0 51475147           !word assemble_dir_word, assemble_dir_word
  6543  4af4 8d47               !word assemble_dir_lword
  6544  4af6 7448               !word assemble_dir_fill
  6545  4af8 6b49               !word assemble_dir_pet
  6546  4afa a749               !word assemble_dir_scr
  6547  4afc e34a               !word assemble_dir_source
  6548  4afe e34a               !word assemble_dir_binary
  6549  4b00 1d48               !word assemble_dir_warn
  6550  4b02 d04a               !word assemble_dir_cpu
  6551                          
  6552                          assemble_directive:
  6553                              ; <pseudoop> arglist
  6554  4b04 20223b                 jsr expect_pseudoop
  6555  4b07 b30900                 lbcs statement_err_exit
  6556                              ; A=token ID
  6557  4b0a 38                     sec
  6558  4b0b e993                   sbc #tokid_after_mnemonics
  6559  4b0d 0a                     asl
  6560  4b0e aa                     tax
  6561  4b0f 7cea4a                 jmp (directive_jump_table,x)
  6562                          
  6563                          
  6564                          ; ------------------------------------------------------------
  6565                          ; Assembler
  6566                          ; ------------------------------------------------------------
  6567                          
  6568                          
  6569                          statement_err_exit
  6570  4b12 a6c4                   ldx stmt_tokpos
  6571  4b14 86f1                   stx tok_pos
  6572  4b16 38                     sec
  6573  4b17 60                     rts
  6574                          
  6575                          statement_ok_exit
  6576  4b18 18                     clc
  6577  4b19 60                     rts
  6578                          
  6579                          
  6580                          ; Input: line_addr
  6581                          ; Output: err_code, line_pos
  6582                          ;  C=0 success, continue
  6583                          ;  C=1 stop assembly (err_code=0 end of program, other on error)
  6584                          assemble_line:
  6585  4b1a a900                   lda #0
  6586  4b1c 85f3                   sta err_code
  6587                          
  6588  4b1e a5f4                   lda line_addr
  6589  4b20 85fc                   sta bas_ptr
  6590  4b22 a5f5                   lda line_addr+1
  6591  4b24 85fd                   sta bas_ptr+1
  6592                          
  6593  4b26 a300                   ldz #0
  6594  4b28 eab2fc                 lda [bas_ptr],z
  6595  4b2b 1b                     inz
  6596  4b2c ea12fc                 ora [bas_ptr],z
  6597  4b2f d002                   bne +
  6598                              ; End of program
  6599  4b31 38                     sec
  6600  4b32 60                     rts
  6601                          +
  6602  4b33 20fe32                 jsr tokenize
  6603  4b36 a5f3                   lda err_code
  6604  4b38 f002                   beq +
  6605                              ; Error return
  6606  4b3a 38                     sec
  6607  4b3b 60                     rts
  6608                          +
  6609  4b3c a200                   ldx #0
  6610  4b3e 86f1                   stx tok_pos
  6611                          
  6612                          @tokbuf_loop
  6613  4b40 a6f1                   ldx tok_pos
  6614  4b42 bd007e                 lda tokbuf,x
  6615  4b45 f36600                 lbeq @end_tokbuf
  6616  4b48 86c4                   stx stmt_tokpos
  6617                          
  6618  4b4a 205c40                 jsr assemble_pc_assign
  6619  4b4d 934400                 lbcc @next_statement
  6620  4b50 a5f3                   lda err_code
  6621  4b52 d35700                 lbne @err_exit
  6622                          
  6623  4b55 203d41                 jsr assemble_label
  6624  4b58 b013                   bcs +
  6625  4b5a c200                   cpz #0
  6626  4b5c f33500                 lbeq @next_statement
  6627  4b5f a6f1                   ldx tok_pos
  6628  4b61 bd007e                 lda tokbuf,x
  6629  4b64 f34700                 lbeq @end_tokbuf  ; label at end of line
  6630  4b67 c9ae                   cmp #tk_colon
  6631  4b69 f028                   beq @next_statement  ; colon follows label
  6632  4b6b 8005                   bra ++  ; label without equal not end of line or statement,
  6633                                      ; must precede an instruction or directive
  6634  4b6d a5f3               +   lda err_code
  6635  4b6f d33a00                 lbne @err_exit
  6636                          
  6637                          ++
  6638  4b72 202545                 jsr assemble_instruction
  6639  4b75 901c                   bcc @next_statement
  6640  4b77 a5f3                   lda err_code
  6641  4b79 d33000                 lbne @err_exit
  6642                          
  6643  4b7c 20044b                 jsr assemble_directive
  6644  4b7f 9012                   bcc @next_statement
  6645  4b81 a5f3                   lda err_code
  6646  4b83 d32600                 lbne @err_exit
  6647                          
  6648                              ; No statement patterns match. Syntax error.
  6649  4b86 a6f1                   ldx tok_pos
  6650  4b88 bd017e                 lda tokbuf+1,x
  6651  4b8b 85f2                   sta line_pos
  6652  4b8d a901                   lda #err_syntax
  6653  4b8f 85f3                   sta err_code
  6654  4b91 8018                   bra @err_exit
  6655                          
  6656                          @next_statement
  6657                              ; If colon, try another statement.
  6658                              ; (This covers <label> ":" also.)
  6659  4b93 a9ae                   lda #tk_colon
  6660  4b95 20633a                 jsr expect_token
  6661  4b98 93a6ff                 lbcc @tokbuf_loop
  6662                          
  6663                          @must_end
  6664  4b9b a6f1                   ldx tok_pos
  6665  4b9d bd007e                 lda tokbuf,x
  6666  4ba0 f00b                   beq @end_tokbuf
  6667  4ba2 a901                   lda #err_syntax
  6668  4ba4 85f3                   sta err_code
  6669  4ba6 bd017e                 lda tokbuf+1,x
  6670  4ba9 85f2                   sta line_pos
  6671                          @err_exit
  6672  4bab 38                     sec
  6673  4bac 60                     rts
  6674                          @end_tokbuf
  6675  4bad 18                     clc
  6676  4bae 60                     rts
  6677                          
  6678                          
  6679                          ; Input: pass
  6680                          ; Output:
  6681                          ;   err_code = 0: one full assembly pass
  6682                          ;   err_code > 0: error result
  6683                          do_assemble_pass:
  6684  4baf a901                   lda #<(source_start+1)
  6685  4bb1 85f4                   sta line_addr
  6686  4bb3 a920                   lda #>(source_start+1)
  6687  4bb5 85f5                   sta line_addr+1
  6688                          
  6689                          @line_loop
  6690  4bb7 201a4b                 jsr assemble_line
  6691  4bba b017                   bcs @end
  6692  4bbc a5f4                   lda line_addr
  6693  4bbe 85fc                   sta bas_ptr
  6694  4bc0 a5f5                   lda line_addr+1
  6695  4bc2 85fd                   sta bas_ptr+1
  6696  4bc4 a300                   ldz #0
  6697  4bc6 eab2fc                 lda [bas_ptr],z
  6698  4bc9 85f4                   sta line_addr
  6699  4bcb 1b                     inz
  6700  4bcc eab2fc                 lda [bas_ptr],z
  6701  4bcf 85f5                   sta line_addr+1
  6702  4bd1 80e4                   bra @line_loop
  6703                          @end
  6704  4bd3 60                     rts
  6705                          
  6706                          
  6707                          ; Input: source in BASIC region
  6708                          ; Output:
  6709                          ;   err_code = 0: segment table built successfully
  6710                          ;   err_code > 0: error result
  6711                          assemble_source:
  6712                              ; Do two assembly passes ($00, $FF), aborting for errors.
  6713  4bd4 a900                   lda #0
  6714  4bd6 85b6               -   sta pass
  6715  4bd8 209535                 jsr init_pass
  6716  4bdb 20af4b                 jsr do_assemble_pass
  6717  4bde a5f3                   lda err_code
  6718  4be0 d008                   bne @done
  6719  4be2 24b6                   bit pass
  6720  4be4 3004                   bmi @done
  6721  4be6 a9ff                   lda #$ff
  6722  4be8 80ec                   bra -
  6723                          @done
  6724  4bea 60                     rts
  6725                          
  6726                          
  6727                          ; ------------------------------------------------------------
  6728                          ; Data
  6729                          ; ------------------------------------------------------------
  6730                          
  6731                          ; ---------------------------------------------------------
  6732                          ; Error message strings
  6733                          
  6734                          err_message_tbl:
  6735  4beb 134c204c3a4c4d4c...!word e01,e02,e03,e04,e05,e06,e07,e08,e09,e10,e11,e12,e13,e14,e15
  6736  4c09 834d984dbc4dce4d...!word e16,e17,e18,e19,e20
  6737                          
  6738                          err_messages:
  6739                          err_syntax = 1
  6740  4c13 53594e5441582045...e01: !pet "syntax error",0
  6741                          err_pc_undef = 2
  6742  4c20 50524f4752414d20...e02: !pet "program counter undefined",0
  6743                          err_value_out_of_range = 3
  6744  4c3a 56414c5545204f55...e03: !pet "value out of range",0
  6745                          err_unsupported_addr_mode = 4
  6746  4c4d 554e535550504f52...e04: !pet "unsupported addressing mode for instruction",0
  6747                          err_already_defined = 5
  6748  4c79 53594d424f4c2041...e05: !pet "symbol already defined",0
  6749                          err_out_of_memory = 6
  6750  4c90 4f5554204f46204d...e06: !pet "out of memory",0
  6751                          err_undefined = 7
  6752  4c9e 53594d424f4c2055...e07: !pet "symbol undefined",0
  6753                          err_pc_overflow = 8
  6754  4caf 50524f4752414d20...e08: !pet "program counter overflowed $ffff",0
  6755                          err_label_assign_global_only = 9
  6756  4cd0 4f4e4c5920474c4f...e09: !pet "only global labels can be assigned with =",0
  6757                          err_unimplemented = 10
  6758  4cfa 554e494d504c454d...e10: !pet "unimplemented feature",0
  6759                          err_exponent_negative = 11
  6760  4d10 4558504f4e454e54...e11: !pet "exponent cannot be negative",0
  6761                          err_fraction_not_supported = 12
  6762  4d2c 4652414354494f4e...e12: !pet "fraction operator not supported",0
  6763                          err_invalid_arg = 13
  6764  4d4c 415247554d454e54...e13: !pet "argument not allowed",0
  6765                          err_missing_arg = 14
  6766  4d61 4d495353494e4720...e14: !pet "missing argument",0
  6767                          err_division_by_zero = 15
  6768  4d72 4449564953494f4e...e15: !pet "division by zero",0
  6769                          err_unsupported_cpu_mode = 16
  6770  4d83 554e535550504f52...e16: !pet "unsupported cpu mode",0
  6771                          err_segment_without_a_file = 17
  6772  4d98 5345474d454e5420...e17: !pet "segment without a file, missing !to",0
  6773                          err_disk_error = 18
  6774  4dbc 4b45524e414c2044...e18: !pet "kernal disk error",0
  6775                          err_device_not_present = 19
  6776  4dce 4449534b20444556...e19: !pet "disk device not present; to set device, use: set def #",0
  6777                          err_runnable_wrong_segments = 20
  6778  4e05 52554e4e41424c45...e20: !pet "runnable file only supports one segment at default pc",0
  6779                          
  6780                          warn_message_tbl:
  6781  4e3b 3d4e               !word w01
  6782                          warn_messages:
  6783                          warn_ldz_range = 1
  6784  4e3d 4c445a2057495448...w01: !pet "ldz with address $00-$FF behaves as $0000-$00FF (ldz+2 to silence)"
  6785                          
  6786                          kernal_error_messages:
  6787  4e7f 914ea94ebb4ec94e...!word ke01,ke02,ke03,ke04,ke05,ke06,ke07,ke08,ke09
  6788  4e91 544f4f204d414e59...ke01: !pet "too many files are open",0
  6789  4ea9 46494c4520414c52...ke02: !pet "file already open",0
  6790  4ebb 46494c45204e4f54...ke03: !pet "file not open",0
  6791  4ec9 46494c45204e4f54...ke04: !pet "file not found",0
  6792  4ed8 444556494345204e...ke05: !pet "device not present",0
  6793  4eeb 4e4f5420494e5055...ke06: !pet "not input file",0
  6794  4efa 4e4f54204f555450...ke07: !pet "not output file",0
  6795  4f0a 4d495353494e4720...ke08: !pet "missing filename",0
  6796  4f1b 494c4c4547414c20...ke09: !pet "illegal device number",0
  6797                          
  6798                          ; ---------------------------------------------------------
  6799                          ; Mnemonics token list
  6800                          mnemonics:
  6801  4f31 41444300           !pet "adc",0   ; $01
  6802                          mnemonic_adc = $01
  6803  4f35 4144435100         !pet "adcq",0  ; $02
  6804                          mnemonic_adcq = $02
  6805  4f3a 414e4400           !pet "and",0   ; $03
  6806  4f3e 414e445100         !pet "andq",0  ; $04
  6807                          mnemonic_andq = $04
  6808  4f43 41534c00           !pet "asl",0   ; $05
  6809  4f47 41534c5100         !pet "aslq",0  ; $06
  6810                          mnemonic_aslq = $06
  6811  4f4c 41535200           !pet "asr",0   ; $07
  6812  4f50 4153525100         !pet "asrq",0  ; $08
  6813                          mnemonic_asrq = $08
  6814  4f55 41535700           !pet "asw",0   ; $09
  6815  4f59 4242523000         !pet "bbr0",0  ; $0A
  6816                          mnemonic_bbr0 = $0A
  6817  4f5e 4242523100         !pet "bbr1",0  ; $0B
  6818  4f63 4242523200         !pet "bbr2",0  ; $0C
  6819  4f68 4242523300         !pet "bbr3",0  ; $0D
  6820  4f6d 4242523400         !pet "bbr4",0  ; $0E
  6821  4f72 4242523500         !pet "bbr5",0  ; $0F
  6822  4f77 4242523600         !pet "bbr6",0  ; $10
  6823  4f7c 4242523700         !pet "bbr7",0  ; $11
  6824  4f81 4242533000         !pet "bbs0",0  ; $12
  6825  4f86 4242533100         !pet "bbs1",0  ; $13
  6826  4f8b 4242533200         !pet "bbs2",0  ; $14
  6827  4f90 4242533300         !pet "bbs3",0  ; $15
  6828  4f95 4242533400         !pet "bbs4",0  ; $16
  6829  4f9a 4242533500         !pet "bbs5",0  ; $17
  6830  4f9f 4242533600         !pet "bbs6",0  ; $18
  6831  4fa4 4242533700         !pet "bbs7",0  ; $19
  6832                          mnemonic_bbs7 = $19
  6833  4fa9 42434300           !pet "bcc",0   ; $1A
  6834  4fad 42435300           !pet "bcs",0   ; $1B
  6835  4fb1 42455100           !pet "beq",0   ; $1C
  6836  4fb5 42495400           !pet "bit",0   ; $1D
  6837                          mnemonic_bit = $1D
  6838  4fb9 4249545100         !pet "bitq",0  ; $1E
  6839                          mnemonic_bitq = $1E
  6840  4fbe 424d4900           !pet "bmi",0   ; $1F
  6841  4fc2 424e4500           !pet "bne",0   ; $20
  6842  4fc6 42504c00           !pet "bpl",0   ; $21
  6843  4fca 42524100           !pet "bra",0   ; $22
  6844  4fce 42524b00           !pet "brk",0   ; $23
  6845                          mnemonic_brk = $23
  6846  4fd2 42535200           !pet "bsr",0   ; $24
  6847  4fd6 42564300           !pet "bvc",0   ; $25
  6848  4fda 42565300           !pet "bvs",0   ; $26
  6849                          mnemonic_bvs = $26
  6850  4fde 434c4300           !pet "clc",0   ; $27
  6851  4fe2 434c4400           !pet "cld",0   ; $28
  6852  4fe6 434c4500           !pet "cle",0   ; $29
  6853  4fea 434c4900           !pet "cli",0   ; $2A
  6854  4fee 434c5600           !pet "clv",0   ; $2B
  6855  4ff2 434d5000           !pet "cmp",0   ; $2C
  6856  4ff6 434d505100         !pet "cmpq",0  ; $2D
  6857                          mnemonic_cmpq = $2D
  6858  4ffb 43505100           !pet "cpq",0   ; $2E
  6859                          mnemonic_cpq = $2E
  6860  4fff 43505800           !pet "cpx",0   ; $2F
  6861  5003 43505900           !pet "cpy",0   ; $30
  6862  5007 43505a00           !pet "cpz",0   ; $31
  6863  500b 44454300           !pet "dec",0   ; $32
  6864  500f 44455100           !pet "deq",0   ; $33
  6865                          mnemonic_deq = $33
  6866  5013 44455700           !pet "dew",0   ; $34
  6867  5017 44455800           !pet "dex",0   ; $35
  6868  501b 44455900           !pet "dey",0   ; $36
  6869  501f 44455a00           !pet "dez",0   ; $37
  6870  5023 454f4d00           !pet "eom",0   ; $38
  6871  5027 454f5200           !pet "eor",0   ; $39
  6872  502b 454f525100         !pet "eorq",0  ; $3A
  6873                          mnemonic_eorq = $3A
  6874  5030 494e4300           !pet "inc",0   ; $3B
  6875  5034 494e5100           !pet "inq",0   ; $3C
  6876                          mnemonic_inq = $3C
  6877  5038 494e5700           !pet "inw",0   ; $3D
  6878  503c 494e5800           !pet "inx",0   ; $3E
  6879  5040 494e5900           !pet "iny",0   ; $3F
  6880  5044 494e5a00           !pet "inz",0   ; $40
  6881  5048 4a4d5000           !pet "jmp",0   ; $41
  6882  504c 4a535200           !pet "jsr",0   ; $42
  6883  5050 4c42434300         !pet "lbcc",0  ; $43
  6884                          mnemonic_lbcc = $43
  6885  5055 4c42435300         !pet "lbcs",0  ; $44
  6886  505a 4c42455100         !pet "lbeq",0  ; $45
  6887  505f 4c424d4900         !pet "lbmi",0  ; $46
  6888  5064 4c424e4500         !pet "lbne",0  ; $47
  6889  5069 4c42504c00         !pet "lbpl",0  ; $48
  6890  506e 4c42524100         !pet "lbra",0  ; $49
  6891  5073 4c42564300         !pet "lbvc",0  ; $4A
  6892  5078 4c42565300         !pet "lbvs",0  ; $4B
  6893                          mnemonic_lbvs = $4B
  6894  507d 4c444100           !pet "lda",0   ; $4C
  6895                          mnemonic_lda = $4C
  6896  5081 4c445100           !pet "ldq",0   ; $4D
  6897                          mnemonic_ldq = $4D
  6898  5085 4c445800           !pet "ldx",0   ; $4E
  6899  5089 4c445900           !pet "ldy",0   ; $4F
  6900  508d 4c445a00           !pet "ldz",0   ; $50
  6901                          mnemonic_ldz = $50
  6902  5091 4c535200           !pet "lsr",0   ; $51
  6903  5095 4c53525100         !pet "lsrq",0  ; $52
  6904                          mnemonic_lsrq = $52
  6905  509a 4d415000           !pet "map",0   ; $53
  6906  509e 4e454700           !pet "neg",0   ; $54
  6907  50a2 4f524100           !pet "ora",0   ; $55
  6908  50a6 4f525100           !pet "orq",0   ; $56
  6909                          mnemonic_orq = $56
  6910  50aa 50484100           !pet "pha",0   ; $57
  6911  50ae 50485000           !pet "php",0   ; $58
  6912  50b2 50485700           !pet "phw",0   ; $59
  6913                          mnemonic_phw = $59
  6914  50b6 50485800           !pet "phx",0   ; $5A
  6915  50ba 50485900           !pet "phy",0   ; $5B
  6916  50be 50485a00           !pet "phz",0   ; $5C
  6917  50c2 504c4100           !pet "pla",0   ; $5D
  6918  50c6 504c5000           !pet "plp",0   ; $5E
  6919  50ca 504c5800           !pet "plx",0   ; $5F
  6920  50ce 504c5900           !pet "ply",0   ; $60
  6921  50d2 504c5a00           !pet "plz",0   ; $61
  6922  50d6 524d423000         !pet "rmb0",0  ; $62
  6923  50db 524d423100         !pet "rmb1",0  ; $63
  6924  50e0 524d423200         !pet "rmb2",0  ; $64
  6925  50e5 524d423300         !pet "rmb3",0  ; $65
  6926  50ea 524d423400         !pet "rmb4",0  ; $66
  6927  50ef 524d423500         !pet "rmb5",0  ; $67
  6928  50f4 524d423600         !pet "rmb6",0  ; $68
  6929  50f9 524d423700         !pet "rmb7",0  ; $69
  6930  50fe 524f4c00           !pet "rol",0   ; $6A
  6931  5102 524f4c5100         !pet "rolq",0  ; $6B
  6932                          mnemonic_rolq = $6B
  6933  5107 524f5200           !pet "ror",0   ; $6C
  6934  510b 524f525100         !pet "rorq",0  ; $6D
  6935                          mnemonic_rorq = $6D
  6936  5110 524f5700           !pet "row",0   ; $6E
  6937  5114 52544900           !pet "rti",0   ; $6F
  6938  5118 52544e00           !pet "rtn",0   ; $70
  6939  511c 52545300           !pet "rts",0   ; $71
  6940  5120 53424300           !pet "sbc",0   ; $72
  6941  5124 5342435100         !pet "sbcq",0  ; $73
  6942                          mnemonic_sbcq = $73
  6943  5129 53454300           !pet "sec",0   ; $74
  6944  512d 53454400           !pet "sed",0   ; $75
  6945  5131 53454500           !pet "see",0   ; $76
  6946  5135 53454900           !pet "sei",0   ; $77
  6947  5139 534d423000         !pet "smb0",0  ; $78
  6948  513e 534d423100         !pet "smb1",0  ; $79
  6949  5143 534d423200         !pet "smb2",0  ; $7A
  6950  5148 534d423300         !pet "smb3",0  ; $7B
  6951  514d 534d423400         !pet "smb4",0  ; $7C
  6952  5152 534d423500         !pet "smb5",0  ; $7D
  6953  5157 534d423600         !pet "smb6",0  ; $7E
  6954  515c 534d423700         !pet "smb7",0  ; $7F
  6955  5161 53544100           !pet "sta",0   ; $80
  6956  5165 53545100           !pet "stq",0   ; $81
  6957                          mnemonic_stq = $81
  6958  5169 53545800           !pet "stx",0   ; $82
  6959  516d 53545900           !pet "sty",0   ; $83
  6960  5171 53545a00           !pet "stz",0   ; $84
  6961  5175 54414200           !pet "tab",0   ; $85
  6962  5179 54415800           !pet "tax",0   ; $86
  6963  517d 54415900           !pet "tay",0   ; $87
  6964  5181 54415a00           !pet "taz",0   ; $88
  6965  5185 54424100           !pet "tba",0   ; $89
  6966  5189 54524200           !pet "trb",0   ; $8A
  6967  518d 54534200           !pet "tsb",0   ; $8B
  6968  5191 54535800           !pet "tsx",0   ; $8C
  6969  5195 54535900           !pet "tsy",0   ; $8D
  6970  5199 54584100           !pet "txa",0   ; $8E
  6971  519d 54585300           !pet "txs",0   ; $8F
  6972  51a1 54594100           !pet "tya",0   ; $90
  6973  51a5 54595300           !pet "tys",0   ; $91
  6974  51a9 545a4100           !pet "tza",0   ; $92
  6975                          mnemonic_tza = $92
  6976  51ad 00                 !byte 0
  6977                          tokid_after_mnemonics = $93
  6978                          
  6979                          ; Token IDs for the Q mnemonics, which all use a $42 $42 encoding prefix
  6980                          q_mnemonics:
  6981  51ae 020406081e         !byte mnemonic_adcq, mnemonic_andq, mnemonic_aslq, mnemonic_asrq, mnemonic_bitq
  6982  51b3 2d2e333a3c         !byte mnemonic_cmpq, mnemonic_cpq,  mnemonic_deq,  mnemonic_eorq, mnemonic_inq
  6983  51b8 4d52566b6d         !byte mnemonic_ldq,  mnemonic_lsrq, mnemonic_orq,  mnemonic_rolq, mnemonic_rorq
  6984  51bd 7381               !byte mnemonic_sbcq, mnemonic_stq
  6985  51bf 00                 !byte 0
  6986                          
  6987                          ; Pseudo-op table
  6988                          ; These tokens are preceded with a "!" character.
  6989                          pseudoops:
  6990                          po_to = tokid_after_mnemonics + 0
  6991  51c0 544f00             !pet "to",0
  6992                          po_byte = tokid_after_mnemonics + 1
  6993  51c3 4259544500         !pet "byte",0
  6994                          po_8 = tokid_after_mnemonics + 2
  6995  51c8 3800               !pet "8",0
  6996                          po_word = tokid_after_mnemonics + 3
  6997  51ca 574f524400         !pet "word",0
  6998                          po_16 = tokid_after_mnemonics + 4
  6999  51cf 313600             !pet "16",0
  7000                          po_32 = tokid_after_mnemonics + 5
  7001  51d2 333200             !pet "32",0
  7002                          po_fill = tokid_after_mnemonics + 6
  7003  51d5 46494c4c00         !pet "fill",0
  7004                          po_pet = tokid_after_mnemonics + 7
  7005  51da 50455400           !pet "pet",0
  7006                          po_scr = tokid_after_mnemonics + 8
  7007  51de 53435200           !pet "scr",0
  7008                          po_source = tokid_after_mnemonics + 9
  7009  51e2 534f5552434500     !pet "source",0
  7010                          po_binary = tokid_after_mnemonics + 10
  7011  51e9 42494e41525900     !pet "binary",0
  7012                          po_warn = tokid_after_mnemonics + 11
  7013  51f0 5741524e00         !pet "warn",0
  7014                          po_cpu = tokid_after_mnemonics + 12
  7015  51f5 43505500           !pet "cpu",0
  7016  51f9 00                 !byte 0
  7017                          last_po = po_cpu + 1
  7018                          
  7019                          ; Other tokens table
  7020                          ; These tokens are lexed up to their length, in order, with no delimiters.
  7021                          ; Note: + and - are tokenized separately.
  7022                          other_tokens:
  7023                          tk_complement = last_po + 0
  7024  51fa 2100               !pet "!",0
  7025                          tk_megabyte = last_po + 1
  7026  51fc 5e5e00             !pet "^^",0
  7027                          tk_power = last_po + 2
  7028  51ff 5e00               !pet "^",0
  7029                          tk_multiply = last_po + 3
  7030  5201 2a00               !pet "*",0
  7031                          tk_remainder = last_po + 4
  7032  5203 2500               !pet "%",0
  7033                          tk_lsr = last_po + 5
  7034  5205 3e3e3e00           !pet ">>>",0
  7035                          tk_asr = last_po + 6
  7036  5209 3e3e00             !pet ">>",0
  7037                          tk_asl = last_po + 7
  7038  520c 3c3c00             !pet "<<",0
  7039                          tk_lt = last_po + 8
  7040  520f 3c00               !pet "<",0
  7041                          tk_gt = last_po + 9
  7042  5211 3e00               !pet ">",0
  7043                          tk_ampersand = last_po + 10
  7044  5213 2600               !pet "&",0
  7045                          tk_pipe = last_po + 11
  7046  5215 dc00               !pet 220,0  ; Typed by Mega + period or Mega + minus
  7047                          tk_comma = last_po + 12
  7048  5217 2c00               !pet ",",0
  7049                          tk_hash = last_po + 13
  7050  5219 2300               !pet "#",0
  7051                          tk_colon = last_po + 14
  7052  521b 3a00               !pet ":",0
  7053                          tk_equal = last_po + 15
  7054  521d 3d00               !pet "=",0
  7055                          tk_lparen = last_po + 16
  7056  521f 2800               !pet "(",0
  7057                          tk_rparen = last_po + 17
  7058  5221 2900               !pet ")",0
  7059                          tk_lbracket = last_po + 18
  7060  5223 5b00               !pet "[",0
  7061                          tk_rbracket = last_po + 19
  7062  5225 5d00               !pet "]",0
  7063                          tk_fraction = last_po + 20  ; (Not supported, but special error message)
  7064  5227 2f00               !pet "/",0
  7065                          tk_pipe2 = last_po + 21
  7066  5229 7c00               !pet "|",0  ; The other PETSCII "pipe" character, just in case.
  7067  522b 00                 !byte 0
  7068                          last_tk = tk_pipe2 + 1
  7069                          
  7070                          ; Other token IDs
  7071                          tk_number_literal = last_tk + 0
  7072                          tk_number_literal_leading_zero = last_tk + 1
  7073                          tk_string_literal = last_tk + 2
  7074                          tk_label_or_reg = last_tk + 3
  7075                          tk_pluses = last_tk + 4
  7076                          tk_minuses = last_tk + 5
  7077                          
  7078                          ; Keywords
  7079                          ; Tokenized as tk_label_or_reg. Case insensitive.
  7080  522c 5800               kw_x: !pet "x",0
  7081  522e 5900               kw_y: !pet "y",0
  7082  5230 5a00               kw_z: !pet "z",0
  7083  5232 535000             kw_sp: !pet "sp",0
  7084  5235 44495600           kw_div: !pet "div",0
  7085  5239 584f5200           kw_xor: !pet "xor",0
  7086  523d 43424d00           kw_cbm: !pet "cbm",0
  7087  5241 504c41494e00       kw_plain: !pet "plain",0
  7088  5247 52554e4e41424c45...kw_runnable: !pet "runnable",0
  7089  5250 4d363500           kw_m65: !pet "m65",0
  7090                          
  7091                          
  7092                          ; ------------------------------------------------------------
  7093                          ; Instruction encodings
  7094                          ;
  7095                          ; The addressing_modes table consists of one entry per instruction mnemonic,
  7096                          ; four bytes per entry, in token ID order.
  7097                          ;
  7098                          ; The first two bytes are an addressing mode bitmask, one bit set for each
  7099                          ; addressing mode supported by the instruction.
  7100                          ;
  7101                          ; The last two bytes are the code address for the encoding list. (See below,
  7102                          ; starting with enc_adc.)
  7103                          ;
  7104                          ; The bit branch instructions, which take two operands, are not uniquely
  7105                          ; represented by this data structure. expect_addressing_expr will return the
  7106                          ; "base page" mode and leave the token position on the comma for further
  7107                          ; processing.
  7108                          ;
  7109                          ;     %11111111,
  7110                          ;      ^ Implied (parameterless, or A/Q)
  7111                          ;       ^ Immediate
  7112                          ;        ^ Immedate word
  7113                          ;         ^ Base-Page, branch relative, bit-test branch relative
  7114                          ;          ^ Base-Page X-Indexed
  7115                          ;           ^ Base-Page Y-Indexed
  7116                          ;            ^ Absolute, 16-bit branch relative
  7117                          ;             ^ Absolute X-Indexed
  7118                          ;               %11111111
  7119                          ;                ^ Absolute Y-Indexed
  7120                          ;                 ^ Absolute Indirect
  7121                          ;                  ^ Absolute Indirect X-Indexed
  7122                          ;                   ^ Base-Page Indirect X-Indexed
  7123                          ;                    ^ Base-Page Indirect Y-Indexed
  7124                          ;                     ^ Base-Page Indirect Z-Indexed (or no index)
  7125                          ;                      ^ 32-bit Base-Page Indirect Z-Indexed (or no index)
  7126                          ;                       ^ Stack Relative Indirect, Y-Indexed
  7127                          MODES_NO_OPERAND     = %1000000000000000
  7128                          MODES_BYTE_OPERAND   = %0101110000011111
  7129                          MODES_WORD_OPERAND   = %0010001111100000
  7130                          MODE_IMPLIED         = %1000000000000000
  7131                          MODE_IMMEDIATE       = %0100000000000000
  7132                          MODE_IMMEDIATE_WORD  = %0010000000000000
  7133                          MODE_BASE_PAGE       = %0001000000000000
  7134                          MODE_BASE_PAGE_X     = %0000100000000000
  7135                          MODE_BASE_PAGE_Y     = %0000010000000000
  7136                          MODE_ABSOLUTE        = %0000001000000000
  7137                          MODE_ABSOLUTE_X      = %0000000100000000
  7138                          MODE_ABSOLUTE_Y      = %0000000010000000
  7139                          MODE_ABSOLUTE_IND    = %0000000001000000
  7140                          MODE_ABSOLUTE_IND_X  = %0000000000100000
  7141                          MODE_BASE_PAGE_IND_X = %0000000000010000
  7142                          MODE_BASE_PAGE_IND_Y = %0000000000001000
  7143                          MODE_BASE_PAGE_IND_Z = %0000000000000100
  7144                          MODE_32BIT_IND       = %0000000000000010
  7145                          MODE_STACK_REL       = %0000000000000001
  7146                          
  7147                          ; If addr mode identified as 8-bit, but instruction only supports the 16-bit
  7148                          ; equivalent, coerce the mode to 16-bit. From A to B:
  7149                          mode16_coercion:
  7150  5254 00400020           !word MODE_IMMEDIATE, MODE_IMMEDIATE_WORD
  7151  5258 00100002           !word MODE_BASE_PAGE, MODE_ABSOLUTE
  7152  525c 00080001           !word MODE_BASE_PAGE_X, MODE_ABSOLUTE_X
  7153  5260 00048000           !word MODE_BASE_PAGE_Y, MODE_ABSOLUTE_Y
  7154  5264 00000000           !word 0,0
  7155                          
  7156                          addressing_modes:
  7157  5268 00000000           !word 0,0 ; dummy entry "0" (tok IDs start at 1)
  7158  526c 9e5b               !word %0101101110011110  ; adc
  7159  526e b454               !word enc_adc
  7160  5270 0612               !word %0001001000000110  ; adcq
  7161  5272 be54               !word enc_adcq
  7162  5274 9e5b               !word %0101101110011110  ; and
  7163  5276 c254               !word enc_and
  7164  5278 0612               !word %0001001000000110  ; andq
  7165  527a cc54               !word enc_andq
  7166  527c 009b               !word %1001101100000000  ; asl
  7167  527e d054               !word enc_asl
  7168  5280 009b               !word %1001101100000000  ; aslq
  7169  5282 d554               !word enc_aslq
  7170  5284 0098               !word %1001100000000000  ; asr
  7171  5286 da54               !word enc_asr
  7172  5288 0098               !word %1001100000000000  ; asrq
  7173  528a dd54               !word enc_asrq
  7174  528c 0002               !word %0000001000000000  ; asw
  7175  528e e054               !word enc_asw
  7176  5290 0010               !word %0001000000000000  ; bbr0
  7177  5292 e154               !word enc_bbr0
  7178  5294 0010               !word %0001000000000000  ; bbr1
  7179  5296 e254               !word enc_bbr1
  7180  5298 0010               !word %0001000000000000  ; bbr2
  7181  529a e354               !word enc_bbr2
  7182  529c 0010               !word %0001000000000000  ; bbr3
  7183  529e e454               !word enc_bbr3
  7184  52a0 0010               !word %0001000000000000  ; bbr4
  7185  52a2 e554               !word enc_bbr4
  7186  52a4 0010               !word %0001000000000000  ; bbr5
  7187  52a6 e654               !word enc_bbr5
  7188  52a8 0010               !word %0001000000000000  ; bbr6
  7189  52aa e754               !word enc_bbr6
  7190  52ac 0010               !word %0001000000000000  ; bbr7
  7191  52ae e854               !word enc_bbr7
  7192  52b0 0010               !word %0001000000000000  ; bbs0
  7193  52b2 e954               !word enc_bbs0
  7194  52b4 0010               !word %0001000000000000  ; bbs1
  7195  52b6 ea54               !word enc_bbs1
  7196  52b8 0010               !word %0001000000000000  ; bbs2
  7197  52ba eb54               !word enc_bbs2
  7198  52bc 0010               !word %0001000000000000  ; bbs3
  7199  52be ec54               !word enc_bbs3
  7200  52c0 0010               !word %0001000000000000  ; bbs4
  7201  52c2 ed54               !word enc_bbs4
  7202  52c4 0010               !word %0001000000000000  ; bbs5
  7203  52c6 ee54               !word enc_bbs5
  7204  52c8 0010               !word %0001000000000000  ; bbs6
  7205  52ca ef54               !word enc_bbs6
  7206  52cc 0010               !word %0001000000000000  ; bbs7
  7207  52ce f054               !word enc_bbs7
  7208  52d0 0010               !word %0001000000000000  ; bcc
  7209  52d2 f154               !word enc_bcc
  7210  52d4 0010               !word %0001000000000000  ; bcs
  7211  52d6 f254               !word enc_bcs
  7212  52d8 0010               !word %0001000000000000  ; beq
  7213  52da f354               !word enc_beq
  7214  52dc 005b               !word %0101101100000000  ; bit
  7215  52de f454               !word enc_bit
  7216  52e0 0012               !word %0001001000000000  ; bitq
  7217  52e2 f954               !word enc_bitq
  7218  52e4 0010               !word %0001000000000000  ; bmi
  7219  52e6 fb54               !word enc_bmi
  7220  52e8 0010               !word %0001000000000000  ; bne
  7221  52ea fc54               !word enc_bne
  7222  52ec 0010               !word %0001000000000000  ; bpl
  7223  52ee fd54               !word enc_bpl
  7224  52f0 0010               !word %0001000000000000  ; bra
  7225  52f2 fe54               !word enc_bra
  7226  52f4 0080               !word %1000000000000000  ; brk
  7227  52f6 ff54               !word enc_brk
  7228  52f8 0002               !word %0000001000000000  ; bsr
  7229  52fa 0055               !word enc_bsr
  7230  52fc 0010               !word %0001000000000000  ; bvc
  7231  52fe 0155               !word enc_bvc
  7232  5300 0010               !word %0001000000000000  ; bvs
  7233  5302 0255               !word enc_bvs
  7234  5304 0080               !word %1000000000000000  ; clc
  7235  5306 0355               !word enc_clc
  7236  5308 0080               !word %1000000000000000  ; cld
  7237  530a 0455               !word enc_cld
  7238  530c 0080               !word %1000000000000000  ; cle
  7239  530e 0555               !word enc_cle
  7240  5310 0080               !word %1000000000000000  ; cli
  7241  5312 0655               !word enc_cli
  7242  5314 0080               !word %1000000000000000  ; clv
  7243  5316 0755               !word enc_clv
  7244  5318 9e5b               !word %0101101110011110  ; cmp
  7245  531a 0855               !word enc_cmp
  7246  531c 0612               !word %0001001000000110  ; cmpq
  7247  531e 1255               !word enc_cmpq
  7248  5320 0612               !word %0001001000000110  ; cpq
  7249  5322 1255               !word enc_cmpq
  7250  5324 0052               !word %0101001000000000  ; cpx
  7251  5326 1655               !word enc_cpx
  7252  5328 0052               !word %0101001000000000  ; cpy
  7253  532a 1955               !word enc_cpy
  7254  532c 0052               !word %0101001000000000  ; cpz
  7255  532e 1c55               !word enc_cpz
  7256  5330 009b               !word %1001101100000000  ; dec
  7257  5332 1f55               !word enc_dec
  7258  5334 009b               !word %1001101100000000  ; deq
  7259  5336 2455               !word enc_deq
  7260  5338 0010               !word %0001000000000000  ; dew
  7261  533a 2955               !word enc_dew
  7262  533c 0080               !word %1000000000000000  ; dex
  7263  533e 2a55               !word enc_dex
  7264  5340 0080               !word %1000000000000000  ; dey
  7265  5342 2b55               !word enc_dey
  7266  5344 0080               !word %1000000000000000  ; dez
  7267  5346 2c55               !word enc_dez
  7268  5348 0080               !word %1000000000000000  ; eom
  7269  534a 2d55               !word enc_eom
  7270  534c 9e5b               !word %0101101110011110  ; eor
  7271  534e 2e55               !word enc_eor
  7272  5350 0612               !word %0001001000000110  ; eorq
  7273  5352 3855               !word enc_eorq
  7274  5354 009b               !word %1001101100000000  ; inc
  7275  5356 3c55               !word enc_inc
  7276  5358 009b               !word %1001101100000000  ; inq
  7277  535a 4155               !word enc_inq
  7278  535c 0010               !word %0001000000000000  ; inw
  7279  535e 4655               !word enc_inw
  7280  5360 0080               !word %1000000000000000  ; inx
  7281  5362 4755               !word enc_inx
  7282  5364 0080               !word %1000000000000000  ; iny
  7283  5366 4855               !word enc_iny
  7284  5368 0080               !word %1000000000000000  ; inz
  7285  536a 4955               !word enc_inz
  7286  536c 6002               !word %0000001001100000  ; jmp
  7287  536e 4a55               !word enc_jmp
  7288  5370 6002               !word %0000001001100000  ; jsr
  7289  5372 4d55               !word enc_jsr
  7290  5374 0002               !word %0000001000000000  ; lbcc
  7291  5376 5055               !word enc_lbcc
  7292  5378 0002               !word %0000001000000000  ; lbcs
  7293  537a 5155               !word enc_lbcs
  7294  537c 0002               !word %0000001000000000  ; lbeq
  7295  537e 5255               !word enc_lbeq
  7296  5380 0002               !word %0000001000000000  ; lbmi
  7297  5382 5355               !word enc_lbmi
  7298  5384 0002               !word %0000001000000000  ; lbne
  7299  5386 5455               !word enc_lbne
  7300  5388 0002               !word %0000001000000000  ; lbpl
  7301  538a 5555               !word enc_lbpl
  7302  538c 0002               !word %0000001000000000  ; lbra
  7303  538e 5655               !word enc_lbra
  7304  5390 0002               !word %0000001000000000  ; lbvc
  7305  5392 5755               !word enc_lbvc
  7306  5394 0002               !word %0000001000000000  ; lbvs
  7307  5396 5855               !word enc_lbvs
  7308  5398 9f5b               !word %0101101110011111  ; lda
  7309  539a 5955               !word enc_lda
  7310  539c 0612               !word %0001001000000110  ; ldq
  7311  539e 6455               !word enc_ldq
  7312  53a0 8056               !word %0101011010000000  ; ldx
  7313  53a2 6855               !word enc_ldx
  7314  53a4 005b               !word %0101101100000000  ; ldy
  7315  53a6 6d55               !word enc_ldy
  7316  53a8 0043               !word %0100001100000000  ; ldz
  7317  53aa 7255               !word enc_ldz
  7318  53ac 009b               !word %1001101100000000  ; lsr
  7319  53ae 7555               !word enc_lsr
  7320  53b0 009b               !word %1001101100000000  ; lsrq
  7321  53b2 7a55               !word enc_lsrq
  7322  53b4 0080               !word %1000000000000000  ; map
  7323  53b6 7f55               !word enc_map
  7324  53b8 0080               !word %1000000000000000  ; neg
  7325  53ba 8055               !word enc_neg
  7326  53bc 9e5b               !word %0101101110011110  ; ora
  7327  53be 8155               !word enc_ora
  7328  53c0 0612               !word %0001001000000110  ; orq
  7329  53c2 8b55               !word enc_orq
  7330  53c4 0080               !word %1000000000000000  ; pha
  7331  53c6 8f55               !word enc_pha
  7332  53c8 0080               !word %1000000000000000  ; php
  7333  53ca 9055               !word enc_php
  7334  53cc 0022               !word %0010001000000000  ; phw
  7335  53ce 9155               !word enc_phw
  7336  53d0 0080               !word %1000000000000000  ; phx
  7337  53d2 9355               !word enc_phx
  7338  53d4 0080               !word %1000000000000000  ; phy
  7339  53d6 9455               !word enc_phy
  7340  53d8 0080               !word %1000000000000000  ; phz
  7341  53da 9555               !word enc_phz
  7342  53dc 0080               !word %1000000000000000  ; pla
  7343  53de 9655               !word enc_pla
  7344  53e0 0080               !word %1000000000000000  ; plp
  7345  53e2 9755               !word enc_plp
  7346  53e4 0080               !word %1000000000000000  ; plx
  7347  53e6 9855               !word enc_plx
  7348  53e8 0080               !word %1000000000000000  ; ply
  7349  53ea 9955               !word enc_ply
  7350  53ec 0080               !word %1000000000000000  ; plz
  7351  53ee 9a55               !word enc_plz
  7352  53f0 0010               !word %0001000000000000  ; rmb0
  7353  53f2 9b55               !word enc_rmb0
  7354  53f4 0010               !word %0001000000000000  ; rmb1
  7355  53f6 9c55               !word enc_rmb1
  7356  53f8 0010               !word %0001000000000000  ; rmb2
  7357  53fa 9d55               !word enc_rmb2
  7358  53fc 0010               !word %0001000000000000  ; rmb3
  7359  53fe 9e55               !word enc_rmb3
  7360  5400 0010               !word %0001000000000000  ; rmb4
  7361  5402 9f55               !word enc_rmb4
  7362  5404 0010               !word %0001000000000000  ; rmb5
  7363  5406 a055               !word enc_rmb5
  7364  5408 0010               !word %0001000000000000  ; rmb6
  7365  540a a155               !word enc_rmb6
  7366  540c 0010               !word %0001000000000000  ; rmb7
  7367  540e a255               !word enc_rmb7
  7368  5410 009b               !word %1001101100000000  ; rol
  7369  5412 a355               !word enc_rol
  7370  5414 009b               !word %1001101100000000  ; rolq
  7371  5416 a855               !word enc_rolq
  7372  5418 009b               !word %1001101100000000  ; ror
  7373  541a ad55               !word enc_ror
  7374  541c 009b               !word %1001101100000000  ; rorq
  7375  541e b255               !word enc_rorq
  7376  5420 0002               !word %0000001000000000  ; row
  7377  5422 b755               !word enc_row
  7378  5424 0080               !word %1000000000000000  ; rti
  7379  5426 b855               !word enc_rti
  7380  5428 0040               !word %0100000000000000  ; rtn
  7381  542a b955               !word enc_rtn
  7382  542c 00c0               !word %1100000000000000  ; rts
  7383  542e ba55               !word enc_rts
  7384  5430 9e5b               !word %0101101110011110  ; sbc
  7385  5432 bc55               !word enc_sbc
  7386  5434 0612               !word %0001001000000110  ; sbcq
  7387  5436 c655               !word enc_sbcq
  7388  5438 0080               !word %1000000000000000  ; sec
  7389  543a ca55               !word enc_sec
  7390  543c 0080               !word %1000000000000000  ; sed
  7391  543e cb55               !word enc_sed
  7392  5440 0080               !word %1000000000000000  ; see
  7393  5442 cc55               !word enc_see
  7394  5444 0080               !word %1000000000000000  ; sei
  7395  5446 cd55               !word enc_sei
  7396  5448 0010               !word %0001000000000000  ; smb0
  7397  544a ce55               !word enc_smb0
  7398  544c 0010               !word %0001000000000000  ; smb1
  7399  544e cf55               !word enc_smb1
  7400  5450 0010               !word %0001000000000000  ; smb2
  7401  5452 d055               !word enc_smb2
  7402  5454 0010               !word %0001000000000000  ; smb3
  7403  5456 d155               !word enc_smb3
  7404  5458 0010               !word %0001000000000000  ; smb4
  7405  545a d255               !word enc_smb4
  7406  545c 0010               !word %0001000000000000  ; smb5
  7407  545e d355               !word enc_smb5
  7408  5460 0010               !word %0001000000000000  ; smb6
  7409  5462 d455               !word enc_smb6
  7410  5464 0010               !word %0001000000000000  ; smb7
  7411  5466 d555               !word enc_smb7
  7412  5468 9f1b               !word %0001101110011111  ; sta
  7413  546a d655               !word enc_sta
  7414  546c 0612               !word %0001001000000110  ; stq
  7415  546e e055               !word enc_stq
  7416  5470 8016               !word %0001011010000000  ; stx
  7417  5472 e455               !word enc_stx
  7418  5474 001b               !word %0001101100000000  ; sty
  7419  5476 e855               !word enc_sty
  7420  5478 001b               !word %0001101100000000  ; stz
  7421  547a ec55               !word enc_stz
  7422  547c 0080               !word %1000000000000000  ; tab
  7423  547e f055               !word enc_tab
  7424  5480 0080               !word %1000000000000000  ; tax
  7425  5482 f155               !word enc_tax
  7426  5484 0080               !word %1000000000000000  ; tay
  7427  5486 f255               !word enc_tay
  7428  5488 0080               !word %1000000000000000  ; taz
  7429  548a f355               !word enc_taz
  7430  548c 0080               !word %1000000000000000  ; tba
  7431  548e f455               !word enc_tba
  7432  5490 0012               !word %0001001000000000  ; trb
  7433  5492 f555               !word enc_trb
  7434  5494 0012               !word %0001001000000000  ; tsb
  7435  5496 f755               !word enc_tsb
  7436  5498 0080               !word %1000000000000000  ; tsx
  7437  549a f955               !word enc_tsx
  7438  549c 0080               !word %1000000000000000  ; tsy
  7439  549e fa55               !word enc_tsy
  7440  54a0 0080               !word %1000000000000000  ; txa
  7441  54a2 fb55               !word enc_txa
  7442  54a4 0080               !word %1000000000000000  ; txs
  7443  54a6 fc55               !word enc_txs
  7444  54a8 0080               !word %1000000000000000  ; tya
  7445  54aa fd55               !word enc_tya
  7446  54ac 0080               !word %1000000000000000  ; tys
  7447  54ae fe55               !word enc_tys
  7448  54b0 0080               !word %1000000000000000  ; tza
  7449  54b2 ff55               !word enc_tza
  7450                          
  7451                          ; ------------------------------------------------------------
  7452                          ; Encoding lists
  7453                          ; Single-byte encodings for each supported addressing mode, msb to lsb in the bitfield
  7454                          ; Quad prefix $42 $42 and 32-bit Indirect prefix $ea are added in code.
  7455                          ; Example:
  7456                          ;   "adc",0,%01011011,%10011110
  7457                          ;             ^ Immediate = $69
  7458                          ;               ^ Base page = $65
  7459                          ;                ^ Base page, X-indexed = $75
  7460                          ;                  ^ Absolute = $6d
  7461                          ;                   ^ Absolute, X-indexed = $7d
  7462                          ;                      ^ Absolute, Y-indexed = $79
  7463                          ;                         ^ Base-Page Indirect X-Indexed = $61
  7464                          ;                          ^ Base-Page Indirect Y-Indexed = $71
  7465                          ;                           ^ Base-Page Indirect Z-Indexed = $72
  7466                          ;                            ^ 32-bit Base-Page Indirect Z-Indexed = ($EA) $72
  7467  54b4 6965756d7d796171...enc_adc : !byte $69, $65, $75, $6d, $7d, $79, $61, $71, $72, $72
  7468  54be 656d7272           enc_adcq: !byte $65, $6d, $72, $72
  7469  54c2 2925352d3d392131...enc_and : !byte $29, $25, $35, $2d, $3d, $39, $21, $31, $32, $32
  7470  54cc 252d3232           enc_andq: !byte $25, $2d, $32, $32
  7471  54d0 0a06160e1e         enc_asl : !byte $0a, $06, $16, $0e, $1e
  7472  54d5 0a06160e1e         enc_aslq: !byte $0a, $06, $16, $0e, $1e
  7473  54da 434454             enc_asr : !byte $43, $44, $54
  7474  54dd 434454             enc_asrq: !byte $43, $44, $54
  7475  54e0 cb                 enc_asw : !byte $cb
  7476  54e1 0f                 enc_bbr0: !byte $0f
  7477  54e2 1f                 enc_bbr1: !byte $1f
  7478  54e3 2f                 enc_bbr2: !byte $2f
  7479  54e4 3f                 enc_bbr3: !byte $3f
  7480  54e5 4f                 enc_bbr4: !byte $4f
  7481  54e6 5f                 enc_bbr5: !byte $5f
  7482  54e7 6f                 enc_bbr6: !byte $6f
  7483  54e8 7f                 enc_bbr7: !byte $7f
  7484  54e9 8f                 enc_bbs0: !byte $8f
  7485  54ea 9f                 enc_bbs1: !byte $9f
  7486  54eb af                 enc_bbs2: !byte $af
  7487  54ec bf                 enc_bbs3: !byte $bf
  7488  54ed cf                 enc_bbs4: !byte $cf
  7489  54ee df                 enc_bbs5: !byte $df
  7490  54ef ef                 enc_bbs6: !byte $ef
  7491  54f0 ff                 enc_bbs7: !byte $ff
  7492  54f1 90                 enc_bcc : !byte $90
  7493  54f2 b0                 enc_bcs : !byte $b0
  7494  54f3 f0                 enc_beq : !byte $f0
  7495  54f4 8924342c3c         enc_bit : !byte $89, $24, $34, $2c, $3c
  7496  54f9 242c               enc_bitq: !byte $24, $2c
  7497  54fb 30                 enc_bmi : !byte $30
  7498  54fc d0                 enc_bne : !byte $d0
  7499  54fd 10                 enc_bpl : !byte $10
  7500  54fe 80                 enc_bra : !byte $80
  7501  54ff 00                 enc_brk : !byte $00
  7502  5500 63                 enc_bsr : !byte $63
  7503  5501 50                 enc_bvc : !byte $50
  7504  5502 70                 enc_bvs : !byte $70
  7505  5503 18                 enc_clc : !byte $18
  7506  5504 d8                 enc_cld : !byte $d8
  7507  5505 02                 enc_cle : !byte $02
  7508  5506 58                 enc_cli : !byte $58
  7509  5507 b8                 enc_clv : !byte $b8
  7510  5508 c9c5d5cdddd9c1d1...enc_cmp : !byte $c9, $c5, $d5, $cd, $dd, $d9, $c1, $d1, $d2, $d2
  7511  5512 c5cdd2d2           enc_cmpq: !byte $c5, $cd, $d2, $d2
  7512  5516 e0e4ec             enc_cpx : !byte $e0, $e4, $ec
  7513  5519 c0c4cc             enc_cpy : !byte $c0, $c4, $cc
  7514  551c c2d4dc             enc_cpz : !byte $c2, $d4, $dc
  7515  551f 3ac6d6cede         enc_dec : !byte $3a, $c6, $d6, $ce, $de
  7516  5524 3ac6d6cede         enc_deq : !byte $3a, $c6, $d6, $ce, $de
  7517  5529 c3                 enc_dew : !byte $c3
  7518  552a ca                 enc_dex : !byte $ca
  7519  552b 88                 enc_dey : !byte $88
  7520  552c 3b                 enc_dez : !byte $3b
  7521  552d ea                 enc_eom : !byte $ea
  7522  552e 4945554d5d594151...enc_eor : !byte $49, $45, $55, $4d, $5d, $59, $41, $51, $52, $52
  7523  5538 454d5252           enc_eorq: !byte $45, $4d, $52, $52
  7524  553c 1ae6f6eefe         enc_inc : !byte $1a, $e6, $f6, $ee, $fe
  7525  5541 1ae6f6eefe         enc_inq : !byte $1a, $e6, $f6, $ee, $fe
  7526  5546 e3                 enc_inw : !byte $e3
  7527  5547 e8                 enc_inx : !byte $e8
  7528  5548 c8                 enc_iny : !byte $c8
  7529  5549 1b                 enc_inz : !byte $1b
  7530  554a 4c6c7c             enc_jmp : !byte $4c, $6c, $7c
  7531  554d 202223             enc_jsr : !byte $20, $22, $23
  7532  5550 93                 enc_lbcc : !byte $93
  7533  5551 b3                 enc_lbcs : !byte $b3
  7534  5552 f3                 enc_lbeq : !byte $f3
  7535  5553 33                 enc_lbmi : !byte $33
  7536  5554 d3                 enc_lbne : !byte $d3
  7537  5555 13                 enc_lbpl : !byte $13
  7538  5556 83                 enc_lbra : !byte $83
  7539  5557 53                 enc_lbvc : !byte $53
  7540  5558 73                 enc_lbvs : !byte $73
  7541  5559 a9a5b5adbdb9a1b1...enc_lda : !byte $a9, $a5, $b5, $ad, $bd, $b9, $a1, $b1, $b2, $b2, $e2
  7542  5564 a5adb2b2           enc_ldq : !byte $a5, $ad, $b2, $b2
  7543  5568 a2a6b6aebe         enc_ldx : !byte $a2, $a6, $b6, $ae, $be
  7544  556d a0a4b4acbc         enc_ldy : !byte $a0, $a4, $b4, $ac, $bc
  7545  5572 a3abbb             enc_ldz : !byte $a3, $ab, $bb
  7546  5575 4a46564e5e         enc_lsr : !byte $4a, $46, $56, $4e, $5e
  7547  557a 4a46564e5e         enc_lsrq: !byte $4a, $46, $56, $4e, $5e
  7548  557f 5c                 enc_map : !byte $5c
  7549  5580 42                 enc_neg : !byte $42
  7550  5581 0905150d1d190111...enc_ora : !byte $09, $05, $15, $0d, $1d, $19, $01, $11, $12, $12
  7551  558b 050d1212           enc_orq : !byte $05, $0d, $12, $12
  7552  558f 48                 enc_pha : !byte $48
  7553  5590 08                 enc_php : !byte $08
  7554  5591 f4fc               enc_phw : !byte $f4, $fc
  7555  5593 da                 enc_phx : !byte $da
  7556  5594 5a                 enc_phy : !byte $5a
  7557  5595 db                 enc_phz : !byte $db
  7558  5596 68                 enc_pla : !byte $68
  7559  5597 28                 enc_plp : !byte $28
  7560  5598 fa                 enc_plx : !byte $fa
  7561  5599 7a                 enc_ply : !byte $7a
  7562  559a fb                 enc_plz : !byte $fb
  7563  559b 07                 enc_rmb0: !byte $07
  7564  559c 17                 enc_rmb1: !byte $17
  7565  559d 27                 enc_rmb2: !byte $27
  7566  559e 37                 enc_rmb3: !byte $37
  7567  559f 47                 enc_rmb4: !byte $47
  7568  55a0 57                 enc_rmb5: !byte $57
  7569  55a1 67                 enc_rmb6: !byte $67
  7570  55a2 77                 enc_rmb7: !byte $77
  7571  55a3 2a26362e3e         enc_rol : !byte $2a, $26, $36, $2e, $3e
  7572  55a8 2a26362e3e         enc_rolq: !byte $2a, $26, $36, $2e, $3e
  7573  55ad 6a66766e7e         enc_ror : !byte $6a, $66, $76, $6e, $7e
  7574  55b2 6a66766e7e         enc_rorq: !byte $6a, $66, $76, $6e, $7e
  7575  55b7 eb                 enc_row : !byte $eb
  7576  55b8 40                 enc_rti : !byte $40
  7577  55b9 62                 enc_rtn : !byte $62
  7578  55ba 6062               enc_rts : !byte $60, $62
  7579  55bc e9e5f5edfdf9e1f1...enc_sbc : !byte $e9, $e5, $f5, $ed, $fd, $f9, $e1, $f1, $f2, $f2
  7580  55c6 e5edf2f2           enc_sbcq: !byte $e5, $ed, $f2, $f2
  7581  55ca 38                 enc_sec : !byte $38
  7582  55cb f8                 enc_sed : !byte $f8
  7583  55cc 03                 enc_see : !byte $03
  7584  55cd 78                 enc_sei : !byte $78
  7585  55ce 87                 enc_smb0: !byte $87
  7586  55cf 97                 enc_smb1: !byte $97
  7587  55d0 a7                 enc_smb2: !byte $a7
  7588  55d1 b7                 enc_smb3: !byte $b7
  7589  55d2 c7                 enc_smb4: !byte $c7
  7590  55d3 d7                 enc_smb5: !byte $d7
  7591  55d4 e7                 enc_smb6: !byte $e7
  7592  55d5 f7                 enc_smb7: !byte $f7
  7593  55d6 85958d9d99819192...enc_sta : !byte $85, $95, $8d, $9d, $99, $81, $91, $92, $92, $82
  7594  55e0 858d9292           enc_stq : !byte $85, $8d, $92, $92
  7595  55e4 86968e9b           enc_stx : !byte $86, $96, $8e, $9b
  7596  55e8 84948c8b           enc_sty : !byte $84, $94, $8c, $8b
  7597  55ec 64749c9e           enc_stz : !byte $64, $74, $9c, $9e
  7598  55f0 5b                 enc_tab : !byte $5b
  7599  55f1 aa                 enc_tax : !byte $aa
  7600  55f2 a8                 enc_tay : !byte $a8
  7601  55f3 4b                 enc_taz : !byte $4b
  7602  55f4 7b                 enc_tba : !byte $7b
  7603  55f5 141c               enc_trb : !byte $14, $1c
  7604  55f7 040c               enc_tsb : !byte $04, $0c
  7605  55f9 ba                 enc_tsx : !byte $ba
  7606  55fa 0b                 enc_tsy : !byte $0b
  7607  55fb 8a                 enc_txa : !byte $8a
  7608  55fc 9a                 enc_txs : !byte $9a
  7609  55fd 98                 enc_tya : !byte $98
  7610  55fe 2b                 enc_tys : !byte $2b
  7611  55ff 6b                 enc_tza : !byte $6b
  7612                          
  7613                          
  7614                          ; ------------------------------------------------------------
  7615                          ; Screen code translation table
  7616                          ; Index: PETSCII code, value: screen code
  7617                          ; Untranslatable characters become spaces.
  7618                          scr_table:
  7619  5600 2020202020202020...!scr $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
  7620  5610 2020202020202020...!scr $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
  7621  5620 2021222324252627...!scr ' ', '!', $22, '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/'
  7622  5630 3031323334353637...!scr '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?'
  7623  5640 0001020304050607...!scr '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o'
  7624  5650 1011121314151617...!scr 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '[', $1c, ']', $1e, $1f
  7625  5660 4041424344454647...!scr $40, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'
  7626  5670 5051525354555657...!scr 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', $5b, $5c, $5d, $5e, $5f
  7627  5680 2020202020202020...!scr $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
  7628  5690 2020202020202020...!scr $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
  7629  56a0 6061626364656667...!scr $60, $61, $62, $63, $64, $65, $66, $67, $68, $69, $6a, $6b, $6c, $6d, $6e, $6f
  7630  56b0 7071727374757677...!scr $70, $71, $72, $73, $74, $75, $76, $77, $78, $79, $7a, $7b, $7c, $7d, $7e, $7f
  7631  56c0 4041424344454647...!scr $40, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'
  7632  56d0 5051525354555657...!scr 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', $5b, $5c, $5d, $5e, $5f
  7633  56e0 6061626364656667...!scr $60, $61, $62, $63, $64, $65, $66, $67, $68, $69, $6a, $6b, $6c, $6d, $6e, $6f
  7634  56f0 7071727374757677...!scr $70, $71, $72, $73, $74, $75, $76, $77, $78, $79, $7a, $7b, $7c, $7d, $7e, $7f
  7635                          
  7636                          
  7637                          ; ------------------------------------------------------------
  7638                          ; Bootstrap
  7639                          
  7640                          bootstrap_basic_preamble:
  7641  5700 12200a00fe022030...!8 $12,$20,$0a,$00,$fe,$02,$20,$30,$3a,$9e,$20
  7642  570b 24                 !pet "$"
  7643  570c 32                 !byte '0' + ((bootstrap_ml_start >> 12) & $0f)
  7644  570d 30                 !byte '0' + ((bootstrap_ml_start >> 8) & $0f)
  7645  570e 31                 !byte '0' + ((bootstrap_ml_start >> 4) & $0f)
  7646  570f 34                 !byte '0' + (bootstrap_ml_start & $0f)
  7647  5710 000000             !8 $00,$00,$00
  7648                          bootstrap_basic_preamble_end:
  7649                          ; (Acme needs this below the preamble so it is defined in the first pass.)
  7650                          bootstrap_ml_start = source_start + 1 + bootstrap_basic_preamble_end - bootstrap_basic_preamble
  7651                          
  7652                          
  7653                          ; ---------------------------------------------------------
  7654                          ; Tests
  7655                          ; ---------------------------------------------------------
  7656                          
  7657                          ; A test suite provides run_test_suite_cmd, run with: SYS $1E04,4
  7658                          
  7659                          !if TEST_SUITE > 0 {
  7660                              !warn "Adding test suite ", TEST_SUITE
  7661                              !source "test_common.asm"
  7662                              !if TEST_SUITE = 1 {
  7663                                  !source "test_suite_1.asm"
  7664                              } else if TEST_SUITE = 2 {
  7665                                  !source "test_suite_2.asm"
  7666                              } else if TEST_SUITE = 3 {
  7667                                  !source "test_suite_3.asm"
  7668                              } else if TEST_SUITE = 4 {
  7669                                  !source "test_suite_4.asm"
  7670                              } else if TEST_SUITE = 5 {
  7671                                  !source "test_suite_5.asm"
  7672                              } else if TEST_SUITE = 6 {
  7673                                  !source "test_suite_6.asm"
  7674                              } else if TEST_SUITE = 7 {
  7675                                  !source "test_suite_7.asm"
  7676                              } else if TEST_SUITE = 8 {
  7677                                  !source "test_suite_8.asm"
  7678                              } else if TEST_SUITE = 9 {
  7679                                  !source "test_suite_9.asm"
  7680                              } else if TEST_SUITE = 10 {
  7681                                  !source "test_suite_10.asm"
  7682                              } else if TEST_SUITE = 11 {
  7683                                  !source "test_suite_11.asm"
  7684                              } else {
  7685                                  !error "Invalid TEST_SUITE; check Makefile"
  7686                              }
  7687                          } else {
  7688                              !warn "No TEST_SUITE requested"
  7689  5713 60                 run_test_suite_cmd: rts
  7690                          }
  7691                          
  7692                          ; ---------------------------------------------------------
  7693                          
  7694                          !warn "EasyAsm remaining code space: ", max_end_of_program - *
  7695                          !if * >= max_end_of_program {
  7696                              !error "EasyAsm code is too large, * = ", *
  7697                          }
